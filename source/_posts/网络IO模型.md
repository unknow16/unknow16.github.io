---
title: 网络IO模型
date: 2018-02-27 10:05:45
tags: Netty
---

### 基础
* 用户空间
* 内核空间
* DMA

参考：http://www.cnblogs.com/xrq730/p/5074199.html

### 同步/异步
该概念比较广，不仅在IO领域，还如同步调用/异步调用、同步请求/异步请求，都是一个意思。关注的是消息通知机制。

* 同步

在发布一个“调用请求”时，在没有得到结果之前，该“调用请求”不会返回，但一旦返回就得到了返回值。即“调用者”主动等待“调用”的结果。

* 异步

正好和同步相反，“调用”发出之后，这个调用就直接返回了，所以没有返回结果。即调用者不能立即得到结果，因此适用于那些对数据一致性要求不高的场景。

获取异步调用的结果，被调用者可通过状态、通知来通知调用者，或通过回调函数处理这个调用，Java中Future/FutureTask、wait/notify。

### 阻塞/非阻塞
关注的是程序在等待调用结果的状态。

阻塞调用指的是调用结果返回之前，当前线程会被挂起，调用线程只有在得到结果之后才会返回。

非阻塞调用指的是在不能立即得到结果之前，该调用不会阻塞当前线程。

### Linux网络I/O模型
由于绝大多数的Java应用都部署在Linux系统上，因此这里谈一下Linux网络I/O模型。

Linux的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file descriptor（fd，文件描述符）。

而对一个Socket的读写也会有相应的描述符，称为Socketfd（Socket描述符），描述符就是一个数字，它指向内核中的一个结构体（结构体，C/C++数据类型，类似Java中的类，存储各种不同类型的数据，这里存储的是文件路径、数据区等一些属性）。

根据UNIX网络编程对I/O模型的分类，UNIX提供了5种I/O模型，分别为：

### 阻塞IO模型（BIO）
阻塞I/O模型就是最常用的I/O模型，缺省情况下所有的文件操作都是阻塞的，以Socket来讲解此模型：在用户空间中调用recvfrom，其系统调用直到数据包到达且被复制到应用进程的缓冲区或者发生错误时才返回，在此期间会一直等待，进程在从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞I/O。

### 非阻塞IO模型（NIO）
recvfrom从用户空间到内核空间的时候，如果该缓冲区没有数据的话，就直接返回一个EWOULDBOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核空间是不是有数据到来，有数据到来则从内核空间复制数据到用户空间。

### I/O复用模型（采用选择器轮询实现非阻塞）

一个多路复用器Selector可以负责成千上万个注册到其上的通道，轮询哪个通道准备好数据了，通知cpu执行io的读取和写入操作。

selctor模式：当io事件（通道）注册到选择器之后，选择器会为其分配一个key,相当于一个标签，选择器采用轮询的方法轮询每个io事件，当io事件就绪后，选择器根据key选择出相应通道，通知其进行数据的读取或写入数据缓冲区。

每个通道都会对选择器进行注册不同的事件状态，以便选择器查找
* SelectionKey.OP_CONNECT
* SelectionKey.OP_ACCEPT
* SelectionKey.OP_READ
* SelectionKey.OP_WRITE

### 信号驱动I/O模型

### 异步I/O模型（无需自己进行读写，操作系统负责将数据从内核拷贝到用户空间）JDK1.7
* AsynchronousChannelGroup
* AsynchronousServerSocketChannel