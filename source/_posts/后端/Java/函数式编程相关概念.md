---
title: 函数式编程相关概念
toc: true
date: 2020-04-18 11:05:29
tags:
categories:
---

## 高阶函数

具体到实际的函数来说，高阶函数以其他函数作为输入，或产生其他函数作为输出。高阶函数使得函数的组合成为可能，更有利于函数的复用。熟悉面向对象的读者对于对象的组合应该不陌生。在划分对象的职责时，组合被认为是优于继承的一种方式。在使用对象组合时，每个对象所对应的职责单一。多个对象通过组合的方式来完成复杂的行为。函数的组合类似对象的组合。

在 Java 中，可以使用函数类型来定义高阶函数，可以作为方法的参数和返回值。Java 标准 API 已经大量使用了这样的方式。比如 Iterable 的forEach 方法就接受一个 Consumer 类型的参数。

## 部分函数（partial function）

部分函数（partial function）是指仅有部分输入参数被绑定了实际值的函数。如下函数 f(a, b, c) = a + b +c 有 3 个参数 a、b 和c。正常情况下调用该函数需要提供全部 3 个参数的值。如果只提供了部分参数的值，如只提供了 a 值，就得到了一个部分函数，其中参数 a 被绑定成了给定值。假设给定的参数 a 的值是1，那新的部分函数的定义是 fa(b, c) = 1 + b + c。由于 a 的实际值可以有无穷多，也有对应的无穷多种可能的部分函数。除了只对 a 绑定值之外，还可以绑定参数 b 和c 的值。

部分函数可以用来为函数提供快捷方式，也就是预先绑定一些常用的参数值。比如函数 add(a, b) = a + b 用来对 2 个参数进行相加操作。可以在 add基础上创建一个部分函数 increase，把参数 b 的值绑定为 1。increase 相当于进行加 1 操作。同样的，把参数值 b 绑定为 -1 可以得到函数decrease。

Java 标准库并没有提供对部分函数的支持，而且由于只提供了 Function 和 BiFunction，部分函数只对 BiFunction有意义。不过我们可以自己实现部分函数。如把一个 BiFunction 转换成一个Function。

## 柯里化（currying）

柯里化（currying）是与λ演算相关的重要概念。通过柯里化，可以把有多个输入的函数转换成只有一个输入的函数，从而可以在λ演算中来表示。柯里化的名称来源于数学家 Haskell  Curry。Haskell Curry 是一位传奇性的人物，以他的名字命令了 3 种编程语言，Haskell、Brook 和 Curry。柯里化是把有多个输入参数的求值过程，转换成多个只包含一个参数的函数的求值过程。对于函数 f(a, b,  c)，在柯里化之后转换成函数 g，则对应的调用方式是 g(a)(b)(c)。函数 (x, y) -> x + y 经过柯里化之后的结果是 x -> (y -> x + y)。

柯里化与部分函数存在一定的关联，但两者是有区别的。部分函数的求值结果永远是实际的函数调用结果；而柯里化函数的求值结果则可能是另外一个函数。以部分函数 fa(b,c) 为例，每次调用 fa 时都必须提供剩余的 2 个参数。求值的结果都是具体的值；而调用柯里化之后的函数g(a) 得到的是另外的一个函数。只有通过递归的方式依次求值之后，才能得到最终的结果。

## 闭包

闭包的概念与高阶函数密切相关。在很多编程语言中，函数都是一等公民，也就是存在语言级别的结构来表示函数。比如 Python 中就有函数类型，JavaScript 中有 function关键词来创建函数。对于这样的语言，函数可以作为其他函数的参数，也可以作为其他函数的返回值。当一个函数作为返回值，并且该函数内部使用了出现在其所在函数的词法域（lexical scope）的自由变量时，就创建了一个闭包。

如下函数 idGenerator 用来创建简单的递增式的 ID 生成器。参数 initialValue 是递增的初始值。返回值是另外一个函数，在调用时会返回并递增count 的值。这段代码就用到了闭包。idGenerator 返回的函数中使用了其所在函数的词法域中的自由变量 count。count不在返回的函数中定义，而是来自包含该函数的词法域。在实际调用中，虽然 idGenerator 函数的执行已经结束，其返回的函数 genId 却仍然可以访问 idGenerator词法域中的变量 count。这是由闭包的上下文环境提供的。

```javascript
function idGenerator(initialValue) {
    let count = initialValue;
    return function() {
           return count++;
    };
}

let genId = idGenerator(0);
genId(); // 0
genId(); // 1
```

函数是闭包对外的呈现部分。在闭包创建之后，闭包的存在与否对函数的使用者是透明的。如genId函数，使用者只需要调用即可，并不需要了解背后是否有闭包的存在。上下文环境则是闭包背后的实现机制，由编程语言的运行时环境来提供。该上下文环境需要为函数创建一个映射，把函数中的每个自由变量与闭包创建时的对应值关联起来，使得闭包可以继续访问这些值。在idGenerator 的例子中，上下文环境负责关联变量 count 的值，该变量可以在返回的函数中继续访问和修改。

从上述两个要点也可以得出闭包这个名字的由来。闭包是用来封闭自由变量的，适合用来实现内部状态。比如count 是无法被外部所访问的。一旦 idGenerator 返回之后，唯一的引用就来自于所返回的函数。在 JavaScript 中，闭包可以用来实现真正意义上的私有变量。

从闭包的使用方式可以得知，闭包的生命周期长于创建它的函数。因此，自由变量不能在堆栈上分配；否则一旦函数退出，自由变量就无法继续访问。因此，闭包所访问的自由变量必须在堆上分配。也正因为如此，支持闭包的编程语言都有垃圾回收机制，来保证闭包所访问的变量可以被正确地释放。同样，不正确地使用闭包可能造成潜在的内存泄漏。

闭包的一个重要特性是其中的自由变量所绑定的是闭包创建时的值，而不是变量的当前值。如下是一个简单的 HTML 页面的代码，其中有 3 个按钮。用浏览器打开该页面时，点击 3个按钮会发现，所弹出的值全部都是 3。这是因为当点击按钮时，循环已经执行完成，i 的当前值已经是 3。所以按钮的 click 事件处理函数所得到是 i 的当前值 3。

```html
<!DOCTYPE html>
<html lang="en">
<head>
   <title>Test</title>
</head>
<body>
   <button>Button 1</button>
   <button>Button 2</button>
   <button>Button 3</button>
</body>
<script>
   var buttons = document.getElementsByTagName("button");
   for (var i = 0; i < buttons.length; i++) {          
     buttons[i].addEventListener("click", function() {
       alert(i);              
     });
   }
</script>
</html>
```

如下就可以得到所期望的结果。我们创建了一个匿名函数并马上调用该函数来返回真正的事件处理函数。处理函数中访问的变量 i 现在成为了闭包的自由变量，因此 i 的值被绑定到闭包创建时的值，也就是每个循环执行过程中的实际值。

```javascript
var buttons = document.getElementsByTagName("button");
for (var i = 0; i < buttons.length; i++) {          
   buttons[i].addEventListener("click", function(i) {
      return function() {
        alert(i);              
      }
    }(i));
}
```

在 Java 中有与闭包类似的概念，那就是匿名内部类。在匿名内部类中，可以访问词法域中声明为 final 的变量。不是 final的变量无法被访问，会出现编译错误。匿名内部类提供了一种方式来共享局部变量。不过并不能对该变量的引用进行修改。如下变量 latch被两个匿名内部类所使用。

```java
public class InnerClasses {

  public static void main(String[] args) {
    final CountDownLatch latch = new CountDownLatch(1);

    final Future<?> task1 = ForkJoinPool.commonPool().submit(() -> {
      try {
        Thread.sleep(ThreadLocalRandom.current().nextInt(2000));
      } catch (InterruptedException e) {
        e.printStackTrace();
      } finally {
        latch.countDown();
      }
    });

    final Future<?> task2 = ForkJoinPool.commonPool().submit(() -> {
      final long start = System.currentTimeMillis();
      try {
        latch.await();
      } catch (InterruptedException e) {
        e.printStackTrace();
      } finally {
        System.out.println("Done after " + (System.currentTimeMillis() - start) + "ms");
      }
    });

    try {
      task1.get();
      task2.get();
    } catch (InterruptedException | ExecutionException e) {
      e.printStackTrace();
    }
  }
}
```

可以被共享的变量必须声明为 final。这个限制只对变量引用有效。只要对象本身是可变的，仍然可以修改该对象的内容。比如一个 List 类型的变量，虽然对它的引用是 final的，仍然可以通过其方法来修改 List 内部的值。

## 递归

递归（recursion）是编程中的一个重要概念。很多编程语言，不仅限于函数式编程语言，都有递归这样的结构。从代码上来说，递归允许一个函数在其内部调用该函数自身。有些函数式编程语言并没有循环这样的结构，而是通过递归来实现循环。递归和循环在表达能力上是相同的，只不过命令式编程语言偏向于使用循环，而函数式编程语言偏向于使用递归。递归的优势在于天然适合于那些需要用分治法（divide         and          conquer）解决的问题，把一个大问题划分成小问题，以递归的方式解决。经典的通过递归解决的问题包括阶乘计算、计算最大公约数的欧几里德算法、汉诺塔、二分查找、树的深度优先遍历和快速排序等。

递归分为单递归和多递归。单递归只包含一个对自身的引用；而多递归则包含多个对自身的引用。单递归的例子包括列表遍历和计算阶乘等；多递归的例子包括树遍历等。在具体的编程实践中，单递归可以比较容易改写成使用循环的形式，而多递归则一般保持递归的形式。

```javascript
// 递归方式计算阶乘
int fact(n) {
  if (n === 0) {
      return 1;
  } else {
      return n * fact(n - 1);
  }
}
```

有一种特殊的递归方式叫尾递归。如果函数中的递归调用都是尾调用，则该函数是尾递归函数。尾递归的特性使得递归调用不需要额外的空间，执行起来也更快。不少编程语言会自动对尾递归进行优化。

下面我们以欧几里德算法来说明一下尾递归。该算法的 Java 实现比较简单。函数 gcd 的尾调用是递归调用 gcd 本身。

```javascript
int gcd(x, y) {
   if (y == 0) {
      return x;
   }
   return gcd(y, x % y);
}
```

尾递归的特性在于实现时可以复用函数的当前调用栈的帧。当函数执行到尾调用时，只需要简单的 goto语句跳转到函数开头并更新参数的值即可。相对于循环，递归的一个大的问题是层次过深的函数调用栈导致占用内存空间过大。对尾递归的优化，使得递归只需要使用与循环相似大小的内存空间。

## 记忆化

记忆化（memoization）也是函数式编程中的重要概念，其核心思想是以空间换时间，提高函数的执行性能，尤其是使用递归来实现的函数。使用记忆化要求函数具有引用透明性，从而可以把函数的调用结果与调用时的参数关联起来。通常是做法是在函数内部维护一个查找表。查找表的键是输入的参数，对应的值是函数的返回结果。在每次调用时，首先检查内部的查找表，如果存在与输入参数对应的值，则直接返回已经记录的值。否则的话，先进行计算，再用得到的值更新查找表。通过这样的方式可以避免重复的计算。

最典型的展示记忆化应用的例子是计算斐波那契数列 (Fibonacci sequence)。该数列的表达式是F[n]=F[n-1]+F[n-2] (n>=2,F[0]=0,F[1]=1)。如下是斐波那契数列的一个简单实现，直接体现了斐波那契数列的定义。函数 fib         可以正确完成数列的计算，但是性能极差。当输入 n 的值稍微大一些的时候，计算速度就非常之慢，甚至会出现无法完成的情况。这是因为里面有太多的重复计算。比如在计算 fib(4) 的时候，会计算 fib(3) 和 fib(2)。在计算 fib(3) 的时候，也会计算 fib(2)。由于 fib 函数的返回值仅由参数 n 决定，当第一次得出某个 n  对应的结果之后，就可以使用查找表把结果保存下来。这里需要使用 BigInteger 来表示值，因为 fib 函数的值已经超出了 Long 所能表示的范围。

```java
// 计算斐波那契数列的朴素实现
import java.math.BigInteger;
 
public class Fib {
 
     public static void main(String[] args) {
       System.out.println(fib(40));
     }

     private static BigInteger fib(int n) {
       if (n == 0) {
         return BigInteger.ZERO;
       } else if (n == 1) {
         return BigInteger.ONE;
       }
       return fib(n - 1).add(fib(n - 2));
     }
}
```

如下是使用记忆化之后的计算类 FibMemoized。已经计算的值保存在查找表 lookupTable中。每次计算之前，首先查看查找表中是否有值。改进后的函数的性能有了数量级的提升，即便是 fib(100) 也能很快完成。

```java
import java.math.BigInteger;
import java.util.HashMap;
import java.util.Map;
 
public class FibMemoized {
 
 public static void main(String[] args) {
   System.out.println(fib(100));
 }
 
 private static Map<Integer, BigInteger> lookupTable = new 
HashMap<>();
 
 static {
   lookupTable.put(0, BigInteger.ZERO);
   lookupTable.put(1, BigInteger.ONE);
 }
 
 private static BigInteger fib(int n) {
   if (lookupTable.containsKey(n)) {
     return lookupTable.get(n);
   } else {
     BigInteger result = fib(n - 1).add(fib(n - 2));
     lookupTable.put(n, result);
     return result;
   }
 }
}
```

## 参考资料

> - []()
> - []()
