---
title: JVM-基础知识
toc: true
date: 2021-03-12 15:42:47
tags:
categories:
---

## 内存结构
![](JVM-基础知识/jmm.png)

### 程序计数器
作用：用于保存JVM中下一条所要执行的指令的地址，线程私有的，即每个线程都会有一个，因为CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道继续执行哪一句指令

是唯一个在JVM规范中没有规定内存溢出的。

### 虚拟机栈
栈帧: Java程序从Main方法开始单线程中顺序执行，同时伴随着方法的调用，执行到每个方法内时，它们都有自己的环境，这样的每个方法环境称为栈帧。

虚拟机栈内存用来以栈的数据结构存储栈帧，每调用一个方法会发生一次栈帧的入栈，方法执行完毕，该栈帧出栈。方法的调用链可能会很深，但总是只有栈顶的栈帧处于执行状态，称为当前栈帧，该栈帧关联的方法称为当前方法，执行引擎执行的字节码指令只对当前栈帧执行操作。每个栈帧中包含方法局部变量表，操作数栈，动态链接，返回地址。编译时，方法内的局部变量及操作都已确定，所以当进入调用到该方法时，栈帧中的局部变量表的大小，操作数栈的大小都能确定，进而栈帧的大小也能确定。

每开启一个新线程，会伴随分配一块虚拟机栈内存，用来执行该线程的代码，所以它是每个线程一份。

栈内存溢出：Java.lang.stackOverflowError 

### 本地方法栈
JVM中用来调用本地原生Native方法时分配使用的栈内存。因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法去调用本地的C或者C++方法。

HotSpot虚拟机之间将该内存区域和Java栈合并。

### 堆内存
- JVM内存中最大的一块
- 通过new关键字创建的对象都会被放在堆内存
- 所有线程共享
- 堆内存中的对象都需要考虑线程安全问题
- 有垃圾回收机制，根据垃圾收集器的实现不同，又会细分为，新生代区、老生代区、永久代区
- 堆内存溢出：java.lang.OutofMemoryError

### 方法区/非堆内存/永久代
* 类字节码：运行Java程序时，会加载类的class字节码文件到内存中，会存储在这个区。
* 常量，如：字符串常量
* 类的静态成员变量
* 编译器编译后的类的方法的定义代码

JDK8,改名叫 Native Memory, 即Metaspace空间

> 常见问题

垃圾回收是否涉及栈内存？ 不需要。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。
栈内存的分配越大越好吗？不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。
方法内的局部变量是否是线程安全的？如果方法内局部变量没有逃离方法的作用范围，则是线程安全的。如果如果局部变量引用了对象，并逃离了方法的作用范围，则需要考虑线程安全问题


## 参考资料
> - []()
> - []()
