---
title: 概述
toc: true
date: 2020-12-18 14:33:14
tags:
categories:
---

## 什么是数据结构？

官方解释：数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。
大白话：数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据


## 数据结构分类
传统上，我们可以把数据结构分为逻辑结构和物理结构两大类。

逻辑结构分类：逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类，也是我们后面课题中需要关注和讨论的问题。

- 集合结构：集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。
- 线性结构：线性结构中的数据元素之间存在一对一的关系
- 树形结构：树形结构中的数据元素之间存在一对多的层次关系
- 图形结构：图形结构的数据元素是多对多的关系

物理结构分类：逻辑结构在计算机中真正的表示方式（又称为映像）称为物理结构，也可以叫做存储结构。常见的物理结构有顺序存储结构、链式存储结构。

- 顺序存储结构：把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的数组就是顺序存储结构。
- 链式存储结构：是把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。

## 什么是算法？
官方解释：算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。
大白话：根据一定的条件，对一些数据进行计算，得到需要的结果。

在生活中，我们如果遇到某个问题，常常解决方案不是唯一的。例如从西安到北京，如何去？会有不同的解决方案，我们可以坐飞机，可以坐火车，可以坐汽车，甚至可以步行，不同的解决方案带来的时间成本和金钱成本是不一样的，比如坐飞机用的时间最少，但是费用最高，步行费用最低，但时间最长。再例如在北京二环内买一套四合院，如何付款？也会有不同的解决方案，可以一次性现金付清，也可以通过银行做按揭。这两种解决方案带来的成本也不一样，一次性付清，虽然当时出的钱多，压力大，但是没有利息，按揭虽然当时出的钱少，压力比较小，但是会有利息，而且30年的总利息几乎是贷款额度的一倍，需要多付钱。在程序中，我们也可以用不同的算法解决相同的问题，而不同的算法的成本也是不相同的。

总体上，一个优秀的算法追求以下两个目标：
1. 花最少的时间完成需求；
2. 占用最少的内存空间完成需求；

## 算法分析
我们要计算算法时间耗费情况，首先我们得度量算法的执行时间，那么如何度量呢？

事后分析估算方法：比较容易想到的方法就是我们把算法执行若干次，然后拿个计时器在旁边计时，这种事后统计的方法看上去的确不错，并且也并非要我们真的拿个计算器在旁边计算，因为计算机都提供了计时的功能。这种统计方法主要是通过设计好的测试程序和测试数据，利用计算机计时器对不同的算法编制的程序的运行时间进行比较，从而确定算法效率的高低，但是这种方法有很大的缺陷：必须依据算法实现编制好的测试程序，通常要花费大量时间和精力，测试完了如果发现测试的是非常糟糕的算法，那么之前所做的事情就全部白费了，并且不同的测试环境(硬件环境)的差别导致测试的结果差异也很大。

事前分析估算方法：在计算机程序编写前，依据统计方法对算法进行估算，经过总结，我们发现一个高级语言编写的程序程序在计算机上运行所消耗的时间取决于下列因素：
1. 算法采用的策略和方案；
2. 编译产生的代码质量；
3. 问题的输入规模(所谓的问题输入规模就是输入量的多少)；
4. 机器执行指令的速度；

由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于算法的好坏和问题的输入规模。如果算法固定，那么该算法的执行时间就只和问题的输入规模有关系了。

所以我们研究算法复杂度，侧重的是当输入规模不断增大时，算法的增长量的一个抽象(规律)，而不是精确地定位需要执行多少次，因为如果是这样的话，我们又得考虑回编译期优化等问题，容易主次跌倒。我们不关心编写程序所用的语言是什么，也不关心这些程序将跑在什么样的计算机上，我们只关心它所实现的算法。这样，不计那些循环索引的递增和循环终止的条件、变量声明、打印结果等操作，最终在分析程序的运行时间时，最重要的是把程序看做是独立于程序设计语言的算法或一系列步骤。我们分析一个算法的运行时间，最重要的就是把核心操作的次数和输入规模关联起来。总上所述，在我们比较算法随着输入规模的增长量时，可以有以下规则：
1. 算法函数中的常数可以忽略；
2. 算法函数中最高次幂的常数因子可以忽略；
3. 算法函数中最高次幂越小，算法效率越高。

## 算法时间复杂度分析
大O记法定义：在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的量级。算法的时间复杂度，就是算法的时间量度，记作:T(n)=O(f(n))。它表示随着问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中f(n)是问题规模n的某个函数。

在这里，我们需要明确一个事情：执行次数=执行时间

用大写O()来体现算法时间复杂度的记法，我们称之为大O记法。一般情况下，随着输入规模n的增大，T(n)增长最慢的算法为最优算法。如果用大O记法表示上述每个算法的时间复杂度，应该如何表示呢？基于我们对函数渐近增长的分析，推导大O阶的表示法有以下几个规则可以使用：
1. 用常数1取代运行时间中的所有加法常数；
2. 在修改后的运行次数中，只保留高阶项；
3. 如果最高阶项存在，且常数因子不为1，则去除与这个项相乘的常数；

### 常见的大O阶
线性阶：一般含有非嵌套循环涉及线性阶，线性阶就是随着输入规模的扩大，对应计算次数呈直线增长
平方阶：一般嵌套循环属于这种时间复杂度
立方阶：一般三层嵌套循环属于这种时间复杂度
对数阶：对于对数阶，由于随着输入规模n的增大，不管底数为多少，他们的增长趋势是一样的，所以我们会忽略底数。
常数阶：一般不涉及循环操作的都是常数阶，因为它不会随着n的增长而增加操作次数。

描述 | 增长的数量级 | 说明  | 举例
-- | -- | -- | --
常数级别 | 1    |  普通语句 | 将两个数相加
对数级别 | logN |  二分策略 | 二分查找
线性级别 | N    |  循环     | 找出最大元素
线型对数级别 | NlogN | 分治思想 | 归并排序
平方级别 | N^2 | 双层循环 | 检查所有元素对
立方级别 | N^3 | 三层循环 | 检查所有三元组
指数级别 | 2^N | 穷举查找 | 检查所有子集

他们的复杂程度从低到高依次为：
> O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)

根据前面的折线图分析，我们会发现，从平方阶开始，随着输入规模的增大，时间成本会急剧增大，所以，我们的算法，尽可能的追求的是O(1),O(logn),O(n),O(nlogn)这几种时间复杂度，而如果发现算法的时间复杂度为平方阶、立方阶或者更复杂的，那我们可以分为这种算法是不可取的，需要优化。

### 最坏情况
从心理学角度讲，每个人对发生的事情都会有一个预期，比如看到半杯水，有人会说：哇哦，还有半杯水哦！但也有人会说：天哪，只有半杯水了。一般人处于一种对未来失败的担忧，而在预期的时候趋向做最坏的打算，这样即使最糟糕的结果出现，当事人也有了心理准备，比较容易接受结果。假如最糟糕的结果并没有出现，当事人会很快乐。算法分析也是类似，假如有一个需求：有一个存储了n个随机数字的数组，请从中查找出指定的数字。

最好情况：查找的第一个数字就是期望的数字，那么算法的时间复杂度为O(1)
最坏情况：查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为O(n)
平均情况：任何数字查找的平均成本是O(n/2)

最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非特别指定，我们提到的运行时间都指的是最坏情况下的运行时间。

## 算法空间复杂度分析
计算机的软硬件都经历了一个比较漫长的演变史，作为为运算提供环境的内存，更是如此，从早些时候的512k,经历了1M，2M，4M...等，发展到现在的8G，甚至16G和32G，所以早期，算法在运行过程中对内存的占用情况也是一个经常需要考虑的问题。我们可以用算法的空间复杂度来描述算法对内存的占用。

由于现在的计算机设备内存一般都比较大，基本上个人计算机都是4G起步，大的可以达到32G，所以内存占用一般情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。

但是，如果你做的程序是嵌入式开发，尤其是一些传感器设备上的内置程序，由于这些设备的内存很小，一般为几kb，这个时候对算法的空间复杂度就有要求了，但是一般做java开发的，基本上都是服务器开发，一般不存在这样的问题。


## 参考资料
> - []()
> - []()
