---
title: 03-垃圾收集器
date: 2018-01-12 17:15:57
tags: JVM
---

http://www.importnew.com/26383.html

JVM中，程序计数器、虚拟机栈、本地方法栈都是跟随着线程的生命周期，随着线程的结束，内存会被自动回收，而栈帧也是随着方法的调用进入和结束，内存同时也被回收。

但堆内存和方法区内存是动态分配和使用的，所以垃圾收集主要处理JVM堆内存的。

### 判断对象是否存活
* 引用计数

对象每被引用一次，引用计数加一，引用释放减一，为0时，即没有变量引用它，则会被回收。会存在循环引用问题。

* GC Roots可达性分析

从GC Roots向下搜索，搜索走过的路径称为引用链，能够搜索到的对象为存活对象，不能搜索到的对象可被回收。

### 垃圾收集算法
* 标记-清除算法

标记和清除的效率都不高

会产生空间碎片。

适用：存活对象多，回收对象少。 老年代

* 复制算法

两块大小相同的内存，只使用一块，用完后将该块中存活的对象复制到另一块上。

解决碎片问题，但浪费内存。

适用：存活对象少，回收对象多。 新生代

* 标记-压缩算法

标记是和“标记清除”一样的，但不清除，而是将标记的存活对象向一端移动，然后清除掉端边界外的内存。

* 分代收集算法

假设：绝大部分对象的存活时间都很短。

将Java堆分为新生代和老生代。

新生代：大部分对象存活很短，需回收的较多，可选择复制算法，用较小的复制存活对象成本就可以回收大部分垃圾对象。

老生代：存活时间较长，垃圾对象较少，可采用标记清除或标记压缩算法来回收。

### 收集器
#### Serial 收集器（串行）

单线程执行。

会stop the world,造成程序停顿。

新生代复制算法，老生代标记-压缩。

#### ParNew 收集器

串行收集器的并行版本。

新生代并行，老年代串行，新生代复制算法，老生代标记-压缩。

#### Parallel Scavenge 收集器（吞吐量）

类似ParNew收集器

* Parallel Old 收集器

Parallel Scavenge的老年代版本。

---

#### CMS 收集器（并发标记清除， 最短回收停顿时间为目标）

标记清除算法

#### G1(GarbageFirst)收集器

标记整理算法