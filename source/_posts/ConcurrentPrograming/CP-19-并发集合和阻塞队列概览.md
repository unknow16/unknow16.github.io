---
title: CP-19-并发集合和阻塞队列概览
date: 2018-11-13 21:36:46
tags: ConcurrentPrograming
---

以下集合都是线程安全的。

## 并发Map集合
1. ConcurrentHashMap：HashMap的并发版本
2. ConcurrentSkipListMap：支持并发排序类似treeMap

## 并发List/Set集合
1. CopyOnWriteArrayList
2. CopyOnWriteArraySet

上述一两者都是Copy-On-Write容器，适用于读多写少。写时复制，指当往一个容器中做写（add,del,update）操作时，不直接往当前容器中添加
而是将当前容器进行copy，复制出一个新的容器，然后对容器进行写操作，
完成之后，再将原容器的引用指向新的容器，
这样做可以对CopyOnWrite容器进行并发的读，而不需要加锁，
提现读写分离的思想，读和写不同的容器、

## 非阻塞并发队列
1. ConcurrentLinkedQueue

基于链表的无界线程安全队列，采用循环CAS的方式实现非阻塞

## 阻塞队列
1. ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列
2. LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列
3. PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列
4. SynchronousQueue: 一个不存储元素的阻塞队列
5. DelayQueue： 一个支持延时获取元素的无界阻塞队列
6. LinkedTransferQueue：一个由链表结构组成的无界阻塞队列
7. LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列


方法\处理方式 | 抛出异常 | 返回特殊值 | 一直阻塞 | 超时退出
---|---|---|---|---|
插入方法 | add(e) | offer(e) | put(e) | offer(e, time, unit)
移除方法 | remove(e) | poll(e) | take() | poll(time, unit)
检查方法 | element() | peek() | 不可用 | 不可用

* 抛出异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。
* 返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null
* 一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。
* 超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。

## LinkedBlockingQueue
此队列的默认和最大长度是Integer.MAX_VALUE。

## PriorityBlockingQueue
此队列默认采用自然升序排列，两种方法自定义排序：
1. 元素实现compareTo()方法
2. 构造队列时指定Comparator

## SynchronousQueue
SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue的吞吐量高于LinkedBlockingQueue 和 ArrayBlockingQueue。

## DelayQueue
1. 支持延时获取元素的无界阻塞队列，基于PriorityQueue实现
2. 队列中的元素必须实现Delayed接口，可参考ScheduledThreadPoolExecutor里的ScheduledFutureTask类
3. 在创建元素时可以指定多久才能从队列中获取该元素，只有在延时满后才能取出该元素，在没到延时时间获取元素时会阻塞当前线程

- 应用场景

1. 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程去轮询，一但能从DelayQueue中获取到元素时，表示缓存有效期到了
2. 定时任务调度：使用DelayQueue保存当天要执行的任务和执行时间，一但从其中获取到任务就开始执行，如TimerQueue就是使用DelayQueue实现的

## LinkedTransferQueue
多了两个方法：tryTransfer和transfer

- transfer方法

如果当前有消费者在等待接收元素，该方法会把生产出来的元素直接传输给消费者，否则就将该元素放到队尾，阻塞等待该元素被消费了再返回

- tryTransfer方法

见名知义，该方法用来试探生产者传入的元素是否能直接传给消费者，如果没有消费者在等待获取，则返回false，不会阻塞。

## LinkedBlockingDeque
一个由链表结构组成的双向阻塞队列，可以运用在“工作窃取”模式中。