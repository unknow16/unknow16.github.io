---
title: 后端面试题
toc: true
date: 2021-03-11 11:01:10
tags:
categories:
---

## Spring

## SpringBoot

## SpringCloud

## Dubbo

## Mybatis

## Netty

## Java集合相关
### HashMap死链
1.7及之前，在并发时，多线程同时执行扩容的迁移数据方法中，将冲突的链表转移时，采用了头插法造成死循环

1.8之后，底层数据结构采用了数组+链表或红黑树，迁移链表采用了尾插法，避免死链，链元素超8个会转化成红黑树

### ConcurrentHashMap结构
1.7及之前:
- Segament 是一个ConcurrentHashMap内部类，底层结构与 HashMap 一致。另外Segament 继承自 ReentrantLock。Segament数组初始化后不能扩容，决定的并发度。
- 当新元素加入 ConcurrentHashMap 时，首先根据 key hash 值找到相应的 Segament。接着直接对 Segament 上锁，若获取成功，后续操作步骤如同 HashMap。由于锁的存在，Segament 内部操作都是并发安全，同时由于其他 Segament 未被占用，因此可以支持 concurrencyLevel 个线程安全的并发读写。
- size 统计问题：内部有modCount成员变量，即修改计数，每次修改删除元素都会更新它，size方法默认连续两次获取到相同的modCount，就直接返回该值，需注意该值不一定准去，如果连续三次结果都有同，会依次给segament加锁，重新计算结果

## Java相关
### 为什么说 Java 语言“编译与解释并存”？
我觉的编译有两层含义：1是Java源代码编译成字节码，2是JIT编译器，会在运行时将热点代码编译成机器码，保存下来下次直接使用。

Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。

在解释执行时，即.class->机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。

HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。

### 字符型常量和字符串常量的区别?
形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的 0 个或若干个字符
含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)
占内存大小： 字符常量只占 2 个字节; 字符串常量占若干个字节 (注意： char 在 Java 中占两个字节),

### == 和 equals() 和 hashCode()
- 对于基本类型来说，没有equals方法，只能用==， 比较的是值
- 对于引用类型来说，==比较的是引用地址， equals默认情况下，比较的也是引用地址。但是我们可以重写equals方法，来达到比较值的目的。 
- 重写equals方法，一定要重写hashcode方法，使两个对象equals返回true时，他们的hashCode相同。 否则会导致使用hash算法的集合出问题。
- 如果两个变量equals返回true, 那么两个变量的hashcode一定相同。 两个变量的hashcode相同，equals方法不一定返回true

hashCode()的作用: 获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置，可以快速找到所需要的对象。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。

### 如何解决hash冲突
hash冲突，又称hash碰撞，指的就是key的hashcode相同

1. 链地址法：它的基本思想是将冲突的实体链成一个单向链表，再将其头节点放入通过hashcode定位的哈希表的相应位置，适用于经常添加和删除的场景
2. 开放定址法：将key通过hash函数运算后，将值再次hash探测空地址，该hash函数中会有一个变量变化，根据该变量不同，又分为线性探测、二次方探测、随机探测
3. 再哈希法：准备多个hash函数，冲突时依次hash直到不冲突，元素不会聚集，但会增加计算时间
4. 将哈希表分为基础表和益出表，凡是发生冲突的放入溢出表

### final 在 java 中有什么作用？
final作为Java中的关键字可以用于三个地方：用于修饰类、类属性和类方法。

- 修饰类：表示该类不能被继承；
- 修饰方法：表示方法不能被重写；
- 修饰变量：表示变量只能一次赋值以后值不能被修改，但是这里的"不能够被改变"对于不同的数据类型是有不同的含义的。当final修饰的是一个基本数据类型数据时, 这个数据的值在初始化后将不能被改变。当final修饰的是一个引用类型数据时, 也就是修饰一个对象时, 引用在初始化后将永远指向一个内存地址, 不可修改. 但是该内存地址中保存的对象信息, 是可以进行修改的。

### Math.round(-1.5) 等于多少？
round:返回四舍五入，负.5小数返回较大整数，如-1.5返回-1。
ceil:返回小数所在两整数间的较大值，如-1.5返回-1。
floor:返回小数所在两整数间的较小值，如-1.5返回-2。

### 为什么要使用克隆和如何实现对象克隆？
想对一个对象进行处理，又想保存原对象的数据时，可以用克隆
Object 的 clone() 方法是浅拷贝，即如果类中属性有自定义引用类型，只拷贝引用，不拷贝引用指向的对象。

要实现深克隆，有两种方法：
1. 实现 Cloneable 接口，如果包含引用类型，其也要实现Cloneable接口，分别重写 clone() 方法，写代码实现克隆
2. 实现Serializable 接口，写方法序列化this，再读出来


## 问题排查
### java进程 cpu100%问题排查
- 可能死循环，可能业务代码，也可能是HashMap，查看堆栈，发现程序都卡在了HashMap.get()这个方法上了，重启程序后问题消失。但是过段时间又会来
- 可能内存不够导致gc线程一直在运行回收

排查java cpu100%的问题，大致步骤是固定的，首先找到占用cpu的进程，如果是java进程，则继续查看是哪个线程占用cpu，然后根据线程id从线程栈中找到对应线程栈，到这里，问题基本也就解决了。
1. top找到进程
2. jstack导出进程的线程栈，如果都是gc线程，表示内存不够用了，要进行内存回收，但是对象都在用，内存不能回收不了，导致一直gc
3. jmap导出堆内存，只导出live对象，用jvisualVM查看快照，按照大小排序，找出占用内存最大的类别，居然是字节数组，再定位代码


## 参考资料
> - []()
> - []()
