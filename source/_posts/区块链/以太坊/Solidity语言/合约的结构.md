---
title: 合约的结构
toc: true
date: 2019-12-19 11:58:51
tags:
categories:
---



## pragmas

关键字 `pragma` 是版本标识指令，用来启用某些编译器检查， 版本 标识pragma 指令通常只对本文件有效，所以我们需要把这个版本 标识pragma 添加到项目中所有的源文件。 如果使用了 [import 导入](https://learnblockchain.cn/docs/solidity/layout-of-source-files.html#import) 其他的文件, 标识pragma 并不会从被导入的文件，加入到导入的文件中。

版本号的形式通常是 `0.x.0` 或者 `x.0.0`。如下:

```
pragma solidity ^0.5.2;
```

这样，源文件将既不允许低于 0.5.2 版本的编译器编译， 也不允许高于（包含） `0.6.0` 版本的编译器编译（第二个条件因使用 `^` 被添加）。 这种做法的考虑是，编译器在 0.6.0 版本之前不会有重大变更，所以可确保源代码始终按预期被编译。 上面例子中不固定编译器的具体版本号，因此编译器的补丁版也可以使用。

使用版本标准不会改变编译器的版本，它不会启用或关闭任何编译器的功能。 他仅仅是告知编译器去检查版本是否匹配， 如果不匹配，编译器就会提示一个错误。

可以使用更复杂的规则来指定编译器的版本，表达式遵循 [npm](https://docs.npmjs.com/misc/semver) 版本语义。

> Pragma 是 pragmatic information 的简称，微软 Visual C++ [文档](https://msdn.microsoft.com/zh-cn/library/d9x1s805.aspx) 中译为标识。 Solidity 中沿用 C ，C++ 等中的编译指令概念，用于告知编译器 **如何** 编译。



## import 

Solidity 支持的导入语句来模块化代码，其语法跟 JavaScript（从 ES6 起）非常类似。如下创建了新的 `symbolName` 全局符号，他的成员都来自于导入的 `"filename"` 文件中的全局符号：

```
import * as symbolName from "filename";
```

然后所有全局符号都以``symbolName.symbol``格式提供。上面还能简写成如下：

```
import "filename" as symbolName;
```

如果存在命名冲突，则可以在导入时重命名符号。例如，下面的代码创建了新的全局符号 `alias` 和 `symbol2` ，引用的 `symbol1` 和 `symbol2` 来自 “filename” 。

```
import {symbol1 as alias, symbol2} from "filename";
```





## 参考资料

> - []()
> - []()
