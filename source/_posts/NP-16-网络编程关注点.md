---
title: NP-16-网络编程关注点
date: 2018-09-11 15:31:00
tags: NetworkProgramming
---

## TCP拆包粘包问题
#### 场景描述
TCP编程底层都有粘包和拆包机制，因为我们在C/S这种传输模型下，以TCP协议传输的时候，在网络中的byte其实就像是河水，TCP就像一个搬运工,将这流水从一端转送到另一端，这时又分两种情况：

1. 如果客户端的每次制造的水比较多，也就是我们常说的客户端给的包比较大，TCP这个搬运工就会分多次去搬运。

2. 如果客户端每次制造的水比较少的话，TCP可能会等客户端多次生产之后，把所有的水一起再运输到另一端


上述第一种情况，就是需要我们进行粘包，在另一端接收的时候，需要把多次获取的结果粘在一起，变成我们可以理解的信息，第二种情况，我们在另一端接收的时候，就必须进行拆包处理，因为每次接收的信息，可能是另一个远程端多次发送的包，被TCP粘在一起的


#### 粘包
当客户端与服务端发送的数据包大于单次能发送的最大数据包时，会将数据包拆成多个部分，分别发送

当收到所有数据包后，将各个数据包粘成一个数据包给用户使用。

#### 拆包
当发送的数据包较小时，会对多个数据包进行合并成一个，进行一次发送，

当收到该包时，会对数据包拆成发送前的多个数据包，给用户使用。

#### 解决方案

根据业界主流协议，有三种方案：

1. 消息定长，例如每个报文的大小固定为200个字节 ，如果不够，空格补位
2. 在包尾部增加特殊字符进行分割，例如加回车
3. 将消息分为消息头和消息体，在消息头中包含表示消息总长度的字段，然后进行业务逻辑的处理

netty提供前两种：
* 分隔符类DellmiterBasedFrameDecoder(自定义分隔符)
* FixedLengthFrameDecoder(定长)

## 编解码技术
说白了就是java序列化技术，序列化目的就是两个，第一进行网络传输，第二对象持久化

虽然我们可以使用java进行对象序列化，netty去传输，但是java序列号的硬伤太多，比如java序列化没法跨语言、序列化后码流太大、序列化性能太低等等
#### 主流的编解码框架：
* JBoss的Marshalling包
* Google的Protobuf
* 基于Protobuf的Kyro
* MessagePack框架