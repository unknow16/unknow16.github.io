---
title: 02-类加载机制
date: 2018-01-12 17:14:14
tags: JVM
---

参考：https://blog.stormma.me/2017/11/14/%E4%B8%80%E7%82%B9%E4%B8%80%E6%BB%B4%E6%8E%A2%E7%A9%B6JVM%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/#more

### 什么是类加载

指将*.class字节码文件通过类加载器加载到JVM内存模型的方法区和堆中。

在堆内存中生成一个Class对象，供程序访问。

JVM规范规定类加载器预料到要使用某个类时，可以提前加载该类字节码，如果该类字节码存在错误，也只能等到使用它时，才能发现，类加载器不会报错。

### 类加载顺序
![image](https://note.youdao.com/yws/api/personal/file/6C85DC063AB74A3DB0E1110168BA692D?method=download&shareKey=6d71d5931cebfe5917424161fa82bbe5)

其中加载、验证、准备、初始化一定会发生，但解析不一定，这是为了支持Java语言的运行时绑定。且一定是顺序开始的，但不一定顺序结束，因为一个阶段的执行可能会调用或激活另一个阶段。

#### 加载
查找并加载一个类的字节码进入JVM内存

1. 根据类的全限定名查找类的字节码文件二进制流
2. 将静态的字节码二进制流转换存入方法区内存中的动态数据结构
3. 创建一个Class对象实例，作为访问方法区类数据结构的入口。

#### 链接
* 验证：验证类字节码文件是否符合规范，且不危害JVM运行。
* 准备：为类的静态变量分配内存，并初始化为默认值。0/null，而不是程序中指定的初始化值。
* 解析：把常量池中的符号引用替换成直接引用。直接引用就是直接指向目标的指针。

#### 初始化
为类的静态变量赋予指定的值。包括静态代码块赋值和静态变量直接赋值。
```
public static int value; //默认值为0，可不初始化值。
public static final int value = 1; //必须为其初始化值，否则编译不通过。
public final int value; //系统不会赋予默认值，必须显式的赋值。

static final常量在准备阶段时，就被初始化为代码中指定的值。
```

### 类加载器
![image](https://note.youdao.com/yws/api/personal/file/2F6F4734FCA74EE28C2FA9DD12892246?method=download&shareKey=3c4eed16235abdc5de0b479f7685b67f)

类加载器负责加载所有的类进入JVM，每个加载到JVM中的类，都有一个java.lang.Class的实例，并且保证该类只会被加载一次，已经加载过的类不会再加载。

---

Java代码中，通过一个类的全限定名（包名和类名）标识一个类

JVM中一个类的唯一标识是：一个类的全限定名 + 加载该类的类加载器

如：同一个类通过不同的ClassLoader加载到JVM中，是不同的类，则会生成不同的java.lang.Class实例。

* 根类加载器

负责加载Java核心类

* 扩展类加载

负责加载jre中ext下的扩展类jar包

* 系统类/应用类加载器

负责加载classpath下用户自己编写的类。

如果应用程序没有自定义过自己的类加载器，一般默认就是这个类加载器。

* 除了根类加载器，其它的都是ClassLoader抽象类的子类。
---

### 类加载机制
* 全盘负责

一个类被某个类加载器加载后，该类所依赖的其他类也由该类加载器加载

* 父类委托

加载一个类时，先委托父类加载，父类找不到时，才在自己classpath下加载

* 缓存机制

加载一个类前，先查询是否已加载过该类，加载过直接使用，否则再加载。

### Tomcat类加载机制
* 自定义了自己的类加载器。
* 采用代理，每个应用一个类加载器，先在应用中寻找加载类，找不到委托给父类，跟JDK默认的机制相反。
* 保证了JDK核心类的安全。