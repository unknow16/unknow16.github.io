---
title: 02-操作镜像
toc: true
date: 2019-04-27 14:45:01
tags:
categories:
---


## 获取镜像
Docker Hub上有很多优秀的镜像供大家下载。

拉取镜像的命令格式如下：

```
docker pull [选项] [docker-registry-ip:port/] 仓库名 [:标签]

// 仓库名格式为 <用户名>/<软件名>, 对于docker hub 如果不给出用户名，则默认为library,也就是官方镜像。

// 以上[]的都可以省略
// 1.docker-registry-ip:port 省略默认为 docker hub ip
// 2.[:标签]省略默认为 latest,即最新版本
```

如下从docker hub拉取ubuntu 16.04的镜像： 

```
docker pull ubuntu:16.04

// 即从docker hub中下载 library 用户的 ubuntu 软件的 16.04版本的镜像到本地。
```

## 运行镜像
有了一个ubuntu镜像后，我们可以以这个镜像为基础启动一个容器。

```
docker run -it --rm ubuntu:16.04 bash

// docker run 为运行容器的命令
// -it其实是两个参数，-i表示启动交互操作，-t表示采用终端
// --rm 让容器退出后即被删除。默认退出的容器不会被删除，除非主动用docker rm删除。
// ubuntu:16.04 指采用ubuntu:16.04为镜像启动容器
// bash 启动一个shell来执行命令
```

## 列出本地镜像
- 列出本地已经下载下来的镜像
```
docker image ls

// 显示列表中分别为仓库名、标签、镜像ID、创建时间、所占用空间。
// 镜像ID是镜像的唯一标识
// 一个镜像可以有多个标签，如ubuntu16.04和ubuntu:latest拥有相同的ID,因为它们对应的是一个镜像。 

```

* 根据仓库名列出镜像

```
docker image ls ubuntu
```

* 列出特定镜像，即指定仓库名和标签

```
docker image ls ubuntu:16.04
```

* 过滤器

```
// 显示mongo:3.2之后建立的镜像
// 查看之前则将since改为before即可
docker image ls -f since=mongo:3.2
```

- 如果在构建镜像时，定义了label，可以通过label来过滤
```
docker image ls -f label=com.example.version=0.1
```

- 列出中间层镜像
```
// 显示所有镜像，包括中间层镜像，
// 不加-a参数，只会显示顶级镜像
docker image ls -a
```

- 以特定格式显示
```
docker image ls --format "{{.ID}}: {{.Repository}}" 

// 显示结果如下：
c23fdac595a3: nginx
f29714af4a76: nginx
c9d990395902: ubuntu
e38bc07ac18e: hello-world
b175e7467d66: nginx

docker image ls --format "table {{.ID}}\t{{.Repository}}\t{{.Tag}}"

// 显示结果如下：
IMAGE ID            REPOSITORY          TAG
c23fdac595a3        nginx               v3
f29714af4a76        nginx               v2
c9d990395902        ubuntu              16.04
e38bc07ac18e        hello-world         latest
b175e7467d66        nginx               latest
```

## 镜像体积
Docker镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。

由于Docker使用Union FS，相同的层只需要保存一份即可。

Docker hub上显示的镜像体积大小是压缩过的，下载到本地后是解压缩过的，所以本地显示大小会比Docker hub上显示的大。

```
// 查看本地镜像、容器、数据卷所占用的空间
docker system df
```

## 虚悬镜像(dangling image)
镜像列表中 仓库名和标签都为<nonce>的镜像。

原来存在有某个版本镜像，如mongo:3.2, 随着官方镜像的维护，修复了该版本的bug后，重新用docker pull mongo:3.2时，该版本新镜像采用了mongo:3.2名字，从而导致该版本老镜像无仓库名和标签名，成为虚悬镜像。

可以使用下列命令专门显示这类镜像：

```
// 其中，-f为过滤器
docker image ls -f dangling=true
```
一般来说，虚悬镜像失去了存在的价值，可以随时删除的，可以采用下列命令删除：

```
docker image prune
```
## 删除镜像
- 删除单个镜像
```
docker image rm [选项] <镜像1> [<镜像2> ...]

// 其中镜像可以是 镜像短ID、镜像长ID、镜像名、镜像摘要hash
```

docker image ls 默认列出的就是短ID,一般取3个字符以上，只要能区分镜像就可以了，写脚本时采用长ID


```
// 显示镜像摘要hash
docker image ls --digests
```

- 批量删除镜像

```
// 删除所有仓库名为redis的镜像
docker image rm $(docker image ls -q redis)

// 删除所有在mongo:3.2之前的镜像
docker image rm $(docker image ls -q -f before=mongo:3.2)
```

- Untagged 和 Deleted

一个镜像的唯一标识为镜像ID,但一个镜像可对应多个标签。

删除镜像时一般分两步：
1. Untaged: 删除标签版本
2. Deleted: 删除镜像文件，该步不一定发生

一般删除镜像时主要是删除某个标签版本的镜像，所以首先会进行Untaged,即解绑标签，但因为一个镜像可以有多个标签，此时如果还有其它标签指向此镜像，则该不会执行Deleted.

当某个镜像所有的标签都被取消了，该镜像就失去了存在的意义，就会触发删除行为。因为镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。

* 另外镜像的多层结构让镜像复用变的非常容易，因此很可能其他镜像正以来于当前镜像的某一层，这时依旧不会触发删除该层行为。直到没有任何层依赖当前层时，才会真正删除当前层。

* 除了镜像依赖外，还需注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在，即使容器没有运行，那也不会删除这个镜像。