<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stay Hungry | Stay Foolish | fymingf</title>
  
  <subtitle>自我管理，知识管理，时间管理，阅读，写作，思维导图，Wiz，TimeMeter</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-04-22T03:08:17.725Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>mingfy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node.js开发环境配置</title>
    <link href="http://yoursite.com/wiki/%E5%89%8D%E7%AB%AF/Node%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/wiki/前端/Node开发环境配置/</id>
    <published>2022-04-22T02:36:36.000Z</published>
    <updated>2022-04-22T03:08:17.725Z</updated>
    
    <content type="html"><![CDATA[<p>Node有两个版本线: LTS 是长期维护的稳定版本 Current 是新特性版本</p><h2 id="win配置"><a href="#win配置" class="headerlink" title="win配置"></a>win配置</h2><ol><li><p>解压zip包到想放置目录</p></li><li><p>在解压后的目录下建立 node_global和node_cache，node_global: npm全局安装路径；node_cache: npm全局缓存路径</p></li><li><p>配置环境变量：新建变量 NODE_PATH , 指向 E:\xxx\node-v12.22.12-win-x64</p></li><li><p>追加PATH：编辑Path环境变量，在后面追加 %NODE_PATH%   和    %NODE_PATH%\node_global</p></li><li><p>配置npm全局安装路径: 打开cmd 执行 ，分开执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set cache &quot;E:\xxx\node-v12.22.12-win-x64&quot;</span><br><span class="line">npm config set prefix  &quot;E:\xxx\node-v12.22.12-win-x64&quot;</span><br></pre></td></tr></table></figure><p>如果执行命令卡死，可以删除C:\Users\用户名.npmrc 后重新执行。（用户名：为当前电脑的用户名）</p></li><li><p>npm设置淘宝仓库, 官网地址：<a href="https://npmmirror.com/">https://npmmirror.com/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">设置镜像</span><br><span class="line">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</span><br><span class="line"></span><br><span class="line">查看镜像设置</span><br><span class="line">npm get registry </span><br><span class="line"></span><br><span class="line">如果要恢复成原来的设置，执行如下：</span><br><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npmjs.org&#x2F;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Node有两个版本线: LTS 是长期维护的稳定版本 Current 是新特性版本&lt;/p&gt;
&lt;h2 id=&quot;win配置&quot;&gt;&lt;a href=&quot;#win配置&quot; class=&quot;headerlink&quot; title=&quot;win配置&quot;&gt;&lt;/a&gt;win配置&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>药品集中采购简介</title>
    <link href="http://yoursite.com/wiki/%E6%8A%95%E7%A0%94/%E8%8D%AF%E5%93%81%E9%9B%86%E4%B8%AD%E9%87%87%E8%B4%AD%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/wiki/投研/药品集中采购简介/</id>
    <published>2022-04-20T09:03:45.000Z</published>
    <updated>2022-04-22T01:53:37.626Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说就是：以前各个医疗单位独自采购，采购量小，不具备和厂家的议价能力，同时还有经销商层层加价以及医院收取回扣的现象，因此国家政府部门出面，统一收集各个公立医疗单位医药用品的需求量，然后对各个医院的用量进行整合，最后向企业统一采购药品。</p><p><img src="/wiki/%E6%8A%95%E7%A0%94/%E8%8D%AF%E5%93%81%E9%9B%86%E4%B8%AD%E9%87%87%E8%B4%AD%E7%AE%80%E4%BB%8B/ypjc-01.jpg"></p><p>2018年11月，国家组织的药品集中采购和使用试点工作启动，以北京、上海、天津、重庆4个直辖市，沈阳、大连、厦门、广州、深圳、成都、西安等7个城市的公立医疗机构作为集中采购主体，集合他们的需求量，以带量采购的方式向医药生产厂家采购医药用品，以达到降低采购成本，降低患者医药负担的目的。按目前的态势看，集采改革呈现全面推进之势。药品集采不仅将从试点推广到全国，而且政府集中采购的医药目录也将会越来越多，这将显著的改善居民看病成本，同时这也不可避免会对医药企业乃至整个行业发展带来深刻影响。这就是医疗集采的大致背景和目前集采的现状</p><p><img src="/wiki/%E6%8A%95%E7%A0%94/%E8%8D%AF%E5%93%81%E9%9B%86%E4%B8%AD%E9%87%87%E8%B4%AD%E7%AE%80%E4%BB%8B/ypjc-02.jpg"></p><p>我国的药品集中采购政策是从2000年开始发展起来的，1999年通过的《中华人民共和国招投标法》，正式从法律层面上规定了我国药品集中投标的方式来采购。从2000年起，各个省份到底如何开展和执行中央政策的。我没有做具体的研究，但各个地区在执行上一定遇到很多问题，例如：政策规定药品要集中招投标，那么所有的药品都要招投标吗？招投标是多少年进行一次呢？在这之后的十几年中，因为没有一个政策具体规定集中采购要具体怎么操作，因此各个省市根据当地的特点，发展出了有当地特色的执行政策。</p><p>其中，不是所有的药品都是通过招投标的形式采购的。还有另一个最能体现这个特点的是各种不同的集中采购平台的出现。几乎每个省和直辖市都会有自己的采购平台，比如：上海的阳光医药采购网，四川药械采购监管网等等，同时，还存在GPO（Group purchasing organizations，集团采购组织）平台，上海药品集团采购服务网，深圳的全药网，重庆药交所，三明市的三明联盟，等等。这里我使用平台来表述，很多文章用采购模式来表述，我认为平台在表述上比较清晰，因为可以很清晰的和集中招标，谈判采购，等等采购模式区别开来，避免混淆。</p><ul><li>上海的阳光医药采购网: <a href="http://www.yyzbsw.sh.cn/">http://www.yyzbsw.sh.cn/</a></li><li>四川药械采购监管网: <a href="https://www.scyxzbcg.cn/">https://www.scyxzbcg.cn/</a></li><li>上海药品集团采购服务网: </li><li>深圳的全药网: <a href="https://www.quanyaowang.com/">https://www.quanyaowang.com/</a></li><li>重庆药交所: <a href="http://cq.yjsds.com/">http://cq.yjsds.com/</a></li><li>三明市的三明联盟: <a href="https://www.udplat.com/">https://www.udplat.com/</a></li></ul><p>一直到2015年,国务院办公厅发布了“关于完善公立医院药品集中采购工作的指导意见”从政策层面上总结了各个地区的经验，并指出了药品集中采购的未来发展路径。这也是当前全国执行的药品集中采购的基本政策。其中有几个关键的点：</p><ol><li><p>政府坚持以省为单位在网上进行集中采购，并且鼓励地方结合实际探索创新，目的是提高医院在药品采购中的参与度。因此，才有目前各个不同的，都说自己有多创新的采购平台的出现。</p></li><li><p>针对不同特点的药品，规定了5种采购模式：<br> 1）集中招标采购，针对用量大的药品；<br> 2）谈判采购，针对专利药，独家药；<br> 3）医院直接采购，针对基础，常用的保障性药品；<br> 4）国家定点生产，议价采购，针对用量小，供应少的必须药品；<br> 5）国家管控采购，针对管制类药品，免疫规划和防治床染病等药品。</p></li><li><p>规定在2015年全国开展新一轮的药品采购。自此，每个省份开始了新一轮的药品集中采购。甚至有的省份从2014年就已经开始了。这个政策意味着，每个省份开始重新选择药品的供应商，涉及到上千种药品。这一轮药品集中采购流程大体上有这么几步：</p><ol><li>第一步：每个省份根据自己对药品的使用情况，把所有药品分成5类，每一类对应一种采购模式。哪些药品是招标采购，哪些是谈判，哪些直接采购，可以在药品集采网站上直接看到。</li><li>第二步：各个药厂根据公布的药品分类和对应的采购模式，参与对应的流程。</li><li>第三步：省政府部门筛选药品供应商，最终确定省级别的供应商名录。</li></ol></li></ol><p>在第一步的5种采购模式中，每种模式有不同的操作流程。其中，集中招标采购最复杂。按照政策要求，至少80%的药品要用这种采购模式，意味这上千种药品要招标，竞标，开标。可以想象，当年每个省份的食药监局的工作人员有多忙。但是对于药厂来说，这就是市场的计划呀，也可以想象他们有多么的紧张和兴奋。一旦中标，就开疆拓土，一旦失败，那就失去市场。非常的残酷和现实。</p><p>耐人寻味的是，在2015年政策中，对于集中招标采购，强调了要落实带量采购。实际上，几乎没有省份真正的执行的带量采购，只有上海在完成了新一轮的采购之后，在2016，2017和2018进行了三次实验性的带量采购，涉及的药品一共才20个左右。也许因为上海有过几次带量采购的经验，所以主导了2018年底开始的“4+7”带量采购。回到2015年的集中采购上来，到了2016年，基本上每个省份的集中采购已经结束，该选择的供应商已经确定。医院和供应商之间也就开始正常的采购和供应（其中当然存在因为政策的原因，导致的各种灰色的市场行为，这里我们先不谈）。有意思的是，2015年的政策并没有规定这次采购结果的时效，简单说就是没有具体说明，这次选了供应商以后多久在选择一次。这也意味着，在一个省内，中标的药企可以连续几年给在这个地区的医院供应药品，失败的药企只能在零售药店卖药，没有资格供应医院。因此，集中采购结束，药企在这个市场的竞争大格局也就确定了。</p><p>最后，时间来到2018年11月，国家发布了“4+7城市药品集中采购文件”，选择了11个城市，对31种药品进行了跨城市的试点带量采购。注意的是，这个政策只是针对5种集中采购模式中集中招标采购做的规定，并不针对其他的4种采购模式。这个政策对药企来说有爱有恨，爱的是供应商选择重新开始。恨的是，本地药企和国际药企同台晋级，而且成王败寇，每个企业都压低价格。到目前为止，对政策的效果褒贬不一，但带量采购会成为未来的方向。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.zhihu.com/column/c_1173267719310254080">https://www.zhihu.com/column/c_1173267719310254080</a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;简单来说就是：以前各个医疗单位独自采购，采购量小，不具备和厂家的议价能力，同时还有经销商层层加价以及医院收取回扣的现象，因此国家政府部门出面，统一收集各个公立医疗单位医药用品的需求量，然后对各个医院的用量进行整合，最后向企业统一采购药品。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;
      
    
    </summary>
    
      <category term="投研" scheme="http://yoursite.com/categories/%E6%8A%95%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>Tomcat-基础知识</title>
    <link href="http://yoursite.com/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/wiki/中间件/Tomcat-基础知识/</id>
    <published>2021-04-19T06:28:19.000Z</published>
    <updated>2021-04-21T10:15:28.506Z</updated>
    
    <content type="html"><![CDATA[<p>官网：<a href="http://tomcat.apache.org/">http://tomcat.apache.org/</a></p><h2 id="常见web服务器软件"><a href="#常见web服务器软件" class="headerlink" title="常见web服务器软件"></a>常见web服务器软件</h2><ul><li>webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</li><li>webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 </li><li>JBoss：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。 </li><li>Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范 servlet/jsp。开源的，免费的。</li></ul><h2 id="Tomcat-历史"><a href="#Tomcat-历史" class="headerlink" title="Tomcat 历史"></a>Tomcat 历史</h2><ol><li>Tomcat 最初由Sun公司的软件架构师 James Duncan Davidson 开发，名称为 “JavaWebServer”。 </li><li>1999年，在 Davidson 的帮助下，该项目于1999年他和 apache 软件基金会旗下的 JServ 项目合并，并发布第一个版本（3.x）, 即是现在的Tomcat，该版本实现了 Servlet2.2 和 JSP 1.1 规范 。</li><li>2001年，Tomcat 发布了4.0版本， 作为里程碑式的版本，Tomcat 完全重新设计了 其架构，并实现了 Servlet 2.3 和 JSP1.2规范。 </li><li>目前 Tomcat 已经更新到 9.0.x版本 ， 但是目前企业中的Tomcat服务器， 主流版本还是 7.x 和 8.x ， 所以以下基于 8.5 版本进行讲解。</li></ol><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>我们知道如果要设计一个系统，首先是要了解需求，我们已经了解了Tomcat要实现两个 核心功能：</p><ol><li>处理Socket连接，负责网络字节流与Request和Response对象的转化。 </li><li>加载和管理Servlet，以及具体处理Request请求。 </li></ol><p>因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这 两件事情。连接器负责对外交流，容器负责内部处理。</p><h2 id="连接器-Coyote"><a href="#连接器-Coyote" class="headerlink" title="连接器 - Coyote"></a>连接器 - Coyote</h2><h3 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h3><p>Coyote 是Tomcat的连接器框架的名称 , 是Tomcat服务器提供的供客户端访问的外部接口。客户端通过Coyote与服务器建立连接、发送请求并接受响应。<br>Coyote 封装了底层的网络通信（Socket 请求及响应处理），为Catalina 容器提供了统一 的接口，使Catalina 容器与具体的请求协议及IO操作方式完全解耦。Coyote 将Socket 输入转换封装为 Request 对象，交由Catalina 容器进行处理，处理请求完成后, Catalina 通 过Coyote 提供的Response 对象将结果写入输出流。<br>Coyote 作为独立的模块，只负责具体协议和IO的相关操作， 与Servlet 规范实现没有直 接关系，因此即便是 Request 和 Response 对象也并未实现Servlet规范对应的接口， 而 是在Catalina 中将他们进一步封装为ServletRequest 和 ServletResponse 。</p><p><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/01-coyote-catalina.png"></p><h3 id="IO模型与协议"><a href="#IO模型与协议" class="headerlink" title="IO模型与协议"></a>IO模型与协议</h3><p>在Coyote中 ， Tomcat支持的多种I/O模型和应用层协议，Tomcat 支持的IO模型（自8.5/9.0 版本起，Tomcat 移除了 对 BIO 的支持）：</p><ul><li>NIO 非阻塞I/O，采用Java NIO类库实现。 </li><li>NIO2 异步I/O，采用JDK 7最新的NIO2类库实现。 </li><li>APR 采用Apache可移植运行库实现，是C/C++编写的本地库。如果选择该方案，需要单独安装APR库。</li></ul><p>应用层协议如下：</p><ul><li>HTTP/1.1：这是大部分Web应用采用的访问协议。 </li><li>AJP：用于和Web服务器集成（如Apache），以实现对静态资源的优化以及集群部署，当前支持AJP/1.3。 </li><li>HTTP/2：HTTP 2.0大幅度的提升了Web性能。下一代HTTP协议 ， 自8.5以及9.0 版本之后支持。</li></ul><p>在 8.0 之前 ， Tomcat 默认采用的I/O方式为 BIO ， 之后改为 NIO。 无论 NIO、NIO2 还是 APR， 在性能方面均优于以往的BIO。 如果采用APR， 甚至可以达到 Apache HTTP Server 的影响性能。</p><p>Tomcat中的Service概念：Tomcat为了实现支持多种I/O模型和应用层协议，一个容器可能对接多个连接器，就好比 一个房间有多个门。但是单独的连接器或者容器都不能对外提供服务，需要把它们组装 起来才能工作，组装后这个整体叫作Service组件。这里请你注意，Service本身没有做什 么重要的事情，只是在连接器和容器外面多包了一层，把它们组装在一起。Tomcat内可 能有多个Service，这样的设计也是出于灵活性的考虑。通过在Tomcat中配置多个 Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。</p><h3 id="连接器组件"><a href="#连接器组件" class="headerlink" title="连接器组件"></a>连接器组件</h3><p><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/02-connector.png"><br>连接器中的各个组件的作用如下： </p><ul><li>EndPoint ： Coyote 通信端点，即通信监听的接口，是具体Socket接收和发送处理器，是对传输层的抽象，因此EndPoint用来实现TCP/IP协议的。Tomcat 并没有EndPoint 接口，而是提供了一个抽象类AbstractEndpoint ， 里面定 义了两个内部类：Acceptor和SocketProcessor。Acceptor用于监听Socket连接请求。 SocketProcessor用于处理接收到的Socket请求，它实现Runnable接口，在Run方法里 调用协议处理组件Processor进行处理。为了提高处理能力，SocketProcessor被提交到 线程池来执行。而这个线程池叫作执行器（Executor)，我在后面的专栏会详细介绍 Tomcat如何扩展原生的Java线程池。 </li><li>Processor ： Coyote 协议处理接口 ，如果说EndPoint是用来实现TCP/IP协议的，那么 Processor用来实现HTTP协议，Processor接收来自EndPoint的Socket，读取字节流解 析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理， Processor是对应用层协议的抽象。 </li><li>ProtocolHandler： Coyote 协议接口， 通过Endpoint 和 Processor ， 实现针对具体协议的处理能力。Tomcat 按照协议和I/O 提供了6个实现类 ： AjpNioProtocol， AjpNio2Protocol ，AjpAprProtocol， Http11NioProtocol ，Http11Nio2Protocol ， Http11AprProtocol。我们在配置tomcat/conf/server.xml 时 ， 至少要指定具体的 ProtocolHandler , 当然也可以指定协议名称， 如 ： HTTP/1.1 ，如果安装了APR，那么 将使用Http11AprProtocol ， 否则使用 Http11NioProtocol 。</li><li>Adapter:  由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了自己的Request类 来“存放”这些请求信息。ProtocolHandler接口负责解析请求并生成Tomcat Request类。 但是这个Request对象不是标准的ServletRequest，也就意味着，不能用Tomcat Request作为参数来调用容器。Tomcat设计者的解决方案是引入CoyoteAdapter，这是 适配器模式的经典运用，连接器调用CoyoteAdapter的Sevice方法，传入的是Tomcat Request对象，CoyoteAdapter负责将Tomcat Request转成ServletRequest，再调用容 器的Service方法。</li></ul><h2 id="容器-Catalina"><a href="#容器-Catalina" class="headerlink" title="容器 - Catalina"></a>容器 - Catalina</h2><p>Tomcat是一个由一系列可配置的组件构成的Web容器，而Catalina是Tomcat的servlet容器。Catalina 是Servlet 容器实现，包含了之前讲到的所有的容器组件，以及后续章节涉及到的安全、会话、集群、管理等Servlet 容器架构的各个方面。它通过松耦合的方式集成 Coyote，以完成按照请求协议进行数据读写。同时，它还包括我们的启动入口、Shell程序等</p><h3 id="Catalina-地位"><a href="#Catalina-地位" class="headerlink" title="Catalina 地位"></a>Catalina 地位</h3><p>Tomcat 的模块分层结构图， 如下：<br><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/03.png"><br>Tomcat 本质上就是一款 Servlet 容器， 因此Catalina 才是 Tomcat 的核心 ， 其他模块 都是为Catalina 提供支撑的。 比如 ： 通过Coyote 模块提供链接通信，Jasper 模块提供 JSP引擎，Naming 提供JNDI 服务，Juli 提供日志服务。</p><h3 id="Catalina-结构"><a href="#Catalina-结构" class="headerlink" title="Catalina 结构"></a>Catalina 结构</h3><p>Catalina 的主要组件结构如下：<br><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/04.png"></p><p>如上图所示，Catalina负责管理Server，而Server表示着整个服务器。Server下面有多个 服务Service，每个服务都包含着多个连接器组件Connector（Coyote 实现）和一个容器 组件Container。在Tomcat 启动的时候， 会初始化一个Catalina的实例。<br>Catalina 各个组件的职责：</p><ul><li>Catalina： 负责解析Tomcat的配置文件 , 以此来创建服务器Server组件，并根据 命令来对其进行管理 </li><li>Server： 服务器表示整个Catalina Servlet容器以及其它组件，负责组装并启动 Servlet引擎,Tomcat连接器。Server通过实现Lifecycle接口，提供了 一种优雅的启动和关闭整个系统的方式 </li><li>Service： 服务是Server内部的组件，一个Server包含多个Service。它将若干个 Connector组件绑定到一个Container（Engine）上 </li><li>Connector： 连接器，处理与客户端的通信，它负责接收客户请求，然后转给相关 的容器处理，最后向客户返回响应结果 </li><li>Container： 容器，负责处理用户的servlet请求，并返回对象给web用户的模块</li></ul><h3 id="Container-结构"><a href="#Container-结构" class="headerlink" title="Container 结构"></a>Container 结构</h3><p>Tomcat设计了4种容器，分别是Engine、Host、Context和Wrapper。这4种容器不是平 行关系，而是父子关系。， Tomcat通过一种分层的架构，使得Servlet容器具有很好的灵活性。<br><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/05.png"></p><p>各个组件的含义 ：</p><ul><li>Engine： 表示整个Catalina的Servlet引擎，用来管理多个虚拟站点，一个Service 最多只能有一个Engine，但是一个引擎可包含多个Host </li><li>Host： 代表一个虚拟主机，或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可包含多个Context </li><li>Context： 表示一个Web应用程序， 一个Web应用可包含多个Wrapper </li><li>Wrapper： 表示一个Servlet，Wrapper 作为容器中的最底层，不能包含子容器</li></ul><p>我们也可以再通过Tomcat的server.xml配置文件来加深对Tomcat容器的理解。Tomcat 采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件 按照一定的格式要求配置在这个顶层容器中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Connector</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">Context</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么，Tomcat是怎么管理这些容器的呢？你会发现这些容器具有父子关系，形成一个树 形结构，你可能马上就想到了设计模式中的组合模式。没错，Tomcat就是用组合模式来 管理这些容器的。具体实现方法是，所有容器组件都实现了Container接口，因此组合模 式可以使得用户对单容器对象和组合容器对象的使用具有一致性。这里单容器对象指的 是最底层的Wrapper，组合容器对象指的是上面的Context、Host或者Engine。</p><p><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/06.png"></p><p>Container 接口中提供了addChild()、getParent()等方法，Container接口扩展了LifeCycle接口，LifeCycle接口用来统一管理各组件的生命周期，后面我也用专门的篇幅去详细介绍。</p><h2 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h2><p><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/07.png"></p><ol><li>启动tomcat ， 需要调用 bin/startup.bat (在linux 目录下 , 需要调用 bin/startup.sh) ， 在startup.bat 脚本中, 调用了catalina.bat。 </li><li>在catalina.bat 脚本文件中，调用了org.apache.catalina.startup.Bootstrap 中的main方法。 </li><li>在BootStrap 的main 方法中调用了 init 方法 ， 来创建Catalina 及 初始化类加载器。 </li><li>在BootStrap 的main 方法中调用了 load 方法 ， 在其中又调用了Catalina的load方法。</li><li>在Catalina 的load 方法中 , 需要进行一些初始化的工作, 并需要构造Digester 对象, 用 于解析 XML。 </li><li>然后在调用后续组件的初始化操作，加载Tomcat的配置文件，初始化容器组件 ，监听对应的端口号， 准备接受客户端请求</li></ol><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><p>由于所有的组件均存在初始化、启动、停止等生命周期方法，拥有生命周期管理的特性， 所以Tomcat在设计的时候， 基于生命周期管理抽象成了一个接口 Lifecycle ，而组 件 Server、Service、Container、Executor、Connector 组件 ， 都实现了一个生命周期 的接口，从而具有了以下生命周期中的核心方法：</p><ul><li>init（）：初始化组件 </li><li>start（）：启动组件 </li><li>stop（）：停止组件 </li><li>destroy（）：销毁组件</li></ul><p>从启动流程图中以及源码中，我们可以看出Tomcat的启动过程非常标准化， 统一按照生 命周期管理接口Lifecycle的定义进行启动。首先调用init() 方法进行组件的逐级初始化操 作，然后再调用start()方法进行启动。 每一级的组件除了完成自身的处理外，还要负责调用子组件响应的生命周期管理方法， 组件与组件之间是松耦合的，因为我们可以很容易的通过配置文件进行修改和替换。</p><h2 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h2><p>设计了这么多层次的容器，Tomcat是怎么确定每一个请求应该由哪个Wrapper容器里的 Servlet来处理的呢？答案是，Tomcat是用Mapper组件来完成这个任务的。 Mapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是： Mapper组件里保存了Web应用的配置信息，其实就是容器组件与访问路径的映射关系， 比如Host容器里配置的域名、Context容器里的Web应用路径，以及Wrapper容器里 Servlet映射的路径，你可以想象这些配置信息就是一个多层次的Map。</p><p>当一个请求到来时，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的 Map里去查找，就能定位到一个Servlet。请你注意，一个请求URL最后只会定位到一个 Wrapper容器，也就是一个Servlet。</p><p>上面只是描述了根据请求的URL如何查找到需要执行的Servlet ， 那么下面我们 再来解析一下 ， 从Tomcat的设计架构层面来分析Tomcat的请求处理。</p><p><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/08.png"></p><ol><li>Connector组件Endpoint中的Acceptor监听客户端套接字连接并接收Socket。 </li><li>将连接交给线程池Executor处理，开始执行请求响应任务。 </li><li>Processor组件读取消息报文，解析请求行、请求体、请求头，封装成Request对象。 </li><li>Mapper组件根据请求行的URL值和请求头的Host值匹配由哪个Host容器、Context容器、Wrapper容器处理请求。 </li><li>CoyoteAdaptor组件负责将Connector组件和Engine容器关联起来，把生成的 Request对象和响应对象Response传递到Engine容器中，调用 Pipeline。 </li><li>Engine容器的管道开始处理，管道中包含若干个Valve、每个Valve负责部分处理逻辑。执行完Valve后会执行基础的 Valve–StandardEngineValve，负责调用Host容器的 Pipeline。 </li><li>Host容器的管道开始处理，流程类似，最后执行 Context容器的Pipeline。 </li><li>Context容器的管道开始处理，流程类似，最后执行 Wrapper容器的Pipeline。 </li><li>Wrapper容器的管道开始处理，流程类似，最后执行 Wrapper容器对应的Servlet对象 的 处理方法。</li></ol><p><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/09.png"></p><p>在前面所讲解的Tomcat的整体架构中，我们发现Tomcat中的各个组件各司其职，组件 之间松耦合，确保了整体架构的可伸缩性和可拓展性，那么在组件内部，如何增强组件 的灵活性和拓展性呢？ 在Tomcat中，每个Container组件采用责任链模式来完成具体的 请求处理。 在Tomcat中定义了Pipeline 和 Valve 两个接口，Pipeline 用于构建责任链， 后者代表责 任链上的每个处理器。Pipeline 中维护了一个基础的Valve，它始终位于Pipeline的末端 （最后执行），封装了具体的请求处理和输出响应的过程。当然，我们也可以调用 addValve()方法， 为Pipeline 添加其他的Valve， 后添加的Valve 位于基础的Valve之 前，并按照添加顺序执行。Pipiline通过获得首个Valve来启动整合链条的执行 。</p><h2 id="Jasper"><a href="#Jasper" class="headerlink" title="Jasper"></a>Jasper</h2><h3 id="Jasper-简介"><a href="#Jasper-简介" class="headerlink" title="Jasper 简介"></a>Jasper 简介</h3><p>对于基于JSP 的web应用来说，我们可以直接在JSP页面中编写 Java代码，添加第三方的 标签库，以及使用EL表达式。但是无论经过何种形式的处理，最终输出到客户端的都是 标准的HTML页面（包含js ，css…），并不包含任何的java相关的语法。 也就是说， 我 们可以把jsp看做是一种运行在服务端的脚本。 那么服务器是如何将 JSP页面转换为 HTML页面的呢？ Jasper模块是Tomcat的JSP核心引擎，我们知道JSP本质上是一个Servlet。Tomcat使用 Jasper对JSP语法进行解析，生成Servlet并生成Class字节码，用户在进行访问jsp时，会 访问Servlet，最终将访问的结果直接响应在浏览器端 。另外，在运行的时候，Jasper还 会检测JSP文件是否修改，如果修改，则会重新编译JSP文件。</p><h3 id="运行时编译方式"><a href="#运行时编译方式" class="headerlink" title="运行时编译方式"></a>运行时编译方式</h3><p>Tomcat 并不会在启动Web应用的时候自动编译JSP文件， 而是在客户端第一次请求时， 才编译需要访问的JSP文件。 编译过程如下: </p><p>Tomcat 在默认的web.xml 中配置了一个org.apache.jasper.servlet.JspServlet，用于处 理所有的.jsp 或 .jspx 结尾的请求，该Servlet 实现即是运行时编译的入口。</p><p>JspServlet 处理流程图：<br><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/10.png"></p><p>编译结果:</p><ol><li>如果在 tomcat/conf/web.xml 中配置了参数scratchdir ， 则jsp编译后的结果，就会存储在该目录下 。</li><li>如果没有配置该选项， 则会将编译后的结果，存储在Tomcat安装目录下的 work/Catalina(Engine名称)/localhost(Host名称)/Context名称。 </li></ol><h3 id="预编译方式"><a href="#预编译方式" class="headerlink" title="预编译方式"></a>预编译方式</h3><p>除了运行时编译，我们还可以直接在Web应用启动时， 一次性将Web应用中的所有的JSP 页面一次性编译完成。在这种情况下，Web应用运行过程中，便可以不必再进行实时编 译，而是直接调用JSP页面对应的Servlet 完成请求处理， 从而提升系统性能。 Tomcat 提供了一个Shell程序JspC，用于支持JSP预编译，而且在Tomcat的安装目录下提 供了一个 catalina-tasks.xml 文件声明了Tomcat 支持的Ant任务， 因此，我们很容易使 用 Ant 来执行JSP 预编译 。（要想使用这种方式，必须得确保在此之前已经下载并安装 了Apache Ant）。</p><h3 id="编译后的源码文件"><a href="#编译后的源码文件" class="headerlink" title="编译后的源码文件"></a>编译后的源码文件</h3><p>todo</p><h3 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h3><p>JSP 编译过程如下：<br><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/Tomcat-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/11.png"></p><p>Compiler 编译工作主要包含代码生成 和 编译两部分</p><p>代码生成:</p><ol><li>Compiler 通过一个 PageInfo 对象保存JSP 页面编译过程中的各种配置，这些配置可 能来源于 Web 应用初始化参数， 也可能来源于JSP页面的指令配置（如 page ， include）。 </li><li>调用ParserController 解析指令节点， 验证其是否合法，同时将配置信息保存到 PageInfo 中， 用于控制代码生成。 </li><li>调用ParserController 解析整个页面， 由于 JSP 是逐行解析， 所以对于每一行会创建一个具体的Node 对象。如 静态文本（TemplateText）、Java代码（Scriptlet）、定制标签（CustomTag）、Include指令（IncludeDirective）。 </li><li>验证除指令外其他所有节点的合法性， 如 脚本、定制标签、EL表达式等。 </li><li>收集除指令外其他节点的页面配置信息。 </li><li>编译并加载当前 JSP 页面依赖的标签</li><li>对于JSP页面的EL表达式，生成对应的映射函数。 </li><li>生成JSP页面对应的Servlet 类源代码 编译代码生成完成后， Compiler 还会生成 SMAP 信息。 如果配置生成 SMAP 信息， Compiler 则会在编译阶段将SMAP 信息写到class 文件中 。 </li></ol><p>编译阶段: Compiler 的两个实现 AntCompiler 和 JDTCompiler 分别调用相关框架的 API 进行源代码编译。 对于 AntCompiler 来说， 构造一个 Ant 的javac 的任务完成编译。 对于 JDTCompiler 来说， 调用 org.eclipse.jdt.internal.compiler.Compiler 完成编译。</p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>Tomcat 服务器的配置主要集中于 tomcat/conf 下的 catalina.policy、 catalina.properties、context.xml、server.xml、tomcat-users.xml、web.xml 文件。 </p><p>tomcat-users.xml 该配置文件中，主要配置的是Tomcat的用户，角色等信息，用来控制Tomcat中 manager， host-manager的访问权限。<br>server.xml 是tomcat 服务器的核心配置文件，包含了Tomcat的 Servlet 容器 （Catalina）的所有配置。由于配置的属性特别多，我们在这里主要讲解其中的一部分重要配置。 </p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p>Server标签是server.xml的根元素，用于创建一个Server实例，默认使用的实现类是 org.apache.catalina.core.StandardServer。<br>它的属性有port : Tomcat 监听的关闭服务器的端口；shutdown： 关闭服务器的指令字符串。<br>Server内嵌的子元素为 Listener、GlobalNamingResources、Service。</p><p>默认配置的5个Listener 的含义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!‐‐ 用于以日志形式输出服务器 、操作系统、JVM的版本信息 ‐‐&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.startup.VersionLoggerListener&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!‐‐ 用于加载（服务器启动） 和 销毁 （服务器停止） APR。 如果找不到APR库， 则会 输出日志， 并不影响Tomcat启动 ‐‐&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.AprLifecycleListener&quot;</span> <span class="attr">SSLEngine</span>=<span class="string">&quot;on&quot;</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line">&lt;!‐‐ 用于避免JRE内存泄漏问题 ‐‐&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.JreMemoryLeakPreventionListener&quot;</span> /&gt;</span> </span><br><span class="line"></span><br><span class="line">&lt;!‐‐ 用户加载（服务器启动） 和 销毁（服务器停止） 全局命名服务 ‐‐&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.mbeans.GlobalResourcesLifecycleListener&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;!‐‐ 用于在Context停止时重建Executor 池中的线程， 以避免ThreadLocal 相关的内 存泄漏 ‐‐&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">&quot;org.apache.catalina.core.ThreadLocalLeakPreventionListener&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>GlobalNamingResources 中定义了全局命名服务：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!‐‐ Global JNDI resources Documentation at /docs/jndi‐resources‐howto.html ‐‐&gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span> </span><br><span class="line">    &lt;!‐‐ Editable user database that can also be used by UserDatabaseRealm to authenticate users ‐‐&gt; </span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">&quot;UserDatabase&quot;</span> <span class="attr">auth</span>=<span class="string">&quot;Container&quot;</span> <span class="attr">type</span>=<span class="string">&quot;org.apache.catalina.UserDatabase&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">description</span>=<span class="string">&quot;User database that can be updated and saved&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">factory</span>=<span class="string">&quot;org.apache.catalina.users.MemoryUserDatabaseFactory&quot;</span> </span></span><br><span class="line"><span class="tag">                <span class="attr">pathname</span>=<span class="string">&quot;conf/tomcat‐users.xml&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>该元素用于创建 Service 实例，默认使用 org.apache.catalina.core.StandardService。 一个Server服务器，可以包含多个Service。<br>默认情况下，Tomcat 仅指定了Service 的名称， 值为 “Catalina”。<br>Service 可以内嵌的 元素为 ： Listener、Executor、Connector、Engine</p><ul><li>Listener 用于为Service 添加生命周期监听器</li><li>Executor 用于配置Service 共享线程池</li><li>Connector 用于配置 Service 包含的链接器</li><li>Engine 用于配置Service中链接器对应的Servlet 容器引擎</li></ul><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>该标签用来配置共享线程池。默认情况下，Service 并未添加共享线程池配置。如果不配置共享线程池，那么Catalina 各组件在用到线程池时会独立创建。</p><h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>Connector 用于创建链接器实例。默认情况下，server.xml 配置了两个链接器，一个支 持HTTP协议，一个支持AJP协议。因此大多数情况下，我们并不需要新增链接器配置， 只是根据需要对已有链接器进行优化。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span> <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8009&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;AJP/1.3&quot;</span> <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>属性说明：</p><ul><li>port： 端口号，Connector 用于创建服务端Socket 并进行监听， 以等待客户端请求 链接。如果该属性设置为0，Tomcat将会随机选择一个可用的端口号给当前Connector 使用。 </li><li>protocol ： 当前Connector 支持的访问协议。 默认为 HTTP/1.1 ， 并采用自动切换机制选择一个基于 JAVA NIO 的链接器或者基于本地APR的链接器（根据本地是否含有 Tomcat的本地库判定）。 如果不希望采用上述自动切换的机制， 而是明确指定协议， 可以使用以下值。 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Http协议：</span><br><span class="line">org.apache.coyote.http11.Http11NioProtocol ， 非阻塞式 Java NIO 链接器 </span><br><span class="line">org.apache.coyote.http11.Http11Nio2Protocol ， 非阻塞式 JAVA NIO2 链接器 </span><br><span class="line">org.apache.coyote.http11.Http11AprProtocol ， APR 链接器</span><br><span class="line"></span><br><span class="line">AJP协议 ：</span><br><span class="line">org.apache.coyote.ajp.AjpNioProtocol ， 非阻塞式 Java NIO 链接器 </span><br><span class="line">org.apache.coyote.ajp.AjpNio2Protocol ，非阻塞式 JAVA NIO2 链接器 </span><br><span class="line">org.apache.coyote.ajp.AjpAprProtocol ， APR 链接器</span><br></pre></td></tr></table></figure><ul><li>connectionTimeOut : Connector 接收链接后的等待超时时间， 单位为 毫秒。 -1 表 示不超时。</li><li>redirectPort：当前Connector 不支持SSL请求， 接收到了一个请求， 并且也符合 security-constraint 约束， 需要SSL传输，Catalina自动将请求重定向到指定的端口。 </li><li>executor ： 指定共享线程池的名称， 也可以通过maxThreads、minSpareThreads 等属性配置内部线程池。 </li><li>URIEncoding : 用于指定编码URI的字符编码， Tomcat8.x版本默认的编码为 UTF-8 , Tomcat7.x版本默认为ISO-8859-1。</li></ul><h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h3><p>Engine 作为Servlet 引擎的顶级元素，内部可以嵌入： Cluster、Listener、Realm、 Valve和Host。<br>属性说明： </p><ul><li>name： 用于指定Engine 的名称， 默认为Catalina 。该名称会影响一部分Tomcat的存储路径（如临时文件）。 </li><li>defaultHost ： 默认使用的虚拟主机名称， 当客户端请求指向的主机无效时， 将交由默认的虚拟主机处理， 默认为localhost。</li></ul><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><p>Host 元素用于配置一个虚拟主机， 它支持以下嵌入元素：Alias、Cluster、Listener、 Valve、Realm、Context。如果在Engine下配置Realm， 那么此配置将在当前Engine下 的所有Host中共享。 同样，如果在Host中配置Realm ， 则在当前Host下的所有Context 中共享。Context中的Realm优先级 &gt; Host 的Realm优先级 &gt; Engine中的Realm优先级。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span> <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性说明： </p><ul><li>name: 当前Host通用的网络名称， 必须与DNS服务器上的注册信息一致。 Engine中 包含的Host必须存在一个名称与Engine的defaultHost设置一致。 </li><li>appBase： 当前Host的应用基础目录， 当前Host上部署的Web应用均在该目录下 （可以是绝对目录，相对路径）。默认为webapps。</li><li>unpackWARs： 设置为true， Host在启动时会将appBase目录下war包解压为目录。设置为false， Host将直接从war文件启动。 </li><li>autoDeploy： 控制tomcat是否在运行时定期检测并自动部署新增或变更的web应用。</li></ul><p>通过给Host添加别名，我们可以实现同一个Host拥有多个网络名称，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;www.web1.com&quot;</span> <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span> <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">Alias</span>&gt;</span>www.web2.com<span class="tag">&lt;/<span class="name">Alias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个时候，我们就可以通过两个域名访问当前Host下的应用（需要确保DNS或hosts中添 加了域名的映射配置）。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>Context 用于配置一个Web应用信息，一般在web.xml中配置</p><h2 id="Web-应用配置"><a href="#Web-应用配置" class="headerlink" title="Web 应用配置"></a>Web 应用配置</h2><p>web.xml 是web应用的描述文件， 它支持的元素及属性来自于Servlet 规范定义。<br>在 Tomcat 中， Web 应用的描述信息包括 tomcat/conf/web.xml 中默认配置 以及 Web 应用 WEB-INF/web.xml 下的定制配置。</p><h3 id="ServletContext-初始化参数"><a href="#ServletContext-初始化参数" class="headerlink" title="ServletContext 初始化参数"></a>ServletContext 初始化参数</h3><p>我们可以通过 添加ServletContext 初始化参数，它配置了一个键值对，这样我们可以在 应用程序中使用 javax.servlet.ServletContext.getInitParameter()方法获取参数。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;context‐param&gt; </span><br><span class="line">    &lt;param‐name&gt;contextConfigLocation&lt;/param‐name&gt; </span><br><span class="line">    &lt;param‐value&gt;classpath:applicationContext‐*.xml&lt;/param‐value&gt; </span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Spring Config File Location<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">&lt;/context‐param&gt;</span><br></pre></td></tr></table></figure><h3 id="会话配置"><a href="#会话配置" class="headerlink" title="会话配置"></a>会话配置</h3><p>用于配置Web应用会话，包括 超时时间、Cookie配置以及会话追踪模式。它将覆盖 server.xml 和 context.xml 中的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;session‐config&gt; </span><br><span class="line">    &lt;session‐timeout&gt;30&lt;/session‐timeout&gt; </span><br><span class="line">    &lt;cookie‐config&gt; </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>JESSIONID<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">domain</span>&gt;</span>www.itcast.cn<span class="tag">&lt;/<span class="name">domain</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>Session Cookie<span class="tag">&lt;/<span class="name">comment</span>&gt;</span> </span><br><span class="line">        &lt;http‐only&gt;true&lt;/http‐only&gt;  <span class="comment">&lt;!-- cookie只能通过HTTP方式进行访问，JS无法读取或修改，此项可以增 加网站访问的安全性。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">secure</span>&gt;</span>false<span class="tag">&lt;/<span class="name">secure</span>&gt;</span>  <span class="comment">&lt;!-- 此cookie只能通过HTTPS连接传递到服务器，而HTTP 连接则不会传递该 信息。注意是从浏览器传递到服务器，服务器端的Cookie对象不受此项影响。 --&gt;</span></span><br><span class="line">        &lt;max‐age&gt;3600&lt;/max‐age&gt; <span class="comment">&lt;!-- 以秒为单位表示cookie的生存期，默认为‐1表示是会话Cookie，浏览器 关闭时就会消失。 --&gt;</span></span><br><span class="line">    &lt;/cookie‐config&gt; </span><br><span class="line">    &lt;tracking‐mode&gt;COOKIE&lt;/tracking‐mode&gt; <span class="comment">&lt;!-- 用于配置会话追踪模式，Servlet3.0版本中支持的追踪模式： COOKIE、URL、SSL --&gt;</span></span><br><span class="line">&lt;/session‐config&gt;</span><br></pre></td></tr></table></figure><p>追踪模式：</p><ul><li>COOKIE : 通过HTTP Cookie 追踪会话是最常用的会话追踪机制， 而且 Servlet规范也要求所有的Servlet规范都需要支持Cookie追踪。 </li><li>URL : URL重写是最基本的会话追踪机制。当客户端不支持Cookie时，可以采 用URL重写的方式。当采用URL追踪模式时，请求路径需要包含会话标识信息，Servlet容器 会根据路径中的会话标识设置请求的会话信息。如： http：//<a href="http://www.myserver.com/user/index.html;jessionid=1234567890%E3%80%82">www.myserver.com/user/index.html;jessionid=1234567890。</a> </li><li>SSL : 对于SSL请求， 通过SSL会话标识确定请求会话标识。</li></ul><h3 id="Servlet配置"><a href="#Servlet配置" class="headerlink" title="Servlet配置"></a>Servlet配置</h3><p>Servlet 的配置主要是两部分， servlet 和 servlet-mapping</p><p>Servlet 中文件上传时的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span> </span><br><span class="line">    &lt;servlet‐name&gt;uploadServlet&lt;/servlet‐name&gt; </span><br><span class="line">    &lt;servlet‐class&gt;cn.xxx.web.UploadServlet&lt;/servlet‐class&gt; </span><br><span class="line">    &lt;multipart‐config&gt; </span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>C://path<span class="tag">&lt;/<span class="name">location</span>&gt;</span> </span><br><span class="line">        &lt;max‐file‐size&gt;10485760&lt;/max‐file‐size&gt;  <span class="comment">&lt;!-- 允许上传的文件最大值。 默认值为‐1， 表示没有限制。 --&gt;</span></span><br><span class="line">        &lt;max‐request‐size&gt;10485760&lt;/max‐request‐size&gt;  <span class="comment">&lt;!-- 针对该 multi/form‐data 请求的最大数量，默认值为‐1， 表示 无限制。 --&gt;</span></span><br><span class="line">        &lt;file‐size‐threshold&gt;0&lt;/file‐size‐threshold&gt;  <span class="comment">&lt;!-- 当数量量大于该值时， 内容会被写入文件。 --&gt;</span></span><br><span class="line">    &lt;/multipart‐config&gt; </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Listener配置"><a href="#Listener配置" class="headerlink" title="Listener配置"></a>Listener配置</h3><p>Listener用于监听servlet中的事件，例如context、request、session对象的创建、修 改、删除，并触发响应事件。<br>Listener是观察者模式的实现，在servlet中主要用于对 context、request、session对象的生命周期进行监控。<br>在servlet2.5规范中共定义了8中 Listener。在启动时，ServletContextListener 的执行顺序与web.xml 中的配置顺序一 致， 停止时执行顺序相反。</p><h3 id="Filter配置"><a href="#Filter配置" class="headerlink" title="Filter配置"></a>Filter配置</h3><p>filter 用于配置web应用过滤器， 用来过滤资源请求及响应。 经常用于认证、日志、加密、数据转换等操作。</p><h3 id="欢迎页面配置"><a href="#欢迎页面配置" class="headerlink" title="欢迎页面配置"></a>欢迎页面配置</h3><p>welcome-file-list 用于指定web应用的欢迎文件列表。尝试请求的顺序，从上到下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;welcome‐file‐list&gt; </span><br><span class="line">    &lt;welcome‐file&gt;index.html&lt;/welcome‐file&gt; </span><br><span class="line">    &lt;welcome‐file&gt;index.htm&lt;/welcome‐file&gt; </span><br><span class="line">    &lt;welcome‐file&gt;index.jsp&lt;/welcome‐file&gt; </span><br><span class="line">&lt;/welcome‐file‐list&gt;</span><br></pre></td></tr></table></figure><h3 id="错误页面配置"><a href="#错误页面配置" class="headerlink" title="错误页面配置"></a>错误页面配置</h3><p>error-page 用于配置Web应用访问异常时定向到的页面，支持HTTP响应码和异常类两种 形式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;error‐page&gt; </span><br><span class="line">    &lt;error‐code&gt;404&lt;/error‐code&gt; </span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span> </span><br><span class="line">&lt;/error‐page&gt; </span><br><span class="line"></span><br><span class="line">&lt;error‐page&gt; </span><br><span class="line">    &lt;error‐code&gt;500&lt;/error‐code&gt; </span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/500.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span> </span><br><span class="line">&lt;/error‐page&gt; </span><br><span class="line"></span><br><span class="line">&lt;error‐page&gt; </span><br><span class="line">    &lt;exception‐type&gt;java.lang.Exception&lt;/exception‐type&gt; </span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span> </span><br><span class="line">&lt;/error‐page&gt;</span><br></pre></td></tr></table></figure><h2 id="Tomcat-管理配置"><a href="#Tomcat-管理配置" class="headerlink" title="Tomcat 管理配置"></a>Tomcat 管理配置</h2><p>从早期的Tomcat版本开始，就提供了Web版的管理控制台，他们是两个独立的Web应 用，位于webapps目录下。Tomcat 提供的管理应用有用于管理的Host的host-manager 和用于管理Web应用的manager。 </p><h3 id="host-manager"><a href="#host-manager" class="headerlink" title="host-manager"></a>host-manager</h3><p>Tomcat启动之后，可以通过 <a href="http://localhost:8080/host-manager/html">http://localhost:8080/host-manager/html</a> 访问该Web应用。 host-manager 默认添加了访问权限控制，当打开网址时，需要输入用户名和密码 （conf/tomcat-users.xml中配置） 。所以要想访问该页面，需要在conf/tomcat-users.xml 中配置，并分配对应的角色：</p><ul><li>admin-gui：用于控制页面访问权限 </li><li>admin-script：用于控制以简单文本的形式进行访问</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;admin‐gui&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;admin‐script&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;fuyi&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123546&quot;</span> <span class="attr">roles</span>=<span class="string">&quot;admin‐script,admin‐gui&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="web-manager"><a href="#web-manager" class="headerlink" title="web-manager"></a>web-manager</h3><p>manager的访问地址为 <a href="http://localhost:8080/manager%EF%BC%8C">http://localhost:8080/manager，</a> 同样， manager也添加了页面访问控制，因此我们需要为登录用户分配角色为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;admin-gui&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;admin-script&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-gui&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-script&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">&quot;manager-status&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">&quot;fuyi&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span> <span class="attr">roles</span>=<span class="string">&quot;admin-script,admin-gui,manager-gui,manager-script,manager-status&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JVM-配置"><a href="#JVM-配置" class="headerlink" title="JVM 配置"></a>JVM 配置</h2><p>最常见的JVM配置当属内存分配，因为在绝大多数情况下，JVM默认分配的内存可能不能够满足我们的需求，特别是在生产环境，此时需要手动修改Tomcat启动时的内存参数分配。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.bilibili.com/video/BV1dJ411N7Um">https://www.bilibili.com/video/BV1dJ411N7Um</a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;官网：&lt;a href=&quot;http://tomcat.apache.org/&quot;&gt;http://tomcat.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;常见web服务器软件&quot;&gt;&lt;a href=&quot;#常见web服务器软件&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Java-基础知识</title>
    <link href="http://yoursite.com/wiki/%E5%90%8E%E7%AB%AF/Java/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/wiki/后端/Java/Java-基础知识/</id>
    <published>2021-04-19T02:01:43.000Z</published>
    <updated>2021-04-19T07:23:38.588Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常体系"><a href="#异常体系" class="headerlink" title="异常体系"></a>异常体系</h2><p>所有异常都是Throwable类的子类，注意Throwable是类不是接口。</p><p>Throwable类包含Exception类和Error类，Exception类又包含检查异常和未检查异常。</p><hr><p>异常定义：程序在运行期间发生的不正常事件，它会打断指令的正常流程，在编译期间产生的叫语法错误。</p><ol><li>程序在运行时产生异常时，JVM会创建一个异常对象，交给运行时系统。</li><li>运行时系统在抛出异常代码附近寻找处理方式。</li><li>两种处理方式：<ul><li>catch: 自己捕获处理</li><li>throws: 抛给调用者</li></ul></li></ol><h3 id="未检查异常-运行时异常（RuntimeException）"><a href="#未检查异常-运行时异常（RuntimeException）" class="headerlink" title="未检查异常/运行时异常（RuntimeException）"></a>未检查异常/运行时异常（RuntimeException）</h3><p>对于该异常，Java编译器不要求你一定要捕获或抛出。</p><p>RuntimeException的子类都是未检查异常，不需处理。如下：</p><ul><li>NullPointerException</li><li>ClassCastException</li><li>ArrayIndexsOutOfBoundsException</li><li>ArithmeticException(算术异常，除0溢出)</li></ul><h3 id="检查异常"><a href="#检查异常" class="headerlink" title="检查异常"></a>检查异常</h3><p>必须要在方法中捕获或抛出。如：IOException属于检查异常，必须要捕获或再次抛出。</p><ul><li>FileNotFoundException</li><li>IOException</li><li>SQLException</li></ul><h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><h3 id="transient的作用及使用方法"><a href="#transient的作用及使用方法" class="headerlink" title="transient的作用及使用方法"></a>transient的作用及使用方法</h3><p>我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。</p><p>然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p><p>总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p><p>示例code如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">&quot;Alexia&quot;</span>);</span><br><span class="line">        user.setPasswd(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;C:/user.txt&quot;</span>));</span><br><span class="line">        os.writeObject(user); <span class="comment">// 将User对象写进文件</span></span><br><span class="line">        os.flush();</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:/user.txt&quot;</span>));</span><br><span class="line">        user = (User) is.readObject(); <span class="comment">// 从流中读取User的数据</span></span><br><span class="line">        is.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;read after Serializable: &quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;username: &quot;</span> + user.getUsername()); <span class="comment">// Alexia</span></span><br><span class="line">        System.err.println(<span class="string">&quot;password: &quot;</span> + user.getPasswd());  <span class="comment">// output null；说明反序列化时根本没有从文件中获取到信息。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8294180014912103005L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String passwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transient说明"><a href="#transient说明" class="headerlink" title="transient说明"></a>transient说明</h3><ul><li>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</li><li>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类，则该类需要实现Serializable接口。</li><li>transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</li></ul><p>第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的。</p><h3 id="transient关键字修饰的变量真的不能被序列化吗？"><a href="#transient关键字修饰的变量真的不能被序列化吗？" class="headerlink" title="transient关键字修饰的变量真的不能被序列化吗？"></a>transient关键字修饰的变量真的不能被序列化吗？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalizableTest</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String content = <span class="string">&quot;是的，我将会被序列化，不管我是否被transient关键字修饰&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeObject(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        content = in.readObject().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ExternalizableTest et = <span class="keyword">new</span> ExternalizableTest();</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;F:/test.txt&quot;</span>));</span><br><span class="line">        out.writeObject(et);</span><br><span class="line"></span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;F:/test.txt&quot;</span>));</span><br><span class="line">        et = (ExternalizableTest) in.readObject();</span><br><span class="line">        System.out.println(et.content); <span class="comment">// content初始化的内容，而不是null，transient关键字没有起作用</span></span><br><span class="line"></span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变量content初始化的内容，而不是null。</p><h3 id="部分序列化的实现方式"><a href="#部分序列化的实现方式" class="headerlink" title="部分序列化的实现方式"></a>部分序列化的实现方式</h3><ul><li>实现Serializable接口，不想序列化的字段使用transient关键字修饰</li><li>实现Serializable接口，添加writeObject和readObject方法，方法签名在Serializable接口注释中有说明</li><li>实现Externalizable接口，重写writeExternal和readExternal方法</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常体系&quot;&gt;&lt;a href=&quot;#异常体系&quot; class=&quot;headerlink&quot; title=&quot;异常体系&quot;&gt;&lt;/a&gt;异常体系&lt;/h2&gt;&lt;p&gt;所有异常都是Throwable类的子类，注意Throwable是类不是接口。&lt;/p&gt;
&lt;p&gt;Throwable类包含Exce
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java常见规范</title>
    <link href="http://yoursite.com/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B8%B8%E8%A7%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/wiki/后端/Java/Java常见规范/</id>
    <published>2021-04-19T01:36:03.000Z</published>
    <updated>2021-04-20T03:20:33.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Common-Annotations"><a href="#Common-Annotations" class="headerlink" title="Common Annotations"></a>Common Annotations</h2><p>JSR-250: <a href="http://jcp.org/en/jsr/detail?id=250">http://jcp.org/en/jsr/detail?id=250</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.annotation&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.annotation-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>@PostConstruct: 见名知意，被该注解标注的方法在构造方法执行后才执行，一般用来做一些初始化工作，如果该类中有需要依赖注入的成员，则会在依赖注入完成后才执行该方法。它标注的方法签名有一些限制：不能有方法参数、void返回值、不能是static的等，在该注解注释中有说明。</li><li>@PreDestroy：见名知意，被修饰的方法是一个回调通知方法，当该方法所属类的实例从容器中移除时调用的，该方法通常用来释放一些持有的资源。方法签名要求同@PostConstruct。</li></ul><h2 id="bean-validation"><a href="#bean-validation" class="headerlink" title="bean validation"></a>bean validation</h2><ul><li>官网：<a href="https://beanvalidation.org/">https://beanvalidation.org</a></li><li>JSR-308: Bean Validation 2.0      <a href="https://jcp.org/en/jsr/detail?id=380">https://jcp.org/en/jsr/detail?id=380</a></li><li>JSR-349: Bean Validation 1.1      <a href="https://jcp.org/en/jsr/detail?id=349">https://jcp.org/en/jsr/detail?id=349</a></li><li>JSR-303: Bean Validation 1.0      <a href="https://jcp.org/en/jsr/detail?id=303">https://jcp.org/en/jsr/detail?id=303</a></li><li>推荐实现 Hibernate Validator       <a href="http://www.hibernate.org/subprojects/validator.html">http://www.hibernate.org/subprojects/validator.html</a></li></ul><p>Hibernate Validator提供了规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。</p><p>一个 constraint就是一个约束，一个 constraint 通常由 annotation 和相应的 constraint validator 组成，它们是一对多的关系。也就是说一个 annotation 可以有多个 constraint validator 对应。在运行时，Bean Validation 框架本身会根据被注释元素的类型来选择合适的 constraint validator 对数据进行验证。</p><p>有些时候，在用户的应用中需要一些更复杂的 constraint。Bean Validation 提供扩展 constraint 的机制。可以通过两种方法去实现，一种是组合现有的 constraint 来生成一个更复杂的 constraint，另外一种是开发一个全新的 constraint。</p><p>PS: 在Spring项目中，在Controller的方法入参中只需要给被校验实体加 @Valid注解方可生效</p><h2 id="JAS-RS"><a href="#JAS-RS" class="headerlink" title="JAS-RS"></a>JAS-RS</h2><p>JAX-RS是JAVA EE6 引入的一个新技术。 JAX-RS即Java API for RESTful Web Service，使用了Java SE5引入的Java注解来简化Web服务的客户端和服务端的开发和部署。</p><p>JAX-RS提供了一些注解将一个资源类，一个POJO Java类，封装为Web资源。包括：</p><ul><li>@Path，标注资源类或者方法的相对路径</li><li>@GET，@PUT，@POST，@DELETE，标注方法是HTTP请求的类型。</li><li>@Produces，标注返回的MIME媒体类型</li><li>@Consumes，标注可接受请求的MIME媒体类型</li><li>@PathParam，@QueryParam，@HeaderParam，@CookieParam，@MatrixParam，@FormParam,分别标注方法的参数来自于HTTP请求的不同位置，例如@PathParam来自于URL的路径，@QueryParam来自于URL的查询参数，@HeaderParam来自于HTTP请求的头信息，@CookieParam来自于HTTP请求的Cookie。</li></ul><p>基于JAX-RS实现的框架有Jersey，RESTEasy等。这两个框架创建的应用可以很方便地部署到Servlet 容器中，比如Tomcat，JBoss等。值得一提的是RESTEasy是由JBoss公司开发的，所以将用RESTEasy框架实现的应用部署到JBoss服务器上，可以实现很多额外的功能。</p><h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><p>JPA全称为Java Persistence API ，Java持久化API是Sun公司在Java EE 5规范中提出的Java持久化接口。JPA吸取了目前Java持久化技术的优点，旨在规范、简化Java对象的持久化工作。它只是一套规范API接口，使用JPA持久化对象，并不是依赖于某一个具体框架实现，这保证了基于JPA开发的企业应用能够经过少量的修改就能够在不同的实现下运行。常见JPA实现如下：</p><ul><li>Hibernate</li><li>MyBatis</li><li>Spring Data JPA</li><li>TopLink: Oracle公司的产品，作为一个遵循OTN协议的商业产品，TopLink 在开发过程中可以自由地下载和使用，但是一旦作为商业产品被使用，则需要收取费用。由于这一点，TopLink 的市场占有率不高。</li></ul><p>目前JPA最新版本为2017年发布的JPA 2.2： <a href="https://jcp.org/en/jsr/detail?id=338">https://jcp.org/en/jsr/detail?id=338</a></p><p>核心组件如下：</p><ul><li>EntityManagerFactory接口: 创建和管理多个EntityManager实例</li><li>EntityManager接口：管理对象Entity的CRUD操作(create, update, delete, Query)</li><li>Entity: 对应需要持久化的对象实体</li><li>EntityTransaction接口: 对事务的处理接口，与EntityManager一对一</li><li>Persistence类: 包含获取EntityManagerFactory实例的静态方法</li><li>Query接口: 获取满足creteria的关系对象</li></ul><h2 id="OGNL"><a href="#OGNL" class="headerlink" title="OGNL"></a>OGNL</h2><p><a href="http://commons.apache.org/proper/commons-ognl/">http://commons.apache.org/proper/commons-ognl/</a></p><p>对象导航图语言（Object Graph Navigation Language），简称OGNL，是应用于Java中的一个开源的表达式语言（Expression Language），它被集成在Struts2等框架中，作用是对数据进行访问，它拥有类型转换、访问对象方法、操作集合对象等功能。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Common-Annotations&quot;&gt;&lt;a href=&quot;#Common-Annotations&quot; class=&quot;headerlink&quot; title=&quot;Common Annotations&quot;&gt;&lt;/a&gt;Common Annotations&lt;/h2&gt;&lt;p&gt;JSR-25
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>从Java EE 到 Jakarta EE</title>
    <link href="http://yoursite.com/wiki/%E5%90%8E%E7%AB%AF/Java/%E4%BB%8EJava%20EE%20%E5%88%B0%20Jakarta%20EE/"/>
    <id>http://yoursite.com/wiki/后端/Java/从Java EE 到 Jakarta EE/</id>
    <published>2021-04-16T06:05:23.000Z</published>
    <updated>2021-04-19T08:19:12.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关名词"><a href="#相关名词" class="headerlink" title="相关名词"></a>相关名词</h2><ul><li>JCP: 全称Java Community Process，是一个开放的国际组织，主要由Java开发者以及被授权者组成，维护Java相关规范，审核Java规范提案。JCP官网：<a href="https://jcp.org/">https://jcp.org/</a></li><li>JSR: 全称Java Specification Requests，译为Java规范提案。</li><li>TCK: 全称Technology Compatibility Kit，用于测试基于API和规范文档对应实现的测试代码，成功通过TCK测试是实现是对应规范的兼容实现</li><li>Glassfish：成功通过TCK测试的规范实现，在Java EE被捐给Eclipse基金会之前，称Oracle Glassfish，是Java EE的兼容实现，现在称Eclipse Glassfish，是Jakarta EE的兼容实现。</li></ul><h2 id="Java-EE的历史"><a href="#Java-EE的历史" class="headerlink" title="Java EE的历史"></a>Java EE的历史</h2><ol><li>1996年， Sun公司正式推出了Java 1.0版本，”一次编译，到处运行”的概念风靡全球技术生态圈，立刻赢得开发者的青睐，长期以来霸占着企业级开发的头把交椅。Java语言的发展和传播非常迅速，经历了JDK 1.1 和1.2 两个版本的发布之后，Sun公司随即就发布了Java企业级版本，简称J2EE。它的目标是基于Java SE建立一整套标准，致力于企业级Java应用的开发。</li><li>2006年5月，“J2EE”一词被弃用，并选择了Java EE这个名称。同样，作为Java SE 5（2004）的一部分，数字2也从J2SE中删除了。</li><li>2006年底，Sun公司决定开始基于GPL开源绝大部分的Java虚拟机(JVM)代码，到了2007年初，整个开源过程结束，全部的JVM代码都已经开源并用于公开发行。随后OpenJDK诞生，成为Java SE版本的开源实现。<a href="http://openjdk.java.net/">http://openjdk.java.net/</a></li><li>直到2009年Sun公司被Oracle收购，十年的发展，Java EE版本也发布到了Java EE6，期间也部署了无数的企业应用，诞生了各种Java EE标准兼容的运行时应用服务器，知名的有Apache Tomcat，Oracle Weblogic，Oracle Jboss，IBM Websphere等。</li><li>2009-2010年间，Oracle公司收购了Sun 公司，宣称会继续支持和投入Java的发展。然而2010年，Java之父James Gosling的离职和2012年跟Google的关于Java在安卓的使用法律诉讼，使得社区对于Java语言的发展信心蒙上了一层阴影。</li><li>为了给Java社区注入一剂强心剂，时隔5年之后，Oracle公司在2011年和2013年分别发布了JDK7和Java EE 7。虽然Java EE依然受到企业级的追捧，但是随着Spring的框架的不断演进，新的开发者和原先的一些企业开始转向Spring，同时Java EE自身平台变得原来越臃肿，无法满足业务的日益变化和适应云原生，微服务架构的技术需求。这一切使得Oracle坚信开源模式是对JAVA EE最好的选择。</li></ol><ul><li>2015年7月3日：Java EE 7规范为JSR-342，<a href="https://jcp.org/en/jsr/detail?id=342">https://jcp.org/en/jsr/detail?id=342</a></li><li>2017年9月18日：Java EE 8规范为JSR-366，<a href="https://jcp.org/en/jsr/detail?id=366">https://jcp.org/en/jsr/detail?id=366</a></li></ul><h2 id="MicroProfile产生背景"><a href="#MicroProfile产生背景" class="headerlink" title="MicroProfile产生背景"></a>MicroProfile产生背景</h2><p>传统的Java EE发展遇到了各种问题，主要是微服务架构和云原生两大问题，为了更好的服务微服务架构，2016年6月Java EE社区大公司联合成立了MicroProfile项目，专注于微服务架构标准的制定，并加入Eclipse基金会。随后Java EE为了更好的拥抱云原生和保持创新，在2017年9月Oracle将其贡献给了Eclipse基金会了，并更名为Jakata EE。</p><p>MicroProfile只是一套标准和规范，本身并不提供实现，对应的运行时实现由各厂商提供，另外主要专注于微服务架构相关的规范比如可注入配置，故障隔离，安全(JWT), 可观测性，分布式跟踪，健康检查，OpenAPI，响应式异步REST客户端等，这些规范重要的一个目标是兼容目前业界主流的云平台如Kubernetes。现在MicroProfile项目如此优秀，那么Java EE该如何走，MicroProfile创建的相关规范和功能如何引入到Java EE？答案是Jakarta EE。</p><p>MicroProfile项目的目标是在短周期内进行迭代和创新，以提出新的通用API和功能，获得社区的认可，发布和重复。最终该项目的输出可以提交给Jakarta EE，JCP，OpenJDK或任何相关的标准机构。</p><ul><li>官网：<a href="https://microprofile.io/">https://microprofile.io/</a></li><li>项目地址: <a href="https://projects.eclipse.org/projects/technology.microprofile">https://projects.eclipse.org/projects/technology.microprofile</a></li><li>项目wiki: <a href="https://wiki.eclipse.org/MicroProfile">https://wiki.eclipse.org/MicroProfile</a></li><li>项目源码：<a href="https://github.com/eclipse?utf8=%E2%9C%93&amp;q=microprofile">https://github.com/eclipse?utf8=%E2%9C%93&amp;q=microprofile</a></li><li>规范实现：<a href="https://wiki.eclipse.org/MicroProfile/Implementation">https://wiki.eclipse.org/MicroProfile/Implementation</a></li></ul><h2 id="Jakarta-EE的诞生"><a href="#Jakarta-EE的诞生" class="headerlink" title="Jakarta EE的诞生"></a>Jakarta EE的诞生</h2><p>2017年Oracle正式决定将Java EE贡献给Eclipse基金会。Oracle放弃了大部分 Java EE 知识产权之后，但由于 Oracle 目前仍保留了 Java 的商标权，所以Eclipse需要一个新的命名，经过社区调查投票，新的项目正式更名为Jakarta EE，成立Eclipse Enterprise for Java (EE4J)父项目进行管理。</p><p>目前Oracle已经或者正在将原来JavaEE的产品文档；原JavaEE的TCK测试用例代码；Glassfish参考实现的源码，包含子项目如<code>Jersey, Mojarra, Tyrus, OpenMQ, EclipseLink, JsonP</code>等迁移到Eclipse组织。</p><p>Jakarta EE被寄予厚望，不但继承了原来JavaEE的企业级应用市场的优势，也准备在Cloud Native方向大有作为。不出意外的话，Microprofile的各项规范将会合并入下一版本的Jakarta EE规范之中。同时，也会对Docker和Kubernates等容器环境有优异的集成能力。</p><p>在云原生时代，我们见证的众多开源项目的成功，诸如Kubernetes，Envoy，Spring Boot，强大的社区灵活有效的运作模式对于项目的成功至关重要。反观在Java EE时代，最初Java的创建者Sun公司，后来的Oracle公司，维护着Java执行委员会JCP（Java Community Process)，控制着版本发布的节奏，其中的JSR（Java Specification Requests 规范提案）包含了20年来Java语言的规范文本和API定义，复杂繁琐的JCP审核流程，导致Java EE版本的发布和新功能的引入无比缓慢，这也是Jakarta EE试图改变的局面。在Eclipse基金会治下，工作组秉承自我管理的精髓，制定所有发布日常和计划，与此同时标准和规范的制定也完全以社区为导向，鼓励开发者，厂商和组织参与制定流程以此来反应社区的意志，通过快速迭代，在新版本中不断融入其它开源社区的功能创新，如MicroProfile，帮助开发者构建云原生应用。</p><p>Jakarta EE 规范将不会在 JCP 下，而是由 Jakarta EE 工作组定义并由规范委员会批准，JCP 将仅负责 Java SE 和 Java ME 规范。</p><p>2019年9月10日：发布Jakarta EE 8，完全兼容Java EE 8，主要是进行了代码迁移及包改名<br>2020年11月20日：发布Jakarta EE 9</p><hr><ul><li>官网：<a href="https://jakarta.ee/">https://jakarta.ee/</a></li><li>EE4J项目地址：<a href="https://projects.eclipse.org/projects/ee4j">https://projects.eclipse.org/projects/ee4j</a></li><li>EE4J项目源码地址：<a href="https://github.com/eclipse-ee4j">https://github.com/eclipse-ee4j</a></li><li>Jakarta EE规范文档：<a href="https://github.com/eclipse-ee4j/jakartaee-platform/releases">https://github.com/eclipse-ee4j/jakartaee-platform/releases</a></li><li>改名公告：<a href="https://eclipse-foundation.blog/2018/02/26/and-the-name-is/">https://eclipse-foundation.blog/2018/02/26/and-the-name-is/</a></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="http://www.useopen.com/categories/jakartaee/">http://www.useopen.com/categories/jakartaee/</a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;相关名词&quot;&gt;&lt;a href=&quot;#相关名词&quot; class=&quot;headerlink&quot; title=&quot;相关名词&quot;&gt;&lt;/a&gt;相关名词&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;JCP: 全称Java Community Process，是一个开放的国际组织，主要由Java开发者以及被授权
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>sql1992.txt</title>
    <link href="http://yoursite.com/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/sql1992-txt/"/>
    <id>http://yoursite.com/wiki/中间件/MySQL/sql1992-txt/</id>
    <published>2021-04-11T07:34:55.000Z</published>
    <updated>2021-04-19T06:29:54.897Z</updated>
    
    <content type="html"><![CDATA[<p>源地址：<a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt</a></p><p>(This is stale and you may wish to find a more up-to-date copy, but it is preserved here for posterity. Enjoy – Daria 24 Nov 2017)</p><pre><code>                                                Information Technology -                                                   Database Language SQL                                     (Proposed revised text of DIS 9075)                                                               July 1992</code></pre><p></p><pre><code>     (Second Informal Review Draft) ISO/IEC 9075:1992, Database     Language SQL- July 30, 1992     Digital Equipment Corporation     Maynard, Massachusetts</code></pre><p></p><pre><code>    Contents                                                       Page    Foreword.........................................................xi    Introduction.....................................................xiii    1  Scope ........................................................ 1    2  Normative references ......................................... 3    3  Definitions, notations, and conventions ...................... 5    3.1  Definitions ................................................ 5    3.1.1Definitions taken from ISO/IEC 10646 ....................... 5    3.1.2Definitions taken from ISO 8601 ............................ 5    3.1.3Definitions provided in this International Standard ........ 5    3.2  Notation ................................................... 7    3.3  Conventions ................................................ 9    3.3.1Informative elements ....................................... 9    3.3.2Specification of syntactic elements ........................ 9    3.3.3Specification of the Information Schema ....................10    3.3.4Use of terms ...............................................10    3.3.4Exceptions .................................................10    3.3.4Syntactic containment ......................................11    3.3.4Terms denoting rule requirements ...........................12    3.3.4Rule evaluation order ......................................12    3.3.4Conditional rules ..........................................13    3.3.4Syntactic substitution .....................................13    3.3.4Other terms ................................................14    3.3.5Descriptors ................................................14    3.3.6Index typography ...........................................15    3.4  Object identifier for Database Language SQL ................16    4  Concepts .....................................................19    4.1  Data types .................................................19    4.2  Character strings ..........................................20    4.2.1Character strings and collating sequences ..................20    4.2.2Operations involving character strings .....................22    4.2.2Operators that operate on character strings and return char-         acter strings...............................................22    4.2.2Other operators involving character strings ................23    4.2.3Rules determining collating sequence usage .................23    4.3  Bit strings ................................................26    4.3.1Bit string comparison and assignment .......................27    4.3.2Operations involving bit strings ...........................27    4.3.2Operators that operate on bit strings and return bit strings         ............................................................27    4.3.2Other operators involving bit strings ......................27    ii  Database Language SQL</code></pre><p></p><pre><code>     4.4  Numbers ....................................................27     4.4.1Characteristics of numbers .................................28     4.4.2Operations involving numbers ...............................29     4.5  Datetimes and intervals ....................................29     4.5.1Datetimes ..................................................30     4.5.2Intervals ..................................................32     4.5.3Operations involving datetimes and intervals ...............34     4.6  Type conversions and mixing of data types ..................34     4.7  Domains ....................................................35     4.8  Columns ....................................................36     4.9  Tables .....................................................37     4.10 Integrity constraints ......................................40     4.10.Checking of constraints ....................................41     4.10.Table constraints ..........................................41     4.10.Domain constraints .........................................43     4.10.Assertions .................................................43     4.11 SQL-schemas ................................................44     4.12 Catalogs ...................................................45     4.13 Clusters of catalogs .......................................45     4.14 SQL-data ...................................................45     4.15 SQL-environment ............................................46     4.16 Modules ....................................................46     4.17 Procedures .................................................47     4.18 Parameters .................................................47     4.18.Status parameters ..........................................47     4.18.Data parameters ............................................48     4.18.Indicator parameters .......................................48     4.19 Diagnostics area ...........................................48     4.20 Standard programming languages .............................49     4.21 Cursors ....................................................49     4.22 SQL-statements .............................................51     4.22.Classes of SQL-statements ..................................51     4.22.SQL-statements classified by function ......................52     4.22.Embeddable SQL-statements ..................................55     4.22.Preparable and immediately executable SQL-statements .......56     4.22.Directly executable SQL-statements .........................58     4.22.SQL-statements and transaction states ......................59     4.23 Embedded syntax ............................................61     4.24 SQL dynamic statements .....................................61     4.25 Direct invocation of SQL ...................................64     4.26 Privileges .................................................64     4.27 SQL-agents .................................................66     4.28 SQL-transactions ...........................................67     4.29 SQL-connections ............................................70     4.30 SQL-sessions ...............................................72                                                  Table of Contents  iii</code></pre><p></p><pre><code>     4.31 Client-server operation ....................................74     4.32 Information Schema .........................................75     4.33 Leveling ...................................................75     4.34 SQL Flagger ................................................76     5  Lexical elements .............................................79     5.1  &lt;SQL terminal character&gt; ...................................79     5.2  &lt;token&gt; and &lt;separator&gt; ....................................82     5.3  &lt;literal&gt; ..................................................89     5.4  Names and identifiers ......................................98     6  Scalar expressions ...........................................107     6.1  &lt;data type&gt; ................................................107     6.2  &lt;value specification&gt; and &lt;target specification&gt; ...........114     6.3  &lt;table reference&gt; ..........................................118     6.4  &lt;column reference&gt; .........................................121     6.5  &lt;set function specification&gt; ...............................124     6.6  &lt;numeric value function&gt; ...................................128     6.7  &lt;string value function&gt; ....................................132     6.8  &lt;datetime value function&gt; ..................................139     6.9  &lt;case expression&gt; ..........................................141     6.10 &lt;cast specification&gt; .......................................144     6.11 &lt;value expression&gt; .........................................155     6.12 &lt;numeric value expression&gt; .................................157     6.13 &lt;string value expression&gt; ..................................160     6.14 &lt;datetime value expression&gt; ................................165     6.15 &lt;interval value expression&gt; ................................168     7  Query expressions ............................................173     7.1  &lt;row value constructor&gt; ....................................173     7.2  &lt;table value constructor&gt; ..................................176     7.3  &lt;table expression&gt; .........................................177     7.4  &lt;from clause&gt; ..............................................178     7.5  &lt;joined table&gt; .............................................180     7.6  &lt;where clause&gt; .............................................185     7.7  &lt;group by clause&gt; ..........................................187     7.8  &lt;having clause&gt; ............................................189     7.9  &lt;query specification&gt; ......................................191     7.10 &lt;query expression&gt; .........................................196     7.11 &lt;scalar subquery&gt;, &lt;row subquery&gt;, and &lt;table subquery&gt; ....203     8  Predicates ...................................................205     8.1  &lt;predicate&gt; ................................................205     8.2  &lt;comparison predicate&gt; .....................................207     8.3  &lt;between predicate&gt; ........................................211     8.4  &lt;in predicate&gt; .............................................212     iv  Database Language SQL</code></pre><p></p><pre><code>     8.5  &lt;like predicate&gt; ...........................................214     8.6  &lt;null predicate&gt; ...........................................218     8.7  &lt;quantified comparison predicate&gt; ..........................220     8.8  &lt;exists predicate&gt; .........................................222     8.9  &lt;unique predicate&gt; .........................................223     8.10 &lt;match predicate&gt; ..........................................224     8.11 &lt;overlaps predicate&gt; .......................................227     8.12 &lt;search condition&gt; .........................................229     9  Data assignment rules ........................................231     9.1  Retrieval assignment .......................................231     9.2  Store assignment ...........................................234     9.3  Set operation result data types ............................237     10 Additional common elements ...................................239     10.1 &lt;interval qualifier&gt; .......................................239     10.2 &lt;language clause&gt; ..........................................243     10.3 &lt;privileges&gt; ...............................................245     10.4 &lt;character set specification&gt; ..............................248     10.5 &lt;collate clause&gt; ...........................................251     10.6 &lt;constraint name definition&gt; and &lt;constraint attributes&gt; ...252     11 Schema definition and manipulation ...........................255     11.1 &lt;schema definition&gt; ........................................255     11.2 &lt;drop schema statement&gt; ....................................258     11.3 &lt;table definition&gt; .........................................260     11.4 &lt;column definition&gt; ........................................262     11.5 &lt;default clause&gt; ...........................................266     11.6 &lt;table constraint definition&gt; ..............................270     11.7 &lt;unique constraint definition&gt; .............................272     11.8 &lt;referential constraint definition&gt; ........................274     11.9 &lt;check constraint definition&gt; ..............................281     11.10&lt;alter table statement&gt; ....................................283     11.11&lt;add column definition&gt; ....................................284     11.12&lt;alter column definition&gt; ..................................286     11.13&lt;set column default clause&gt; ................................287     11.14&lt;drop column default clause&gt; ...............................288     11.15&lt;drop column definition&gt; ...................................289     11.16&lt;add table constraint definition&gt; ..........................291     11.17&lt;drop table constraint definition&gt; .........................292     11.18&lt;drop table statement&gt; .....................................294     11.19&lt;view definition&gt; ..........................................296     11.20&lt;drop view statement&gt; ......................................300     11.21&lt;domain definition&gt; ........................................301     11.22&lt;alter domain statement&gt; ...................................304     11.23&lt;set domain default clause&gt; ................................305                                                    Table of Contents  v</code></pre><p></p><pre><code>     11.24&lt;drop domain default clause&gt; ...............................306     11.25&lt;add domain constraint definition&gt; .........................307     11.26&lt;drop domain constraint definition&gt; ........................308     11.27&lt;drop domain statement&gt; ....................................309     11.28&lt;character set definition&gt; .................................311     11.29&lt;drop character set statement&gt; .............................313     11.30&lt;collation definition&gt; .....................................314     11.31&lt;drop collation statement&gt; .................................318     11.32&lt;translation definition&gt; ...................................320     11.33&lt;drop translation statement&gt; ...............................323     11.34&lt;assertion definition&gt; .....................................325     11.35&lt;drop assertion statement&gt; .................................328     11.36&lt;grant statement&gt; ..........................................329     11.37&lt;revoke statement&gt; .........................................333     12 Module .......................................................341     12.1 &lt;module&gt; ...................................................341     12.2 &lt;module name clause&gt; .......................................344     12.3 &lt;procedure&gt; ................................................346     12.4 Calls to a &lt;procedure&gt; .....................................352     12.5 &lt;SQL procedure statement&gt; ..................................368     13 Data manipulation ............................................371     13.1 &lt;declare cursor&gt; ...........................................371     13.2 &lt;open statement&gt; ...........................................375     13.3 &lt;fetch statement&gt; ..........................................377     13.4 &lt;close statement&gt; ..........................................381     13.5 &lt;select statement: single row&gt; .............................382     13.6 &lt;delete statement: positioned&gt; .............................384     13.7 &lt;delete statement: searched&gt; ...............................386     13.8 &lt;insert statement&gt; .........................................388     13.9 &lt;update statement: positioned&gt; .............................391     13.10&lt;update statement: searched&gt; ...............................394     13.11&lt;temporary table declaration&gt; ..............................397     14 Transaction management .......................................399     14.1 &lt;set transaction statement&gt; ................................399     14.2 &lt;set constraints mode statement&gt; ...........................401     14.3 &lt;commit statement&gt; .........................................403     14.4 &lt;rollback statement&gt; .......................................405     15 Connection management ........................................407     15.1 &lt;connect statement&gt; ........................................407     15.2 &lt;set connection statement&gt; .................................410     15.3 &lt;disconnect statement&gt; .....................................412     vi  Database Language SQL</code></pre><p></p><pre><code>     16 Session management ...........................................415     16.1 &lt;set catalog statement&gt; ....................................415     16.2 &lt;set schema statement&gt; .....................................417     16.3 &lt;set names statement&gt; ......................................419     16.4 &lt;set session authorization identifier statement&gt; ...........420     16.5 &lt;set local time zone statement&gt; ............................422     17 Dynamic SQL ..................................................425     17.1 Description of SQL item descriptor areas ...................425     17.2 &lt;allocate descriptor statement&gt; ............................431     17.3 &lt;deallocate descriptor statement&gt; ..........................433     17.4 &lt;get descriptor statement&gt; .................................434     17.5 &lt;set descriptor statement&gt; .................................438     17.6 &lt;prepare statement&gt; ........................................442     17.7 &lt;deallocate prepared statement&gt; ............................449     17.8 &lt;describe statement&gt; .......................................450     17.9 &lt;using clause&gt; .............................................451     17.10&lt;execute statement&gt; ........................................459     17.11&lt;execute immediate statement&gt; ..............................462     17.12&lt;dynamic declare cursor&gt; ...................................464     17.13&lt;allocate cursor statement&gt; ................................465     17.14&lt;dynamic open statement&gt; ...................................467     17.15&lt;dynamic fetch statement&gt; ..................................469     17.16&lt;dynamic close statement&gt; ..................................471     17.17&lt;dynamic delete statement: positioned&gt; .....................472     17.18&lt;dynamic update statement: positioned&gt; .....................474     17.19&lt;preparable dynamic delete statement: positioned&gt; ..........476     17.20&lt;preparable dynamic update statement: positioned&gt; ..........477     18 Diagnostics management .......................................479     18.1 &lt;get diagnostics statement&gt; ................................479     19 Embedded SQL .................................................489     19.1 &lt;embedded SQL host program&gt; ................................489     19.2 &lt;embedded exception declaration&gt; ...........................497     19.3 &lt;embedded SQL Ada program&gt; .................................500     19.4 &lt;embedded SQL C program&gt; ...................................504     19.5 &lt;embedded SQL COBOL program&gt; ...............................508     19.6 &lt;embedded SQL Fortran program&gt; .............................512     19.7 &lt;embedded SQL MUMPS program&gt; ...............................515     19.8 &lt;embedded SQL Pascal program&gt; ..............................517     19.9 &lt;embedded SQL PL/I program&gt; ................................520     20 Direct invocation of SQL .....................................525     20.1 &lt;direct SQL statement&gt; .....................................525     20.2 &lt;direct select statement: multiple rows&gt; ...................530                                                  Table of Contents  vii</code></pre><p></p><pre><code>     21 Information Schema and Definition Schema .....................533     21.1 Introduction ...............................................533     21.2 Information Schema .........................................535     21.2.INFORMATION_SCHEMA Schema ..................................535     21.2.INFORMATION_SCHEMA_CATALOG_NAME base table .................536     21.2.INFORMATION_SCHEMA_CATALOG_NAME_CARDINALITY assertion ......537     21.2.SCHEMATA view ..............................................538     21.2.DOMAINS view ...............................................539     21.2.DOMAIN_CONSTRAINTS view ....................................541     21.2.TABLES view ................................................542     21.2.VIEWS view .................................................543     21.2.COLUMNS view ...............................................544     21.2.TABLE_PRIVILEGES view ......................................546     21.2.COLUMN_PRIVILEGES view .....................................547     21.2.USAGE_PRIVILEGES view ......................................548     21.2.TABLE_CONSTRAINTS view .....................................549     21.2.REFERENTIAL_CONSTRAINTS view ...............................550     21.2.CHECK_CONSTRAINTS view .....................................551     21.2.KEY_COLUMN_USAGE view ......................................552     21.2.ASSERTIONS view ............................................553     21.2.CHARACTER_SETS view ........................................554     21.2.COLLATIONS view ............................................555     21.2.TRANSLATIONS view ..........................................556     21.2.VIEW_TABLE_USAGE view ......................................557     21.2.VIEW_COLUMN_USAGE view .....................................558     21.2.CONSTRAINT_TABLE_USAGE view ................................559     21.2.CONSTRAINT_COLUMN_USAGE view ...............................561     21.2.COLUMN_DOMAIN_USAGE view ...................................562     21.2.SQL_LANGUAGES view .........................................563     21.2.SQL_IDENTIFIER domain ......................................564     21.2.CHARACTER_DATA domain ......................................564     21.2.CARDINAL_NUMBER domain .....................................565     21.3 Definition Schema ..........................................566     21.3.Introduction ...............................................566     21.3.DEFINITION_SCHEMA Schema ...................................567     21.3.USERS base table ...........................................568     21.3.SCHEMATA base table ........................................569     21.3.DATA_TYPE_DESCRIPTOR base table ............................570     21.3.DOMAINS base table .........................................573     21.3.DOMAIN_CONSTRAINTS base table ..............................574     21.3.TABLES base table ..........................................576     21.3.VIEWS base table ...........................................578     21.3.COLUMNS base table .........................................580     21.3.VIEW_TABLE_USAGE base table ................................583     21.3.VIEW_COLUMN_USAGE base table ...............................584     viii  Database Language SQL</code></pre><p></p><pre><code>     21.3.TABLE_CONSTRAINTS base table ...............................585     21.3.KEY_COLUMN_USAGE base table ................................588     21.3.REFERENTIAL_CONSTRAINTS base table .........................590     21.3.CHECK_CONSTRAINTS base table ...............................593     21.3.CHECK_TABLE_USAGE base table ...............................595     21.3.CHECK_COLUMN_USAGE base table ..............................596     21.3.ASSERTIONS base table ......................................598     21.3.TABLE_PRIVILEGES base table ................................600     21.3.COLUMN_PRIVILEGES base table ...............................602     21.3.USAGE_PRIVILEGES base table ................................604     21.3.CHARACTER_SETS base table ..................................606     21.3.COLLATIONS base table ......................................608     21.3.TRANSLATIONS base table ....................................610     21.3.SQL_LANGUAGES base table ...................................612     21.4 Assertions on the base tables ..............................616     21.4.UNIQUE_CONSTRAINT_NAME assertion ...........................616     21.4.EQUAL_KEY_DEGREES assertion ................................617     21.4.KEY_DEGREE_GREATER_THAN_OR_EQUAL_TO_1 assertion ............618     22 Status codes .................................................619     22.1 SQLSTATE ...................................................619     22.2 SQLCODE ....................................................624     23 Conformance ..................................................625     23.1 Introduction ...............................................625     23.2 Claims of conformance ......................................625     23.3 Extensions and options .....................................626     23.4 Flagger requirements .......................................626     23.5 Processing methods .........................................627     Annex A   Leveling the SQL Language..............................629     A.1  Intermediate SQL Specifications ............................629     A.2  Entry SQL Specifications ...................................640     Annex B   Implementation-defined elements........................653     Annex C   Implementation-dependent elements......................667     Annex D   Deprecated features....................................675     Annex E   Incompatibilities with ISO/IEC 9075:1989...............677     Annex F   Maintenance and interpretation of SQL..................685     Index                                                   Table of Contents  ix</code></pre><p></p><pre><code>                                    TABLES     Table                                                          Page     1    Collating coercibility rules for monadic operators .........24     2    Collating coercibility rules for dyadic operators ..........24     3    Collating sequence usage for comparisons ...................25     4    Fields in datetime items ...................................30     5    Fields in year-month INTERVAL items ........................32     6    Fields in day-time INTERVAL items ..........................32     7    Valid values for fields in INTERVAL items ..................33     8    Valid operators involving datetimes and intervals ..........34     9    SQL-transaction isolation levels and the three phenomena ...69     10   Valid values for fields in datetime items ..................112     11   Valid values for fields in INTERVAL items ..................113     12   &lt;null predicate&gt; semantics .................................218     13   Truth table for the AND boolean ............................230     14   Truth table for the OR boolean .............................230     15   Truth table for the IS boolean .............................230     16   Standard programming languages .............................243     17   Data types of &lt;key word&gt;s used in SQL item descriptor areas          ............................................................427     18   Codes used for SQL data types in Dynamic SQL ...............429     19   Codes associated with datetime data types in Dynamic SQL ...429     20   Codes used for &lt;interval qualifier&gt;s in Dynamic SQL ........430     21   &lt;identifier&gt;s for use with &lt;get diagnostics statement&gt; .....481     22   SQL-statement character codes for use in the diagnostics          area........................................................482     23   SQLSTATE class and subclass values .........................619     24   SQLCODE values .............................................624     x  Database Language SQL</code></pre><p></p><pre><code>                                                 X3H2-92-154/DBL CBR-002     Foreword     ISO (the International Organization for Standardization) is a     worldwide federation of national standards bodies (ISO member     bodies). The work of preparing International Standards is nor-     mally carried out through ISO technical committees. Each member     body interested in a subject for which a technical committee has     been established has the right to be represented on that committee.     International organizations, governmental and non-governmental,     in liaison with ISO, also take part in the work. ISO collaborates     closely with the International Electrotechnical Commission (IEC) on     all matters of electrotechnical standardization.     Draft International Standards adopted by the technical committees     are circulated to the member bodies for approval before their ac-     ceptance as International Standards by the ISO Council. They are     approved in accordance with ISO procedures requiring at least 75%     approval by the member bodies voting.     International Standard ISO/IEC 9075:1992 was prepared by Joint     Technical Committee ISO/IEC JTC1, Information Processing Systems.     It cancels and replaces International Standard ISO/IEC 9075:1989,     Database Language-SQL, of which it constitutes a technical revi-     sion.     This International Standard contains seven informative annexes:     -  Annex A (informative): Leveling the SQL Language;     -  Annex B (informative): Implementation-defined elements;     -  Annex C (informative): Implementation-dependent elements;     -  Annex D (informative): Deprecated features;     -  Annex E (informative): Incompatibilities with ISO/IEC 9075:1989;        and     -  Annex F (informative): Maintenance and interpretation of SQL.                                                            Foreword  xi</code></pre><p></p><pre><code>                                                 X3H2-92-154/DBL CBR-002     Introduction     This International Standard was approved in 1992.     This International Standard was developed from ISO/IEC 9075:1989,     Information Systems, Database Language SQL with Integrity     Enhancements, and replaces that International Standard. It adds     significant new features and capabilities to the specifications.     It is generally compatible with ISO/IEC 9075:1989, in the sense     that, with very few exceptions, SQL language that conforms to     ISO/IEC 9075:1989 also conforms to this International Standard,     and will be treated in the same way by an implementation of this     International Standard as it would by an implementation of ISO/IEC     9075:1989. The known incompatibilities between ISO/IEC 9075:1989     and this International Standard are stated in informative Annex E,     &quot;Incompatibilities with ISO/IEC 9075:1989&quot;.     Technical changes between ISO/IEC 9075:1989 and this International     Standard include both improvements or enhancements to existing fea-     tures and the definition of new features. Significant improvements     in existing features include:     -  A better definition of direct invocation of SQL language;     -  Improved diagnostic capabilities, especially a new status param-        eter (SQLSTATE), a diagnostics area, and supporting statements.     Significant new features are:     1) Support for additional data types (DATE, TIME, TIMESTAMP,        INTERVAL, BIT string, variable-length character and bit strings,        and NATIONAL CHARACTER strings),     2) Support for character sets beyond that required to express SQL        language itself and support for additional collations,     3) Support for additional scalar operations, such as string opera-        tions for concatenate and substring, date and time operations,        and a form for conditional expressions,     4) Increased generality and orthogonality in the use of scalar-        valued and table-valued query expressions,     5) Additional set operators (for example, union join, natural join,        set difference, and set intersection),     6) Capability for domain definitions in the schema,     7) Support for Schema Manipulation capabilities (especially DROP        and ALTER statements),                                                      Introduction  xiii</code></pre><p></p><pre><code>     X3H2-92-154/DBL CBR-002     8) Support for bindings (modules and embedded syntax) in the Ada,        C, and MUMPS languages,     9) Additional privilege capabilities,     10)Additional referential integrity facilities, including ref-        erential actions, subqueries in CHECK constraints, separate        assertions, and user-controlled deferral of constraints,     11)Definition of an Information Schema,     12)Support for dynamic execution of SQL language,     13)Support for certain facilities required for Remote Database        Access (especially connection management statements and quali-        fied schema names),     14)Support for temporary tables,     15)Support for transaction consistency levels,     16)Support for data type conversions (CAST expressions among data        types),     17)Support for scrolled cursors, and     18)A requirement for a flagging capability to aid in portability of        application programs.     The organization of this International Standard is as follows:     1) Clause 1, &quot;Scope&quot;, specifies the scope of this International        Standard.     2) Clause 2, &quot;Normative references&quot;, identifies additional stan-        dards that, through reference in this International Standard,        constitute provisions of this International Standard.     3) Clause 3, &quot;Definitions, notations, and conventions&quot;, defines the        notations and conventions used in this International Standard.     4) Clause 4, &quot;Concepts&quot;, presents concepts used in the definition        of SQL.     5) Clause 5, &quot;Lexical elements&quot;, defines the lexical elements of        the language.     6) Clause 6, &quot;Scalar expressions&quot;, defines the elements of the        language that produce scalar values.     7) Clause 7, &quot;Query expressions&quot;, defines the elements of the lan-        guage that produce rows and tables of data.     8) Clause 8, &quot;Predicates&quot;, defines the predicates of the language.     xiv  Database Language SQL</code></pre><p></p><pre><code>                                                 X3H2-92-154/DBL CBR-002     9) Clause 9, &quot;Data assignment rules&quot;, specifies the rules for        assignments that retrieve data from or store data into the        database, and formation rules for set operations.     10)Clause 10, &quot;Additional common elements&quot;, defines additional lan-        guage elements that are used in various parts of the language.     11)Clause 11, &quot;Schema definition and manipulation&quot;, defines facili-        ties for creating and managing a schema.     12)Clause 12, &quot;Module&quot;, defines modules and procedures.     13)Clause 13, &quot;Data manipulation&quot;, defines the data manipulation        statements.     14)Clause 14, &quot;Transaction management&quot;, defines the SQL-transaction        management statements.     15)Clause 15, &quot;Connection management&quot; defines the SQL-connection        management statements.     16)Clause 16, &quot;Session management&quot;, defines the SQL-session manage-        ment statements.     17)Clause 17, &quot;Dynamic SQL&quot;, defines the facilities for executing        SQL-statements dynamically.     18)Clause 18, &quot;Diagnostics management&quot;, defines the diagnostics        management facilities.     19)Clause 19, &quot;Embedded SQL&quot;, defines syntax for embedding SQL in        certain standard programming languages.     20)Clause 20, &quot;Direct invocation of SQL&quot;, defines the direct invo-        cation of SQL language.     21)Clause 21, &quot;Information Schema and Definition Schema&quot;, defines        viewed tables that contain schema information.     22)Clause 22, &quot;Status codes&quot;, defines values that identify the        status of the execution of SQL-statements and the mechanisms by        which those values are returned.     23)Clause 23, &quot;Conformance&quot;, defines the criteria for conformance        to this International standard.     24)Annex A, &quot;Leveling the SQL Language&quot;, is an informative        Annex. It lists the leveling rules defining the Entry SQL and        Intermediate SQL subset levels of the SQL language.     25)Annex B, &quot;Implementation-defined elements&quot;, is an informa-        tive Annex. It lists those features for which the body of the        International Standard states that the syntax or meaning or ef-        fect on the database is partly or wholly implementation-defined,        and describes the defining information that an implementor shall        provide in each case.                                                        Introduction  xv</code></pre><p></p><pre><code>     X3H2-92-154/DBL CBR-002     26)Annex C, &quot;Implementation-dependent elements&quot;, is an informa-        tive Annex. It lists those features for which the body of the        International Standard states explicitly that the meaning or        effect on the database is implementation-dependent.     27)Annex D, &quot;Deprecated features&quot;, is an informative Annex. It        lists features that the responsible Technical Committee in-        tends will not appear in a future revised version of this        International Standard.     28)Annex E, &quot;Incompatibilities with ISO/IEC 9075:1989&quot;, is an in-        formative Annex. It lists the incompatibilities between this        version of this International Standard and ISO/IEC 9075:1989.     29)Annex F, &quot;Maintenance and interpretation of SQL&quot;, is an infor-        mative Annex. It identifies SQL interpretations and corrections        that have been processed by ISO/IEC JTC1/SC21 since adoption of        ISO/IEC 9075:1989.     In the text of this International Standard, Clauses begin a new     odd-numbered page, and in Clause 5, &quot;Lexical elements&quot;, through     Clause 22, &quot;Status codes&quot;, Subclauses begin a new page. Any result-     ing blank space is not significant.     xvi  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002     Information Technology - Database Language SQL     1  Scope     This International Standard defines the data structures and basic     operations on SQL-data. It provides functional capabilities for     creating, accessing, maintaining, controlling, and protecting SQL-     data.     Note: The framework for this International Standard is described by     the Reference Model of Data Management (ISO/IEC DIS 10032:1991).     This International Standard specifies the syntax and semantics of a     database language     -  for specifying and modifying the structure and the integrity        constraints of SQL-data,     -  for declaring and invoking operations on SQL-data and cursors,        and     -  for declaring database language procedures and embedding them        into a standard programming language.     It also specifies an Information Schema that describes the struc-     ture and the integrity constraints of SQL-data.     This International Standard     -  provides a vehicle for portability of data definitions and com-        pilation units between SQL-implementations,     -  provides a vehicle for interconnection of SQL-implementations,     -  specifies syntax for embedding SQL-statements in a compilation        unit that otherwise conforms to the standard for a particular        programming language. It defines how an equivalent compilation        unit may be derived that conforms to the particular programming        language standard. In that equivalent compilation unit, each        embedded SQL-statement has been replaced by statements that        invoke a database language procedure that contains the SQL-        statement, and     -  specifies syntax for direct invocation of SQL-statements.                                                               Scope   1</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     This International Standard does not define the method or time of     binding between any of:     -  database management system components,     -  SQL data definition declarations,     -  SQL procedures, or     -  compilation units, including those containing embedded SQL.     Implementations of this International Standard may exist in en-     vironments that also support application programming languages,     end-user query languages, report generator systems, data dictionary     systems, program library systems, and distributed communication     systems, as well as various tools for database design, data admin-     istration, and performance optimization.     2  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002     2  Normative references     The following standards contain provisions that, through reference     in this text, constitute provisions of this International Standard.     At the time of publication, the editions indicated were valid.     All standards are subject to revision, and parties to agreements     based on this International Standard are encouraged to investigate     the possibility of applying the most recent editions of the stan-     dards listed below. Members of IEC and ISO maintain registers of     currently valid International Standards.     -  ISO/IEC 646:1991, Information technology-ISO 7-bit coded charac-        ter set for information interchange.     -  ISO/IEC 1539:1991, Information technology-Programming languages-        Fortran.     -  ISO 1989:1985, Programming languages-COBOL.        (Endorsement of ANSI X3.23-1985).     -  ISO 2022:1986, Information technology-ISO 7-bit and 8-bit coded        character sets-code extension techniques.     -  ISO 6160:1979, Programming languages-PL/I        (Endorsement of ANSI X3.53-1976).     -  ISO 7185:1990, Information technology-Programming languages-        Pascal.     -  ISO 8601:1988, Data elements and interchange formats - Information        interchange-Representation of dates and times.     -  ISO 8652:1987, Programming languages-Ada.        (Endorsement of ANSI/MIL-STD-1815A-1983).     -  ISO/IEC 8824:1990, Information technology-Open Systems Interconnection-        Specification of Abstract Syntax Notation One (ASN.1).     -  ISO/IEC 9579-2:[1], Information technology - Open Systems        Interconnection - Remote Database Access, Part 2: SQL special-        ization.     -  ISO/IEC 9899:1990, Programming languages - C.     -  ISO/IEC 10206:1991, Information technology-Programming languages-        Extended Pascal.     -  ISO/IEC 10646:[1], Information technology-Multiple-octet coded        character set.     ____________________       [1] To be published                                                Normative references   3</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     -  ISO/IEC 11756:[1], Information technology-Programming languages-        MUMPS.     4  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002     3  Definitions, notations, and conventions     3.1  Definitions     For the purposes of this International Standard, the following     definitions apply.     3.1.1  Definitions taken from ISO/IEC 10646     This International Standard makes use of the following terms de-     fined in ISO/IEC 10646:        a) character        b) octet        c) variable-length coding        d) fixed-length coding     3.1.2  Definitions taken from ISO 8601     This International Standard makes use of the following terms de-     fined in ISO 8601:        a) Coordinated Universal Time (UTC)        b) date (&quot;date, calendar&quot; in ISO 8601)     3.1.3  Definitions provided in this International Standard     This International Standard defines the following terms:     a) assignable: The characteristic of a value or of a data type        that permits that value or the values of that data type to be        assigned to data instances of a specified data type.     b) cardinality (of a collection): The number of objects in that        collection. Those objects need not necessarily have distinct        values.     c) character repertoire; repertoire: A set of characters used for a        specific purpose or application. Each character repertoire has        an implied default collating sequence.     d) coercibility: An attribute of character string data items that        governs how a collating sequence for the items is determined.                             Definitions, notations, and conventions   5</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     3.1 Definitions     e) collation; collating sequence: A method of ordering two com-        parable character strings. Every character set has a default        collation.     f) comparable: The characteristic of two data objects that per-        mits the value of one object to be compared with the value of        the other object. Also said of data types: Two data types are        comparable if objects of those data types are comparable.     g) descriptor: A coded description of an SQL object. It includes        all of the information about the object that a conforming SQL-        implementation requires.     h) distinct: Two values are said to be not distinct if either:        both are the null value, or they compare equal according to        Subclause 8.2, &quot;&lt;comparison predicate&gt;&quot;. Otherwise they are        distinct. Two rows (or partial rows) are distinct if at least        one of their pairs of respective values is distinct. Otherwise        they are not distinct. The result of evaluating whether or not        two values or two rows are distinct is never unknown.     i) duplicate: Two or more values or rows are said to be duplicates        (of each other) if and only if they are not distinct.     j) dyadic operator: An operator having two operands: a left operand        and a right operand. An example of a dyadic arithmetic operator        in this International Standard is &quot;-&quot;, specifying the subtrac-        tion of the right operand from the left operand.     k) form-of-use: A convention (or encoding) for representing charac-        ters (in character strings). Some forms-of-use are fixed-length        codings and others are variable-length codings.     l) form-of-use conversion: A method of converting character strings        from one form-of-use to another form-of-use.     m) implementation-defined: Possibly differing between SQL-        implementations, but specified by the implementor for each        particular SQL-implementation.     n) implementation-dependent: Possibly differing between SQL-        implementations, but not specified by this International        Standard and not required to be specified by the implementor        for any particular SQL-implementations.     o) monadic operator: An operator having one operand. An example of        a monadic arithmetic operator in this International Standard is        &quot;-&quot;, specifying the negation of the operand.     p) multiset: An unordered collection of objects that are not neces-        sarily distinct. The collection may be empty.     q) n-adic operator: An operator having a variable number of        operands (informally: n operands). An example of an n-adic        operator in this International Standard is COALESCE.     6  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                         3.1 Definitions     r) null value (null): A special value, or mark, that is used to        indicate the absence of any data value.     s) persistent: Continuing to exist indefinitely, until destroyed        deliberately. Referential and cascaded actions are regarded        as deliberate. Actions incidental to the ending of an SQL-        transaction (see Subclause 4.28, &quot;SQL-transactions&quot;) or an SQL-        session (see Subclause 4.30, &quot;SQL-sessions&quot;) are not regarded as        deliberate.     t) redundant duplicates: All except one of any multiset of dupli-        cate values or rows.     u) repertoire: See character repertoire.     v) sequence: An ordered collection of objects that are not neces-        sarily distinct.     w) set: An unordered collection of distinct objects. The collection        may be empty.     x) SQL-implementation: A database management system that conforms        to this International Standard.     y) translation: A method of translating characters in one character        repertoire into characters of the same or a different character        repertoire.     3.2  Notation     The syntactic notation used in this International Standard is     an extended version of BNF (&quot;Backus Naur Form&quot; or &quot;Backus Normal     Form&quot;).     In BNF, each syntactic element of the language is defined by means     of a production rule. This defines the element in terms of a for-     mula consisting of the characters, character strings, and syntactic     elements that can be used to form an instance of it.     The version of BNF used in this International Standard makes use of     the following symbols:     SymbolMeaning     &lt; &gt;   Angle brackets delimit character strings that are the names           of syntactic elements, the non-terminal symbols of the SQL           language.     ::=   The definition operator. This is used in a production rule to           separate the element defined by the rule from its definition.           The element being defined appears to the left of the opera-           tor and the formula that defines the element appears to the           right.                             Definitions, notations, and conventions   7</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     3.2 Notation     [ ]   Square brackets indicate optional elements in a formula. The           portion of the formula within the brackets may be explicitly           specified or may be omitted.     &#123; &#125;   Braces group elements in a formula. The portion of the for-           mula within the braces shall be explicitly specified.     |     The alternative operator. The vertical bar indicates that           the portion of the formula following the bar is an alterna-           tive to the portion preceding the bar. If the vertical bar           appears at a position where it is not enclosed in braces           or square brackets, it specifies a complete alternative for           the element defined by the production rule. If the vertical           bar appears in a portion of a formula enclosed in braces or           square brackets, it specifies alternatives for the contents           of the innermost pair of such braces or brackets.      . . . The ellipsis indicates that the element to which it applies           in a formula may be repeated any number of times. If the el-           lipsis appears immediately after a closing brace &quot;&#125;&quot;, then it           applies to the portion of the formula enclosed between that           closing brace and the corresponding opening brace &quot;&#123;&quot;. If           an ellipsis appears after any other element, then it applies           only to that element.     !!    Introduces ordinary English text. This is used when the defi-           nition of a syntactic element is not expressed in BNF.     Spaces are used to separate syntactic elements. Multiple spaces and     line breaks are treated as a single space. Apart from those symbols     to which special functions were given above, other characters and     character strings in a formula stand for themselves. In addition,     if the symbols to the right of the definition operator in a produc-     tion consist entirely of BNF symbols, then those symbols stand for     themselves and do not take on their special meaning.     Pairs of braces and square brackets may be nested to any depth,     and the alternative operator may appear at any depth within such a     nest.     A character string that forms an instance of any syntactic element     may be generated from the BNF definition of that syntactic element     by application of the following steps:     1) Select any one option from those defined in the right hand side        of a production rule for the element, and replace the element        with this option.     2) Replace each ellipsis and the object to which it applies with        one or more instances of that object.     3) For every portion of the string enclosed in square brackets,        either delete the brackets and their contents or change the        brackets to braces.     8  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                            3.2 Notation     4) For every portion of the string enclosed in braces, apply steps        1 through 5 to the substring between the braces, then remove the        braces.     5) Apply steps 1 through 5 to any non-terminal syntactic element        (i.e., name enclosed in angle brackets) that remains in the        string.     The expansion or production is complete when no further non-     terminal symbols remain in the character string.     3.3  Conventions     3.3.1  Informative elements     In several places in the body of this International Standard, in-     formative notes appear. For example:     Note: This is an example of a note.     Those notes do not belong to the normative part of this International     Standard and conformance to material specified in those notes shall     not be claimed.     3.3.2  Specification of syntactic elements     Syntactic elements are specified in terms of:     -  Function: A short statement of the purpose of the element.     -  Format: A BNF definition of the syntax of the element.     -  Syntax Rules: A specification of the syntactic properties of the        element, or of additional syntactic constraints, not expressed        in BNF, that the element shall satisfy, or both.     -  Access Rules: A specification of rules governing the accessibil-        ity of schema objects that shall hold before the General Rules        may be successfully applied.     -  General Rules: A specification of the run-time effect of the        element. Where more than one General Rule is used to specify the        effect of an element, the required effect is that which would be        obtained by beginning with the first General Rule and applying        the Rules in numerical sequence unless a Rule is applied that        specifies or implies a change in sequence or termination of the        application of the Rules. Unless otherwise specified or implied        by a specific Rule that is applied, application of General Rules        terminates when the last in the sequence has been applied.     -  Leveling Rules: A specification of how the element shall be        supported for each of the levels of SQL.                             Definitions, notations, and conventions   9</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     3.3 Conventions     The scope of notational symbols is the Subclause in which those     symbols are defined. Within a Subclause, the symbols defined in     Syntax Rules, Access Rules, or General Rules can be referenced in     other rules provided that they are defined before being referenced.     3.3.3  Specification of the Information Schema     The objects of the Information Schema in this International     Standard are specified in terms of:     -  Function: A short statement of the purpose of the definition.     -  Definition: A definition, in SQL, of the object being defined.     -  Description: A specification of the run-time value of the ob-        ject, to the extent that this is not clear from the definition.     The definitions used to define the views in the Information Schema     are used only to specify clearly the contents of those viewed     tables. The actual objects on which these views are based are     implementation-dependent.     3.3.4  Use of terms     3.3.4.1  Exceptions     The phrase &quot;an exception condition is raised:&quot;, followed by the     name of a condition, is used in General Rules and elsewhere to     indicate that the execution of a statement is unsuccessful, ap-     plication of General Rules, other than those of Subclause 12.3,     &quot;&lt;procedure&gt;&quot;, and Subclause 20.1, &quot;&lt;direct SQL statement&gt;&quot;, may     be terminated, diagnostic information is to be made available,     and execution of the statement is to have no effect on SQL-data or     schemas. The effect on &lt;target specification&gt;s and SQL descriptor     areas of an SQL-statement that terminates with an exception condi-     tion, unless explicitly defined by this International Standard, is     implementation-dependent.     The phrase &quot;a completion condition is raised:&quot;, followed by the     name of a condition, is used in General Rules and elsewhere to     indicate that application of General Rules is not terminated and     diagnostic information is to be made available; unless an excep-     tion condition is also raised, the execution of the statement is     successful.     If more than one condition could have occurred as a result of a     statement, it is implementation-dependent whether diagnostic infor-     mation pertaining to more than one condition is made available.     10  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                         3.3 Conventions     3.3.4.2  Syntactic containment     In a Format, a syntactic element &lt;A&gt; is said to immediately contain     a syntactic element &lt;B&gt; if &lt;B&gt; appears on the right-hand side of     the BNF production rule for &lt;A&gt;. A syntactic element &lt;A&gt; is said     to contain or specify a syntactic element &lt;C&gt; if &lt;A&gt; immediately     contains &lt;C&gt; or if &lt;A&gt; immediately contains a syntactic element &lt;B&gt;     that contains &lt;C&gt;.     In SQL language, an instance A1 of &lt;A&gt; is said to immediately con-     tain an instance B1 of &lt;B&gt; if &lt;A&gt; immediately contains &lt;B&gt; and the     text of B1 is part of the text of A1. An instance A1 of &lt;A&gt; is said     to contain or specify an instance C1 of &lt;C&gt; if A1 immediately con-     tains C1 or if A1 immediately contains an instance B1 of &lt;B&gt; that     contains C1.     An instance A1 of &lt;A&gt; is said to contain an instance B1 of &lt;B&gt; with     an intervening &lt;C&gt; if A1 contains B1 and A1 contains an instance C1     of &lt;C&gt; that contains B1. An instance A1 of &lt;A&gt; is said to contain     an instance B1 of &lt;B&gt; without an intervening &lt;C&gt; if A1 contains B1     and A1 does not contain an instance C1 of &lt;C&gt; that contains B1.     An instance A1 of &lt;A&gt; simply contains an instance B1 of &lt;B&gt; if     A1 contains B1 without an intervening instance A2 of &lt;A&gt; or an     intervening instance B2 of &lt;B&gt;.     If &lt;A&gt; contains &lt;B&gt;, then &lt;B&gt; is said to be contained in &lt;A&gt; and     &lt;A&gt; is said to be a containing production symbol for &lt;B&gt;. If &lt;A&gt;     simply contains &lt;B&gt;, then &lt;B&gt; is said to be simply contained in     &lt;A&gt; and &lt;A&gt; is said to be a simply containing production symbol for     &lt;B&gt;.     Let A1 be an instance of &lt;A&gt; and let B1 be an instance of &lt;B&gt;. If     &lt;A&gt; contains &lt;B&gt;, then A1 is said to contain B1 and B1 is said to     be contained in A1. If &lt;A&gt; simply contains &lt;B&gt;, then A1 is said to     simply contain B1 and B1 is said to be simply contained in A1.     An instance A1 of &lt;A&gt; is the innermost &lt;A&gt; satisfying a condition     C if A1 satisfies C and A1 does not contain an instance A2 of &lt;A&gt;     that satisfies C. An instance A1 of &lt;A&gt; is the outermost &lt;A&gt; satis-     fying a condition C if A1 satisfies C and A1 is not contained in an     instance A2 of &lt;A&gt; that satisfies C.     If &lt;A&gt; contains a &lt;table name&gt; that identifies a view that is     defined by a &lt;view definition&gt; V, then &lt;A&gt; is said to generally     contain the &lt;query expression&gt; contained in V. If &lt;A&gt; contains &lt;B&gt;,     then &lt;A&gt; generally contains &lt;B&gt;. If &lt;A&gt; generally contains &lt;B&gt; and     &lt;B&gt; generally contains &lt;C&gt;, then &lt;A&gt; generally contains &lt;C&gt;.     An instance A1 of &lt;A&gt; directly contains an instance B1 of &lt;B&gt; if A1     contains B1 without an intervening &lt;set function specification&gt; or     &lt;subquery&gt;.                            Definitions, notations, and conventions   11</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     3.3 Conventions     3.3.4.3  Terms denoting rule requirements     In the Syntax Rules, the term shall defines conditions that are     required to be true of syntactically conforming SQL language. When     such conditions depend on the contents of the schema, then they     are required to be true just before the actions specified by the     General Rules are performed. The treatment of language that does     not conform to the SQL Formats and Syntax Rules is implementation-     dependent. If any condition required by Syntax Rules is not sat-     isfied when the evaluation of Access or General Rules is attempted     and the implementation is neither processing non-conforming SQL     language nor processing conforming SQL language in a non-conforming     manner, then an exception condition is raised: syntax error or     access rule violation (if this situation occurs during dynamic ex-     ecution of an SQL-statement, then the exception that is raised is     syntax error or access rule violation in dynamic SQL statement; if     the situation occurs during direct invocation of an SQL-statement,     then the exception that is raised is syntax error or access rule     violation in direct SQL statement).     In the Access Rules, the term shall defines conditions that are     required to be satisfied for the successful application of the     General Rules. If any such condition is not satisfied when the     General Rules are applied, then an exception condition is raised:     syntax error or access rule violation (if this situation occurs     during dynamic execution of an SQL-statement, then the exception     that is raised is syntax error or access rule violation in dynamic     SQL statement; if the situation occurs during direct invocation of     an SQL-statement, then the exception that is raised is syntax error     or access rule violation in direct SQL statement).     In the Leveling Rules, the term shall defines conditions that are     required to be true of SQL language for it to syntactically conform     to the specified level of conformance.     3.3.4.4  Rule evaluation order     A conforming implementation is not required to perform the exact     sequence of actions defined in the General Rules, but shall achieve     the same effect on SQL-data and schemas as that sequence. The term     effectively is used to emphasize actions whose effect might be     achieved in other ways by an implementation.     The Syntax Rules and Access Rules for contained syntactic elements     are effectively applied at the same time as the Syntax Rules and     Access Rules for the containing syntactic elements. The General     Rules for contained syntactic elements are effectively applied be-     fore the General Rules for the containing syntactic elements. Where     the precedence of operators is determined by the Formats of this     International Standard or by parentheses, those operators are ef-     fectively applied in the order specified by that precedence. Where     the precedence is not determined by the Formats or by parentheses,     effective evaluation of expressions is generally performed from     12  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                         3.3 Conventions     left to right. However, it is implementation-dependent whether ex-     pressions are actually evaluated left to right, particularly when     operands or operators might cause conditions to be raised or if     the results of the expressions can be determined without completely     evaluating all parts of the expression. In general, if some syn-     tactic element contains more than one other syntactic element, then     the General Rules for contained elements that appear earlier in the     production for the containing syntactic element are applied before     the General Rules for contained elements that appear later.     For example, in the production:        &lt;A&gt; ::= &lt;B&gt; &lt;C&gt;     the Syntax Rules and Access Rules for &lt;A&gt;, &lt;B&gt;, and &lt;C&gt; are ef-     fectively applied simultaneously. The General Rules for &lt;B&gt; are     applied before the General Rules for &lt;C&gt;, and the General Rules for     &lt;A&gt; are applied after the General Rules for both &lt;B&gt; and &lt;C&gt;.     If the result of an expression or search condition can be deter-     mined without completely evaluating all parts of the expression or     search condition, then the parts of the expression or search condi-     tion whose evaluation is not necessary are called the inessential     parts. If the Access Rules pertaining to inessential parts are not     satisfied, then the syntax error or access rule violation exception     condition is raised regardless of whether or not the inessential     parts are actually evaluated. If evaluation of the inessential     parts would cause an exception condition to be raised, then it is     implementation-dependent whether or not that exception condition is     raised.     3.3.4.5  Conditional rules     Conditional rules are specified with &quot;If&quot; or &quot;Case&quot; conventions.     Rules specified with &quot;Case&quot; conventions include a list of con-     ditional sub-rules using &quot;If&quot; conventions. The first such &quot;If&quot;     sub-rule whose condition is true is the effective sub-rule of     the &quot;Case&quot; rule. The last sub-rule of a &quot;Case&quot; rule may specify     &quot;Otherwise&quot;. Such a sub-rule is the effective sub-rule of the     &quot;Case&quot; rule if no preceding &quot;If&quot; sub-rule in the &quot;Case&quot; rule has     a true condition.     3.3.4.6  Syntactic substitution     In the Syntax and General Rules, the phrase &quot;X is implicit&quot; indi-     cates that the Syntax and General Rules are to be interpreted as if     the element X had actually been specified.     In the Syntax and General Rules, the phrase &quot;the following &lt;X&gt; is     implicit: Y&quot; indicates that the Syntax and General Rules are to be     interpreted as if a syntactic element &lt;X&gt; containing Y had actually     been specified.                            Definitions, notations, and conventions   13</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     3.3 Conventions     In the Syntax Rules and General Rules, the phrase &quot;former is equiv-     alent to latter&quot; indicates that the Syntax Rules and General Rules     are to be interpreted as if all instances of former in the element     had been instances of latter.     If a BNF nonterminal is referenced in a Subclause without speci-     fying how it is contained in a BNF production that the Subclause     defines, then     Case:     -  If the BNF nonterminal is itself defined in the Subclause, then        the reference shall be assumed to be the occurrence of that BNF        nonterminal on the left side of the defining production.     -  Otherwise, the reference shall be assumed to be to a BNF pro-        duction in which the particular BNF nonterminal is immediately        contained.     3.3.4.7  Other terms     Some Syntax Rules define terms, such as T1, to denote named or     unnamed tables. Such terms are used as table names or correlation     names. Where such a term is used as a correlation name, it does     not imply that any new correlation name is actually defined for     the denoted table, nor does it affect the scopes of any actual     correlation names.     An SQL-statement S1 is said to be executed as a direct result of     executing an SQL-statement if S1 is the SQL-statement contained     in a &lt;procedure&gt; that has been executed, or if S1 is the value of     an &lt;SQL statement variable&gt; referenced by an &lt;execute immediate     statement&gt; contained in a &lt;procedure&gt; that has been executed, or if     S1 was the value of the &lt;SQL statement variable&gt; that was associ-     ated with an &lt;SQL statement name&gt; by a &lt;prepare statement&gt; and that     same &lt;SQL statement name&gt; is referenced by an &lt;execute statement&gt;     contained in a &lt;procedure&gt; that has been executed.     3.3.5  Descriptors     A descriptor is a conceptual structured collection of data that     defines the attributes of an instance of an object of a specified     type. The concept of descriptor is used in specifying the seman-     tics of SQL. It is not necessary that any descriptor exist in any     particular form in any database or environment.     Some SQL objects cannot exist except in the context of other SQL     objects. For example, columns cannot exist except in tables. Those     objects are independently described by descriptors, and the de-     scriptors of enabling objects (e.g., tables) are said to include     the descriptors of enabled objects (e.g., columns or table con-     straints). Conversely, the descriptor of an enabled object is said     to be included in the descriptor of an enabling object.     14  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                         3.3 Conventions     In other cases, certain SQL objects cannot exist unless some other     SQL object exists, even though there is not an inclusion relation-     ship. For example, SQL does not permit an assertion to exist if the     tables referenced by the assertion do not exist. Therefore, an as-     sertion descriptor is dependent on or depends on zero or more table     descriptors (equivalently, an assertion is dependent on or depends     on zero or more tables). In general, a descriptor D1 can be said to     depend on, or be dependent on, some descriptor D2.     There are two ways of indicating dependency of one construct on     another. In many cases, the descriptor of the dependent construct     is said to &quot;include the name of&quot; the construct on which it is de-     pendent. In this case &quot;the name of&quot; is to be understood as meaning     &quot;sufficient information to identify the descriptor of&quot;; thus an     implementor might choose to use a pointer or a concatenation of     &lt;catalog name&gt;, &lt;schema name&gt;, etc. Alternatively, the descrip-     tor may be said to include text (e.g., &lt;query expression&gt;, &lt;search     condition&gt;). In such cases, whether the implementation includes ac-     tual text (with defaults and implications made explicit) or its own     style of parse tree is irrelevant; the validity of the descriptor     is clearly &quot;dependent on&quot; the existence of descriptors for objects     that are referred to in it.     The statement that a column &quot;is based on&quot; a domain, is equivalent     to a statement that a column &quot;is dependent on&quot; that domain.     An attempt to destroy a descriptor may fail if other descriptors     are dependent on it, depending on how the destruction is specified.     Such an attempt may also fail if the descriptor to be destroyed     is included in some other descriptor. Destruction of a descriptor     results in the destruction of all descriptors included in it, but     has no effect on descriptors on which it is dependent.     3.3.6  Index typography     In the Index to this International Standard, the following conven-     tions are used:     -  Index entries appearing in boldface indicate the page where the        word, phrase, or BNF nonterminal was defined;     -  Index entries appearing in italics indicate a page where the BNF        nonterminal was used in a Format; and     -  Index entries appearing in roman type indicate a page where        the word, phrase, or BNF nonterminal was used in a heading,        Function, Syntax Rule, Access Rule, General Rule, Leveling Rule,        Table, or other descriptive text.                            Definitions, notations, and conventions   15</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     3.4 Object identifier for Database Language SQL     3.4  Object identifier for Database Language SQL     Function     The object identifier for Database Language SQL identifies the     characteristics of an SQL-implementation to other entities in an     open systems environment.     Format     &lt;SQL object identifier&gt; ::=          &lt;SQL provenance&gt; &lt;SQL variant&gt;     &lt;SQL provenance&gt; ::= &lt;arc1&gt; &lt;arc2&gt; &lt;arc3&gt;     &lt;arc1&gt; ::= iso | 1 | iso &lt;left paren&gt; 1 &lt;right paren&gt;     &lt;arc2&gt; ::= standard | 0 | standard &lt;left paren&gt; 0 &lt;right paren&gt;     &lt;arc3&gt; ::= 9075     &lt;SQL variant&gt; ::= &lt;SQL edition&gt; &lt;SQL conformance&gt;     &lt;SQL edition&gt; ::= &lt;1987&gt; | &lt;1989&gt; | &lt;1992&gt;     &lt;1987&gt; ::= 0 | edition1987 &lt;left paren&gt; 0 &lt;right paren&gt;     &lt;1989&gt; ::= &lt;1989 base&gt; &lt;1989 package&gt;     &lt;1989 base&gt; ::= 1 | edition1989 &lt;left paren&gt; 1 &lt;right paren&gt;     &lt;1989 package&gt; ::= &lt;integrity no&gt; | &lt;integrity yes&gt;     &lt;integrity no&gt; ::= 0 | IntegrityNo &lt;left paren&gt; 0 &lt;right paren&gt;     &lt;integrity yes&gt; ::= 1 | IntegrityYes &lt;left paren&gt; 1 &lt;right paren&gt;     &lt;1992&gt; ::= 2 | edition1992 &lt;left paren&gt; 2 &lt;right paren&gt;     &lt;SQL conformance&gt; ::= &lt;low&gt; | &lt;intermediate&gt; | &lt;high&gt;     &lt;low&gt; ::= 0 | Low &lt;left paren&gt; 0 &lt;right paren&gt;     &lt;intermediate&gt; ::= 1 | Intermediate &lt;left paren&gt; 1 &lt;right paren&gt;     &lt;high&gt; ::= 2 | High &lt;left paren&gt; 2 &lt;right paren&gt;     16  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                         3.4 Object identifier for Database Language SQL     Syntax Rules     1) An &lt;SQL conformance&gt; of &lt;high&gt; shall not be specified unless the        &lt;SQL edition&gt; is specified as &lt;1992&gt;.     2) The value of &lt;SQL conformance&gt; identifies the level at which        conformance is claimed as follows:        a) If &lt;SQL edition&gt; specifies &lt;1992&gt;, then          Case:          i) &lt;low&gt;, then Entry SQL level.         ii) &lt;intermediate&gt;, then Intermediate SQL level.        iii) &lt;high&gt;, then Full SQL level.        b) Otherwise:          i) &lt;low&gt;, then level 1.         ii) &lt;intermediate&gt;, then level 2.     3) A specification of &lt;1989 package&gt; as &lt;integrity no&gt; implies        that the integrity enhancement feature is not implemented. A        specification of &lt;1989 package&gt; as &lt;integrity yes&gt; implies that        the integrity enhancement feature is implemented.                            Definitions, notations, and conventions   17</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     18  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002     4  Concepts     4.1  Data types     A data type is a set of representable values. The logical represen-     tation of a value is a &lt;literal&gt;. The physical representation of a     value is implementation-dependent.     A value is primitive in that it has no logical subdivision within     this International Standard. A value is a null value or a non-null     value.     A null value is an implementation-dependent special value that     is distinct from all non-null values of the associated data type.     There is effectively only one null value and that value is a member     of every SQL data type. There is no &lt;literal&gt; for a null value,     although the keyword NULL is used in some places to indicate that a     null value is desired.     SQL defines distinct data types named by the following &lt;key word&gt;s:     CHARACTER, CHARACTER VARYING, BIT, BIT VARYING, NUMERIC, DECIMAL,     INTEGER, SMALLINT, FLOAT, REAL, DOUBLE PRECISION, DATE, TIME,     TIMESTAMP, and INTERVAL.     Subclause 6.1, &quot;&lt;data type&gt;&quot;, describes the semantic properties of     each data type.     For reference purposes, the data types CHARACTER and CHARACTER     VARYING are collectively referred to as character string types.     The data types BIT and BIT VARYING are collectively referred to     as bit string types. Character string types and bit string types     are collectively referred to as string types and values of string     types are referred to as strings. The data types NUMERIC, DECIMAL,     INTEGER, and SMALLINT are collectively referred to as exact numeric     types. The data types FLOAT, REAL, and DOUBLE PRECISION are col-     lectively referred to as approximate numeric types. Exact numeric     types and approximate numeric types are collectively referred to as     numeric types. Values of numeric type are referred to as numbers.     The data types DATE, TIME, and TIMESTAMP are collectively referred     to as datetime types. Values of datetime types are referred to as     datetimes. The data type INTERVAL is referred to as an interval     type. Values of interval types are called intervals.     Each data type has an associated data type descriptor. The contents     of a data type descriptor are determined by the specific data type     that it describes. A data type descriptor includes an identifica-     tion of the data type and all information needed to characterize an     instance of that data type.                                                           Concepts   19</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.1 Data types     Each host language has its own data types, which are separate and     distinct from SQL data types, even though similar names may be     used to describe the data types. Mappings of SQL data types to data     types in host languages are described in Subclause 12.3, &quot;&lt;pro-     cedure&gt;&quot;, and Subclause 19.1, &quot;&lt;embedded SQL host program&gt;&quot;. Not     every SQL data type has a corresponding data type in every host     language.     4.2  Character strings     A character string data type is described by a character string     data type descriptor. A character string data type descriptor con-     tains:     -  the name of the specific character string data type (CHARACTER        or CHARACTER VARYING; NATIONAL CHARACTER and NATIONAL CHARACTER        VARYING are represented as CHARACTER and CHARACTER VARYING,        respectively);     -  the length or maximum length in characters of the character        string data type;     -  the catalog name, schema name, and character set name of the        character set of the character string data type; and     -  the catalog name, schema name, and collation name of the colla-        tion of the character string data type.     Character sets fall into three categories: those defined by na-     tional or international standards, those provided by implemen-     tations, and those defined by applications. All character sets,     however defined, always contain the &lt;space&gt; character. Character     sets defined by applications can be defined to &quot;reside&quot; in any     schema chosen by the application. Character sets defined by stan-     dards or by implementations reside in the Information Schema (named     INFORMATION_SCHEMA) in each catalog, as do collations defined by     standards and collations and form-of-use conversions defined by     implementations.     The &lt;implementation-defined character repertoire name&gt; SQL_TEXT     specifies the name of a character repertoire and implied form-of-     use that can represent every character that is in &lt;SQL language     character&gt; and all other characters that are in character sets     supported by the implementation.     4.2.1  Character strings and collating sequences     A character string is a sequence of characters chosen from the     same character repertoire. The character repertoire from which     the characters of a particular string are chosen may be specified     explicitly or implicitly. A character string has a length, which     is the number of characters in the sequence. The length is 0 or a     positive integer.     20  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                   4.2 Character strings     All character strings of a given character repertoire are mutu-     ally comparable, subject to the restrictions specified in Table 3,     &quot;Collating sequence usage for comparisons&quot;.     A collating sequence, also known as a collation, is a set of rules     determining comparison of character strings in a particular char-     acter repertoire. There is a default collating sequence for each     character repertoire, but additional collating sequences can be     defined for any character repertoire.     Note: A column may be defined as having a default collating se-     quence. This default collating sequence for the column may be     different from the default collating sequence for its character     repertoire, e.g., if the &lt;collate clause&gt; is specified in the     &lt;column reference&gt;. It will be clear from context when the term     &quot;default collating sequence&quot; is used whether it is meant for a     column or for a character repertoire.     Given a collating sequence, two character strings are identical if     and only if they are equal in accordance with the comparison rules     specified in Subclause 8.2, &quot;&lt;comparison predicate&gt;&quot;. The collat-     ing sequence used for a particular comparison is determined as in     Subclause 4.2.3, &quot;Rules determining collating sequence usage&quot;.     The &lt;key word&gt;s NATIONAL CHARACTER are used to specify a character     string data type with a particular implementation-defined character     repertoire. Special syntax (N&#39;string&#39;) is provided for representing     literals in that character repertoire.     A character set is described by a character set descriptor. A char-     acter set descriptor includes:     -  the name of the character set or character repertoire,     -  if the character set is a character repertoire, then the name of        the form-of-use,     -  an indication of what characters are in the character set, and     -  the name of the default collation of the character set.     For every character set, there is at least one collation. A colla-     tion is described by a collation descriptor. A collation descriptor     includes:     -  the name of the collation,     -  the name of the character set on which the collation operates,     -  whether the collation has the NO PAD or the PAD SPACE attribute,        and     -  an indication of how the collation is performed.                                                           Concepts   21</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.2 Character strings     4.2.2  Operations involving character strings     4.2.2.1  Operators that operate on character strings and return              character strings     &lt;concatenation operator&gt; is an operator, |, that returns the char-     acter string made by joining its character string operands in the     order given.     &lt;character substring function&gt; is a triadic function, SUBSTRING,     that returns a string extracted from a given string according     to a given numeric starting position and a given numeric length.     Truncation occurs when the implied starting and ending positions     are not both within the given string.     &lt;fold&gt; is a pair of functions for converting all the lower case     characters in a given string to upper case (UPPER) or all the upper     case ones to lower case (LOWER), useful only in connection with     strings that may contain &lt;simple Latin letter&gt;s.     &lt;form-of-use conversion&gt; is a function that invokes an installation-     supplied form-of-use conversion to return a character string S2     derived from a given character string S1. It is intended, though     not enforced by this International Standard, that S2 be exactly the     same sequence of characters as S1, but encoded according some dif-     ferent form-of-use. A typical use might be to convert a character     string from two-octet UCS to one-octet Latin1 or vice versa.     &lt;trim function&gt; is a function that returns its first string ar-     gument with leading and/or trailing pad characters removed. The     second argument indicates whether leading, or trailing, or both     leading and trailing pad characters should be removed. The third     argument specifies the pad character that is to be removed.     &lt;character translation&gt; is a function for changing each charac-     ter of a given string according to some many-to-one or one-to-one     mapping between two not necessarily distinct character sets. The     mapping, rather than being specified as part of the function, is     some external function identified by a &lt;translation name&gt;.     For any pair of character sets, there are zero or more translations     that may be invoked by a &lt;character translation&gt;. A translation     is described by a translation descriptor. A translation descriptor     includes:     -  the name of the translation,     -  the name of the character set from which it translates,     -  the name of the character set to which it translates, and     -  an indication of how the translation is performed.     22  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                   4.2 Character strings     4.2.2.2  Other operators involving character strings     &lt;length expression&gt; returns the length of a given character string,     as an integer, in characters, octets, or bits according to the     choice of function.     &lt;position expression&gt; determines the first position, if any, at     which one string, S1, occurs within another, S2. If S1 is of length     zero, then it occurs at position 1 for any value of S2. If S1 does     not occur in S2, then zero is returned.     &lt;like predicate&gt; uses the triadic operator LIKE (or the inverse,     NOT LIKE), operating on three character strings and returning     a Boolean. LIKE determines whether or not a character string     &quot;matches&quot; a given &quot;pattern&quot; (also a character string). The char-     acters &#39;%&#39; (percent) and &#39;_&#39; (underscore) have special meaning when     they occur in the pattern. The optional third argument is a charac-     ter string containing exactly one character, known as the &quot;escape     character&quot;, for use when a percent or underscore is required in the     pattern without its special meaning.     4.2.3  Rules determining collating sequence usage     The rules determining collating sequence usage for character     strings are based on the following:     -  Expressions where no columns are involved (e.g., literals, host        variables) are by default compared using the default collating        sequence for their character repertoire.        Note: The default collating sequence for a character repertoire        is defined in Subclause 10.4, &quot;&lt;character set specification&gt;&quot;,        and Subclause 11.28, &quot;&lt;character set definition&gt;&quot;.     -  When columns are involved (e.g., comparing two columns, or com-        paring a column to a literal), by default the default collating        sequence of the columns involved is used so long as the columns        have the same default collating sequence.     -  When columns are involved having different default collating        sequences, explicit specification of the collating sequence in        the expression is required via the &lt;collate clause&gt; when the        expression participates in a comparison.     -  Any explicit specification of collating sequence in an expres-        sion overrides any default collating sequence.     To formalize this, &lt;character value expression&gt;s effectively have     a coercibility attribute. This attribute has the values Coercible,     Implicit, No collating sequence, and Explicit. &lt;character value     expression&gt;s with the Coercible, Implicit, or Explicit attributes     have a collating sequence.                                                           Concepts   23</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.2 Character strings     A &lt;character value expression&gt; consisting of a column reference has     the Implicit attribute, with collating sequence as defined when the     column was created. A &lt;character value expression&gt; consisting of a     value other than a column (e.g., a host variable or a literal) has     the Coercible attribute, with the default collation for its char-     acter repertoire. A &lt;character value expression&gt; simply containing     a &lt;collate clause&gt; has the Explicit attribute, with the collating     sequence specified in the &lt;collate clause&gt;.     Note: When the coercibility attribute is Coercible, the collating     sequence is uniquely determined as specified in Subclause 8.2,     &quot;&lt;comparison predicate&gt;&quot;.     The tables below define how the collating sequence and the co-     ercibility attribute is determined for the result of any monadic     or dyadic operation. Table 1, &quot;Collating coercibility rules for     monadic operators&quot;, shows the collating sequence and coercibility     rules for monadic operators, and Table 2, &quot;Collating coercibil-     ity rules for dyadic operators&quot;, shows the collating sequence and     coercibility rules for dyadic operators. Table 3, &quot;Collating se-     quence usage for comparisons&quot;, shows how the collating sequence is     determined for a particular comparison.     _____Table_1-Collating_coercibility_rules_for_monadic_operators____            Operand Coercibility              Result Coercibility      _____and_Collating_Sequence_____  _____and_Collating_Sequence___    |                   Collating     |                   Collating    |    |_Coercibility______Sequence______|_Coercibility______Sequence_____|    |                                 |                                |    | Coercible       | default       | Coercible       | default      |    |                 |               |                 |              |    | Implicit        | X             | Implicit        | X            |    |                 |               |                 |              |    | Explicit        | X             | Explicit        | X            |    |                 |               |                 |              |    |_______No_collati|g_sequence_____|______No_collatin|_sequence_____|    |                 |               |                 |              |     _____Table_2-Collating_coercibility_rules_for_dyadic_operators_____                                                             Result                                                          Coercibility       Operand 1 Coercibility   Operand 2 Coercibility   and Collating      _and_Collating_Sequence  _and_Collating_Sequence   ___Sequence___    |              Collating |              Collating |             Col|ating    |_Coercibility_Sequence__|_Coercibility_Sequence__|__CoercibilitySe|uence    |                        |                        |                |    | Coercible  | default   | Coercible  | default   |  Coercible| def|ult    |            |           |            |           |           |    |    | Coercible  | default   | Implicit   | Y         |  Implicit | Y  |    |            |           |            |           |           |    |    | Coercible  | default   |  No collati|g sequence |   No colla|ing |                                                            sequence     24  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                   4.2 Character strings     _Table_2-Collating_coercibility_rules_for_dyadic_operators_(Cont.)_                                                             Result                                                          Coercibility       Operand 1 Coercibility   Operand 2 Coercibility   and Collating      _and_Collating_Sequence  _and_Collating_Sequence   ___Sequence___    |              Collating |              Collating |             Col|ating    |_Coercibility_Sequence__|_Coercibility_Sequence__|__CoercibilitySe|uence    |                        |                        |                |    | Coercible  | default   | Explicit   | Y         |  Explicit | Y  |    |            |           |            |           |           |    |    | Implicit   | X         | Coercible  | default   |  Implicit | X  |    |            |           |            |           |           |    |    | Implicit   | X         | Implicit   | X         |  Implicit | X  |    |            |           |            |           |           |    |    | Implicit   | X         | Implicit   | Y /= X    |   No colla|ing |                                                            sequence    | Implicit   | X         |  No collati|g sequence |   No collating |    |            |           |            |           |     sequence   |    |            |           |            |           |                |    | Implicit   | X         | Explicit     Y         |  Explicit   Y  |    |            |           |                        |                |    |  No collati|g sequence | Any,       | Any       |   No colla|ing |                               except                       sequence                               Explicit    |  No collating sequence | Explicit   | X         |  Explicit   X  |    |                        |            |           |                |    | Explicit     X         | Coercible  | default   |  Explicit | X  |    |                        |            |           |           |    |    | Explicit   | X         | Implicit   | Y         |  Explicit | X  |    |            |           |            |           |           |    |    | Explicit   | X         |  No collati|g sequence |  Explicit | X  |    |            |           |            |           |           |    |    | Explicit   | X         | Explicit     X         |  Explicit | X  |    |            |           |                        |           |    |    | Explicit   | X         | Explicit   | Y /= X    |  Not permi|ted:|     ____________________________________________________invalid_syntax_    |__________Ta|le_3-Collat|ng_sequence_|sage_for_co|parisons________|          Comparand 1          Comparand 2        Coercibility and     Coercibility and      _Collating_Sequence  _Collating_Sequence    |                    |                    |  Collating Sequence    |    |            Collatin|            Collatin|  Used For The          |    |_CoercibilitSequence|_CoercibilitSequence|__Comparison____________|    |                    |                    |                        |    | Coercible| default | Coercible| default |  default               |    |          |         |          |         |                        |    | Coercible| default | Implicit | Y       |  Y                     |    |          |         |          |         |                        |    | Coercible| default |     No co|lating   |  Not permitted: invalid|                                 sequence        syntax    | Coercible| default | Explicit   Y       |  Y                     |    |          |         |                    |                        |                                                           Concepts   25</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.2 Character strings     ______Table_3-Collating_sequence_usage_for_comparisons_(Cont.)_____          Comparand 1          Comparand 2        Coercibility and     Coercibility and      _Collating_Sequence  _Collating_Sequence    |                    |                    |  Collating Sequence    |    |            Collatin|            Collatin|  Used For The          |    |_CoercibilitSequence|_CoercibilitSequence|__Comparison____________|    |                    |                    |                        |    | Implicit | X       | Coercible| default |  X                     |    |          |         |          |         |                        |    | Implicit | X       | Implicit | X       |  X                     |    |          |         |          |         |                        |    | Implicit | X       | Implicit | Y /= X  |  Not permitted: invalid|                                                 syntax    | Implicit | X       |     No co|lating   |  Not permitted: invalid|    |          |         |       seq|ence     |  syntax                |    |          |         |          |         |                        |    | Implicit | X       | Explicit   Y       |  Y                     |    |          |         |                    |                        |    |     No co|lating   | Any      | Any     |  Not permitted: invalid|            sequence       except                syntax                           Explicit    |     No collating   | Explicit | X       |  X                     |    |       sequence     |          |         |                        |    |                    |          |         |                        |    | Explicit   X       | Coercible| default |  X                     |    |                    |          |         |                        |    | Explicit | X       | Implicit | Y       |  X                     |    |          |         |          |         |                        |    | Explicit | X       |     No co|lating   |  X                     |                                 sequence    | Explicit | X       | Explicit   X       |  X                     |    |          |         |                    |                        |    | Explicit | X       | Explicit | Y /= X  |  Not permitted: invalid|     ____________________________________________syntax_________________    |For n-adic|operation| (e.g., &lt;c|se expres|ion&gt;) with operands X1, |     X2, . . . , n , the collating sequence is effectively determined by     considering X1 and X2, then combining this result with X3, and so     on.     4.3  Bit strings     A bit string is a sequence of bits, each having the value of 0 or     1. A bit string has a length, which is the number of bits in the     string. The length is 0 or a positive integer.     A bit string data type is described by a bit string data type de-     scriptor. A bit string data type descriptor contains:     -  the name of the specific bit string data type (BIT or BIT        VARYING); and     26  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                         4.3 Bit strings     -  the length of the bit string data type (in bits).     4.3.1  Bit string comparison and assignment     All bit strings are mutually comparable. A bit string is identical     to another bit string if and only if it is equal to that bit string     in accordance with the comparison rules specified in Subclause 8.2,     &quot;&lt;comparison predicate&gt;&quot;.     Assignment of a bit string to a bit string variable is performed     from the most significant bit to the least significant bit in the     source string to the most significant bit in the target string, one     bit at a time.     4.3.2  Operations involving bit strings     4.3.2.1  Operators that operate on bit strings and return bit              strings     &lt;bit concatenation&gt; is an operator, |, that returns the bit string     made by concatenating the two bit string operands in the order     given.     &lt;bit substring function&gt; is a triadic function identical in syntax     and semantics to &lt;character substring function&gt; except that the     first argument and the returned value are both bit strings.     4.3.2.2  Other operators involving bit strings     &lt;length expression&gt; returns the length (as an integer number of     octets or bits according to the choice of function) of a given bit     string.     &lt;position expression&gt; determines the first position, if any, at     which one string, S1, occurs within another, S2. If S1 is of length     zero, then it occurs at position 1 for any value of S2. If S1 does     not occur in S2, then zero is returned.     4.4  Numbers     A number is either an exact numeric value or an approximate numeric     value. Any two numbers are mutually comparable to each other.     A numeric data type is described by a numeric data type descriptor.     A numeric data type descriptor contains:     -  the name of the specific numeric data type (NUMERIC, DECIMAL,        INTEGER, SMALLINT, FLOAT, REAL, or DOUBLE PRECISION);     -  the precision of the numeric data type;                                                           Concepts   27</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.4 Numbers     -  the scale of the numeric data type, if it is an exact numeric        data type; and     -  an indication of whether the precision (and scale) are expressed        in decimal or binary terms.     4.4.1  Characteristics of numbers     An exact numeric value has a precision and a scale. The precision     is a positive integer that determines the number of significant     digits in a particular radix (binary or decimal). The scale is a     non-negative integer. A scale of 0 indicates that the number is an     integer. For a scale of S, the exact numeric value is the integer     value of the significant digits multiplied by 10-S.     An approximate numeric value consists of a mantissa and an expo-     nent. The mantissa is a signed numeric value, and the exponent is     a signed integer that specifies the magnitude of the mantissa. An     approximate numeric value has a precision. The precision is a posi-     tive integer that specifies the number of significant binary digits     in the mantissa. The value of an approximate numeric value is the     mantissa multiplied by 10exponent.     Whenever an exact or approximate numeric value is assigned to a     data item or parameter representing an exact numeric value, an     approximation of its value that preserves leading significant dig-     its after rounding or truncating is represented in the data type     of the target. The value is converted to have the precision and     scale of the target. The choice of whether to truncate or round is     implementation-defined.     An approximation obtained by truncation of a numerical value N     for an &lt;exact numeric type&gt; T is a value V representable in T such     that N is not closer to zero than the numerical value of V and such     that the absolute value of the difference between N and the numer-     ical value of V is less than the absolute value of the difference     between two successive numerical values representable in T.     An approximation obtained by rounding of a numerical value N for     an &lt;exact numeric type&gt; T is a value V representable in T such     that the absolute value of the difference between N and the nu-     merical value of V is not greater than half the absolute value     of the difference between two successive numerical values repre-     sentable in T. If there are more than one such values V, then it is     implementation-defined which one is taken.     All numerical values between the smallest and the largest value,     inclusive, representable in a given exact numeric type have an     approximation obtained by rounding or truncation for that type; it     is implementation-defined which other numerical values have such     approximations.     28  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                             4.4 Numbers     An approximation obtained by truncation or rounding of a numerical     value N for an &lt;approximate numeric type&gt; T is a value V repre-     sentable in T such that there is no numerical value representable     in T and distinct from that of V that lies between the numerical     value of V and N, inclusive.     If there are more than one such values V then it is implementation-     defined which one is taken. It is implementation-defined which     numerical values have approximations obtained by rounding or trun-     cation for a given approximate numeric type.     Whenever an exact or approximate numeric value is assigned to a     data item or parameter representing an approximate numeric value,     an approximation of its value is represented in the data type of     the target. The value is converted to have the precision of the     target.     Operations on numbers are performed according to the normal rules     of arithmetic, within implementation-defined limits, except as     provided for in Subclause 6.12, &quot;&lt;numeric value expression&gt;&quot;.     4.4.2  Operations involving numbers     As well as the usual arithmetic operators, plus, minus, times,     divide, unary plus, and unary minus, there are the following func-     tions that return numbers:     -  &lt;position expression&gt; (see Subclause 4.2.2, &quot;Operations involv-        ing character strings&quot;, and Subclause 4.3.2, &quot;Operations involv-        ing bit strings&quot;) takes two strings as arguments and returns an        integer;     -  &lt;length expression&gt; (see Subclause 4.2.2, &quot;Operations involving        character strings&quot;, and Subclause 4.3.2, &quot;Operations involv-        ing bit strings&quot;) operates on a string argument and returns an        integer;     -  &lt;extract expression&gt; (see Subclause 4.5.3, &quot;Operations involving        datetimes and intervals&quot;) operates on a datetime or interval        argument and returns an integer.     4.5  Datetimes and intervals     A datetime data type is described by a datetime data type descrip-     tor. An interval data type is described by an interval data type     descriptor.     A datetime data type descriptor contains:     -  the name of the specific datetime data type (DATE, TIME,        TIMESTAMP, TIME WITH TIME ZONE, or TIMESTAMP WITH TIME ZONE);        and                                                           Concepts   29</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.5 Datetimes and intervals     -  the value of the &lt;time fractional seconds precision&gt;, if it is        a TIME, TIMESTAMP, TIME WITH TIME ZONE, or TIMESTAMP WITH TIME        ZONE type.     An interval data type descriptor contains:     -  the name of the interval data type (INTERVAL);     -  an indication of whether the interval data type is a year-month        interval or a day-time interval; and     -  the &lt;interval qualifier&gt; that describes the precision of the        interval data type.     Every datetime or interval data type has an implied length in po-     sitions. Let D denote a value in some datetime or interval data     type DT. The length in positions of DT is constant for all D. The     length in positions is the number of characters from the character     set SQL_TEXT that it would take to represent any value in a given     datetime or interval data type.     4.5.1  Datetimes     Table 4, &quot;Fields in datetime items&quot;, specifies the fields that can     make up a date time value; a datetime value is made up of a subset     of those fields. Not all of the fields shown are required to be in     the subset, but every field that appears in the table between the     first included primary field and the last included primary field     shall also be included. If either timezone field is in the subset,     then both of them shall be included.     __________________Table_4-Fields_in_datetime_items_________________     _Keyword____________Meaning________________________________________    |__________________|___Primary_datetime_fields_____________________|    |                  |                                               |    | YEAR               Year                                          |    |                                                                  |    | MONTH            | Month within year                             |    |                  |                                               |    | DAY              | Day within month                              |    |                  |                                               |    | HOUR             | Hour within day                               |    |                  |                                               |    | MINUTE           | Minute within hour                            |    |                  |                                               |    | SECOND           | Second and possibly fraction of a second      |     ____________________within_minute__________________________________    |__________________|___Timezone_datetime_fields____________________|    |                  |                                               |    | TIMEZONE_HOUR    | Hour value of time zone displacement          |    |                                                                  |    |_TIMEZONE_MINUTE__|_Minute_value_of_time_zone_displacement________|    |                  |                                               |     30  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                             4.5 Datetimes and intervals     There is an ordering of the significance of &lt;datetime field&gt;s. This     is, from most significant to least significant: YEAR, MONTH, DAY,     HOUR, MINUTE, and SECOND.     The &lt;datetime field&gt;s other than SECOND contain non-negative in-     teger values, constrained by the natural rules for dates using the     Gregorian calendar. SECOND, however, can be defined to have a &lt;time     fractional seconds precision&gt; that indicates the number of decimal     digits maintained following the decimal point in the seconds value,     a non-negative exact numeric value.     There are three classes of datetime data types defined within this     International Standard:     -  DATE - contains the &lt;datetime field&gt;s YEAR, MONTH, and DAY;     -  TIME - contains the &lt;datetime field&gt;s HOUR, MINUTE, and SECOND;        and     -  TIMESTAMP - contains the &lt;datetime field&gt;s YEAR, MONTH, DAY,        HOUR, MINUTE, and SECOND.     Items of type datetime are mutually comparable only if they have     the same &lt;datetime field&gt;s.     Datetimes only have absolute meaning in the context of additional     information. Time zones are political divisions of the earth&#39;s     surface that allow the convention that time is measured the same     at all locations within the time zone, regardless of the precise     value of &quot;sun time&quot; at specific locations. Political entities often     change the &quot;local time&quot; within a time zone for certain periods of     the year, e.g., in the summer. However, different political enti-     ties within the same time zone are not necessarily synchronized in     their local time changes. When a datetime is specified (in SQL-data     or elsewhere) it has an implied or explicit time zone specifier as-     sociated with it. Unless that time zone specifier, and its meaning,     is known, the meaning of the datetime value is ambiguous.     Therefore, datetime data types that contain time fields (TIME and     TIMESTAMP) are maintained in Universal Coordinated Time (UTC), with     an explicit or implied time zone part.     The time zone part is an interval specifying the difference between     UTC and the actual date and time in the time zone represented by     the time or timestamp data item. The time zone displacement is     defined as          INTERVAL HOUR TO MINUTE     A TIME or TIMESTAMP that does not specify WITH TIME ZONE has an im-     plicit time zone equal to the local time zone for the SQL-session.     The value of time represented in the data changes along with the     local time zone for the SQL-session. However, the meaning of the     time does not change because it is effectively maintained in UTC.                                                           Concepts   31</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.5 Datetimes and intervals     Note: On occasion, UTC is adjusted by the omission of a second or     the insertion of a &quot;leap second&quot; in order to maintain synchro-     nization with sidereal time. This implies that sometimes, but very     rarely, a particular minute will contain exactly 59, 61, or 62     seconds.     4.5.2  Intervals     There are two classes of intervals. One class, called year-month     intervals, has an express or implied datetime precision that in-     cludes no fields other than YEAR and MONTH, though not both are     required. The other class, called day-time intervals, has an ex-     press or implied interval precision that can include any fields     other than YEAR or MONTH.     Table 5, &quot;Fields in year-month INTERVAL items&quot;, specifies the     fields that make up a year-month interval. A year-month interval     is made up of a contiguous subset of those fields.     ____________Table_5-Fields_in_year-month_INTERVAL_items____________     _Keyword______Meaning______________________________________________    | YEAR       | Years                                               |    |            |                                                     |    |_MONTH______|_Months______________________________________________|    |            |                                                     |     Table 6, &quot;Fields in day-time INTERVAL items&quot;, specifies the fields     that make up a day-time interval. A day-time interval is made up of     a contiguous subset of those fields.     _____________Table_6-Fields_in_day-time_INTERVAL_items_____________     _Keyword______Meaning______________________________________________    | DAY        | Days                                                |    |            |                                                     |    | HOUR       | Hours                                               |    |            |                                                     |    | MINUTE     | Minutes                                             |    |            |                                                     |    |_SECOND_____|_Seconds_and_possibly_fractions_of_a_second__________|    |            |                                                     |     The actual subset of fields that comprise an item of either type of     interval is defined by an &lt;interval qualifier&gt; and this subset is     known as the precision of the item.     Within an item of type interval, the first field is constrained     only by the &lt;interval leading field precision&gt; of the associated     &lt;interval qualifier&gt;. Table 7, &quot;Valid values for fields in INTERVAL     items&quot;, specifies the constraints on subsequence field values.     32  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                             4.5 Datetimes and intervals     _________Table_7-Valid_values_for_fields_in_INTERVAL_items_________     _Keyword______Valid_values_of_INTERVAL_fields______________________    | YEAR       | Unconstrained except by &lt;interval leading field     |                   precision    | MONTH      | Months (within years) (0-11)                        |    |            |                                                     |    | DAY        | Unconstrained except by &lt;interval leading field     |                   precision    | HOUR       | Hours (within days) (0-23)                          |    |            |                                                     |    | MINUTE     | Minutes (within hours) (0-59)                       |    |            |                                                     |    |_SECOND_____|_Seconds_(within_minutes)_(0-59.999...)______________|    |            |                                                     |     Values in interval fields other than SECOND are integers. SECOND,     however, can be defined to have an &lt;interval fractional seconds     precision&gt; that indicates the number of decimal digits maintained     following the decimal point in the seconds value.     Fields comprising an item of type interval are also constrained by     the definition of the Gregorian calendar.     Year-month intervals are mutually comparable only with other year-     month intervals. If two year-month intervals have different inter-     val precisions, they are, for the purpose of any operations between     them, effectively converted to the same precision by appending new     &lt;datetime field&gt;s to either the most significant end or the least     significant end of one or both year-month intervals. New least sig-     nificant &lt;datetime field&gt;s are assigned a value of 0. When it is     necessary to add new most significant date time fields, the as-     sociated value is effectively converted to the new precision in     a manner obeying the natural rules for dates and times associated     with the Gregorian calendar.     Day-time intervals are mutually comparable only with other day-     time intervals. If two day-time intervals have different interval     precisions, they are, for the purpose of any operations between     them, effectively converted to the same precision by appending new     &lt;datetime field&gt;s to either the most significant end or the least     significant end of one or both day-time intervals. New least sig-     nificant &lt;datetime field&gt;s are assigned a value of 0. When it is     necessary to add new most significant datetime fields, the asso-     ciated value is effectively converted to the new precision in a     manner obeying the natural rules for dates and times associated     with the Gregorian calendar.                                                           Concepts   33</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.5 Datetimes and intervals     4.5.3  Operations involving datetimes and intervals     Table 8, &quot;Valid operators involving datetimes and intervals&quot;, spec-     ifies the results of arithmetic expressions involving datetime and     interval operands.     _____Table_8-Valid_operators_involving_datetimes_and_intervals_____      Operand            Operand     _1__________Operator_2_________Result_Type_________________________    | Datetime | -     | Datetime | Interval                           |    |          |       |          |                                    |    | Datetime | + or -| Interval | Datetime                           |    |          |       |          |                                    |    | Interval | +     | Datetime | Datetime                           |    |          |       |          |                                    |    | Interval | + or -| Interval | Interval                           |    |          |       |          |                                    |    | Interval | * or /| Numeric  | Interval                           |    |          |       |          |                                    |    |_Numeric__|_*_____|_Interval_|_Interval___________________________|    |          |       |          |                                    |     Arithmetic operations involving items of type datetime or inter-     val obey the natural rules associated with dates and times and     yield valid datetime or interval results according to the Gregorian     calendar.     Operations involving items of type datetime require that the date-     time items be mutually comparable. Operations involving items of     type interval require that the interval items be mutually compara-     ble.     Operations involving a datetime and an interval preserve the time     zone of the datetime operand. If the datetime operand does not     include a time zone part, then the local time zone is effectively     used.     &lt;overlaps predicate&gt; uses the operator OVERLAPS to determine     whether or not two chronological periods overlap in time. A chrono-     logical period is specified either as a pair of datetimes (starting     and ending) or as a starting datetime and an interval.     &lt;extract expression&gt; operates on a datetime or interval and returns     an exact numeric value representing the value of one component of     the datetime or interval.     4.6  Type conversions and mixing of data types     Values of the data types NUMERIC, DECIMAL, INTEGER, SMALLINT,     FLOAT, REAL, and DOUBLE PRECISION are numbers and are all mutually     comparable and mutually assignable. If an assignment would result     in a loss of the most significant digits, an exception condition     is raised. If least significant digits are lost, implementation-     defined rounding or truncating occurs with no exception condition     being raised. The rules for arithmetic are generally governed by     Subclause 6.12, &quot;&lt;numeric value expression&gt;&quot;.     34  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                           4.6 Type conversions and mixing of data types     Values corresponding to the data types CHARACTER and CHARACTER     VARYING are mutually assignable if and only if they are taken from     the same character repertoire. If they are from different character     repertoires, then the value of the source of the assignment shall     be translated to the character repertoire of the target before an     assignment is possible. If a store assignment would result in the     loss of non-&lt;space&gt; characters due to truncation, then an exception     condition is raised. The values are mutually comparable only if     they are mutually assignable and can be coerced to have the same     collation. The comparison of two character strings depends on the     collating sequence used for the comparison (see Table 3, &quot;Collating     sequence usage for comparisons&quot;). When values of unequal length     are compared, if the collating sequence for the comparison has     the NO PAD attribute and the shorter value is equal to a prefix of     the longer value, then the shorter value is considered less than     the longer value. If the collating sequence for the comparison has     the PAD SPACE attribute, for the purposes of the comparison, the     shorter value is effectively extended to the length of the longer     by concatenation of &lt;space&gt;s on the right.     Values corresponding to the data types BIT and BIT VARYING are al-     ways mutually comparable and are mutually assignable. If a store     assignment would result in the loss of bits due to truncation, then     an exception condition is raised. When values of unequal length are     to be compared, if the shorter is a prefix of the longer, then the     shorter is less than the longer; otherwise, the longer is effec-     tively truncated to the length of the shorter for the purposes of     comparison. When values of equal length are to be compared, then a     bit-by-bit comparison is made. A 0-bit less than a 1-bit.     Values of type datetime are mutually assignable only if the source     and target of the assignment have the same datetime fields.     Values of type interval are mutually assignable only if the source     and target of the assignment are both year-month intervals or if     they are both day-time intervals.     Implicit type conversion can occur in expressions, fetch opera-     tions, single row select operations, inserts, deletes, and updates.     Explicit type conversions can be specified by the use of the CAST     operator.     4.7  Domains     A domain is a set of permissible values. A domain is defined in     a schema and is identified by a &lt;domain name&gt;. The purpose of a     domain is to constrain the set of valid values that can be stored     in SQL-data by various operations.     A domain definition specifies a data type. It may also specify a     &lt;domain constraint&gt; that further restricts the valid values of the     domain and a &lt;default clause&gt; that specifies the value to be used     in the absence of an explicitly specified value or column default.                                                           Concepts   35</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.7 Domains     A domain is described by a domain descriptor. A domain descriptor     includes:     -  the name of the domain;     -  the data type descriptor of the data type of the domain;     -  the &lt;collation name&gt; from the &lt;collate clause&gt;, if any, of the        domain;     -  the value of &lt;default option&gt;, if any, of the domain; and     -  the domain constraint descriptors of the domain constraints, if        any, of the domain.     4.8  Columns     A column is a multiset of values that may vary over time. All val-     ues of the same column are of the same data type or domain and are     values in the same table. A value of a column is the smallest unit     of data that can be selected from a table and the smallest unit of     data that can be updated.     Every column has a &lt;column name&gt;.     Every column has a nullability characteristic of known not nullable     or possibly nullable, defined as follows:     A column has a nullability characteristic that indicates whether     any attempt to store a null value into that column will inevitably     raise an exception, or whether any attempt to retrieve a value     from that column can ever result in a null value. A column C with     &lt;column name&gt; CN of a base table T has a nullability characteristic     that is known not nullable if and only if either:     -  there exists at least one constraint that is not deferrable and        that simply contains a &lt;search condition&gt; that contains CN IS        NOT NULL or NOT CN IS NULL or RVE IS NOT NULL, where RVE is a        &lt;row value constructor&gt; that contains a &lt;row value constructor        expression&gt; that is simply CN without an intervening &lt;search        condition&gt; that specifies OR and without an intervening &lt;boolean        factor&gt; that specifies NOT.     -  C is based on a domain that has a domain constraint that is        not deferrable and that simply contains a &lt;search condition&gt;        that contains VALUE IS NOT NULL or NOT VALUE IS NULL without an        intervening &lt;search condition&gt; that specifies OR and without an        intervening &lt;boolean factor&gt; that specifies NOT.     -  CN is contained in a non-deferrable &lt;unique constraint defi-        nition&gt; whose &lt;unique specification&gt; specifies PRIMARY KEY.     Otherwise, a column C is possibly nullable.     36  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                             4.8 Columns     A column is described by a column descriptor. A column descriptor     includes:     -  the name of the column;     -  whether the name of the column is an implementation-dependent        name;     -  if the column is based on a domain, then the name of that do-        main; otherwise, the data type descriptor of the data type of        the column;     -  the &lt;collation name&gt; from the &lt;collate clause&gt;, if any, of the        column;     -  the value of &lt;default option&gt;, if any, of the column;     -  the nullability characteristic of the column; and     -  the ordinal position of the column within the table that con-        tains the column.     4.9  Tables     A table is a multiset of rows. A row is a nonempty sequence of     values. Every row of the same table has the same cardinality and     contains a value of every column of that table. The i-th value in     every row of a table is a value of the i-th column of that table.     The row is the smallest unit of data that can be inserted into a     table and deleted from a table.     The degree of a table is the number of columns of that table. At     any time, the degree of a table is the same as the cardinality of     each of its rows and the cardinality of a table is the same as the     cardinality of each of its columns. A table whose cardinality is 0     is said to be empty.     A table is either a base table, a viewed table, or a derived table.     A base table is either a persistent base table, a global tempo-     rary table, a created local temporary table, or a declared local     temporary table.     A persistent base table is a named table defined by a &lt;table defi-     nition&gt; that does not specify TEMPORARY.     A derived table is a table derived directly or indirectly from one     or more other tables by the evaluation of a &lt;query expression&gt;.     The values of a derived table are derived from the values of the     underlying tables when the &lt;query expression&gt; is evaluated.     A viewed table is a named derived table defined by a &lt;view defini-     tion&gt;. A viewed table is sometimes called a view.                                                           Concepts   37</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.9 Tables     The terms simply underlying table, underlying table, leaf underly-     ing table, generally underlying table, and leaf generally underly-     ing table define a relationship between a derived table or cursor     and other tables.     The simply underlying tables of derived tables and cursors are     defined in Subclause 7.9, &quot;&lt;query specification&gt;&quot;, Subclause 7.10,     &quot;&lt;query expression&gt;&quot;, and Subclause 13.1, &quot;&lt;declare cursor&gt;&quot;. A     viewed table has no simply underlying tables.     The underlying tables of a derived table or cursor are the simply     underlying tables of the derived table or cursor and the underlying     tables of the simply underlying tables of the derived table or     cursor.     The leaf underlying tables of a derived table or cursor are the     underlying tables of the derived table or cursor that do not them-     selves have any underlying tables.     The generally underlying tables of a derived table or cursor are     the underlying tables of the derived table or cursor and, for those     underlying tables of the derived table or cursor that are viewed     tables, the &lt;query expression&gt; of each viewed table and the gen-     erally underlying tables of the &lt;query expression&gt; of each viewed     table.     The leaf generally underlying tables of a derived table or cursor     are the generally underlying tables of the derived table or cursor     that do not themselves have any generally underlying tables.     All base tables are updatable. Derived tables are either updatable     or read-only. The operations of insert, update, and delete are     permitted for updatable tables, subject to constraining Access     Rules. The operations of insert, update, and delete are not allowed     for read-only tables.     A grouped table is a set of groups derived during the evaluation     of a &lt;group by clause&gt; or a &lt;having clause&gt;. A group is a multiset     of rows in which all values of the grouping column or columns are     equal if a &lt;group by clause&gt; is specified, or the group is the     entire table if no &lt;group by clause&gt; is specified. A grouped table     may be considered as a collection of tables. Set functions may     operate on the individual tables within the grouped table.     A global temporary table is a named table defined by a &lt;table defi-     nition&gt; that specifies GLOBAL TEMPORARY. A created local temporary     table is a named table defined by a &lt;table definition&gt; that speci-     fies LOCAL TEMPORARY. Global and created local temporary tables are     effectively materialized only when referenced in an SQL-session.     Every &lt;module&gt; in every SQL-session that references a created local     temporary table causes a distinct instance of that created local     temporary table to be materialized. That is, the contents of a     global temporary table or a created local temporary table cannot     be shared between SQL-sessions. In addition, the contents of a cre-     ated local temporary table cannot be shared between &lt;module&gt;s of a     single SQL-session. The definition of a global temporary table or a     created local temporary table appears in a schema. In SQL language,     38  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                              4.9 Tables     the name and the scope of the name of a global temporary table or     a created local temporary table are indistinguishable from those     of a persistent base table. However, because global temporary ta-     ble contents are distinct within SQL-sessions, and created local     temporary tables are distinct within &lt;module&gt;s within SQL-sessions,     the effective &lt;schema name&gt; of the schema in which the global tem-     porary table or the created local temporary table is instantiated     is an implementation-dependent &lt;schema name&gt; that may be thought     of as having been effectively derived from the &lt;schema name&gt; of     the schema in which the global temporary table or created local     temporary table is defined and the implementation-dependent SQL-     session identifier associated with the SQL-session. In addition,     the effective &lt;schema name&gt; of the schema in which the created     local temporary table is instantiated may be thought of as being     further qualified by a unique implementation-dependent name associ-     ated with the &lt;module&gt; in which the created local temporary table     is referenced.     A declared local temporary table is a named table defined by a     &lt;temporary table declaration&gt; that is effectively materialized     the first time any &lt;procedure&gt; in the &lt;module&gt; that contains the     &lt;temporary table declaration&gt; is executed. A declared local tem-     porary table is accessible only by &lt;procedure&gt;s in the &lt;module&gt;     that contains the &lt;temporary table declaration&gt;. The effective     &lt;schema name&gt; of the &lt;qualified name&gt; of the declared local tem-     porary table may be thought of as the implementation-dependent     SQL-session identifier associated with the SQL-session and a unique     implementation-dependent name associated with the &lt;module&gt; that     contains the &lt;temporary table declaration&gt;. All references to a     declared local temporary table are prefixed by &quot;MODULE.&quot;.     The materialization of a temporary table does not persist beyond     the end of the SQL-session in which the table was materialized.     Temporary tables are effectively empty at the start of an SQL-     session.     A table is described by a table descriptor. A table descriptor is     either a base table descriptor, a view descriptor, or a derived     table descriptor (for a derived table that is not a view).     Every table descriptor includes:     -  the degree of the table (the number of column descriptors); and     -  the column descriptor of each column in the table.     A base table descriptor describes a base table. In addition to     the components of every table descriptor, a base table descriptor     includes:     -  the name of the base table;     -  an indication of whether the table is a persistent base table,        a global temporary table, a created local temporary table, or a        declared local temporary table; and                                                           Concepts   39</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.9 Tables     -  the descriptor of each table constraint specified for the table.     A derived table descriptor describes a derived table. In addi-     tion to the components of every table descriptor, a derived table     descriptor includes:     -  if the table is named, then the name of the table;     -  the &lt;query expression&gt; that defines how the table is to be de-        rived; and     -  an indication of whether the derived table is updatable or read-        only (this is derived from the &lt;query expression&gt;);     A view descriptor describes a view. In addition to the components     of a derived table descriptor, a view descriptor includes:     -  an indication of whether the view has the CHECK OPTION; if so,        whether it is to be applied as CASCADED or LOCAL.     4.10  Integrity constraints     Integrity constraints, generally referred to simply as constraints,     define the valid states of SQL-data by constraining the values     in the base tables. A constraint is either a table constraint,     a domain constraint or an assertion. A constraint is described     by a constraint descriptor. A constraint descriptor is either a     table constraint descriptor, a domain constraint descriptor or an     assertion descriptor. Every constraint descriptor includes:     -  the name of the constraint;     -  an indication of whether or not the constraint is deferrable;     -  an indication of whether the initial constraint mode is deferred        or immediate;     A &lt;query expression&gt; or &lt;query specification&gt; is possibly non-     deterministic if an implementation might, at two different times     where the state of the SQL-data is the same, produce results that     differ by more than the order of the rows due to General Rules that     specify implementation-dependent behavior.     No integrity constraint shall be defined using a &lt;query specifica-     tion&gt; or a &lt;query expression&gt; that is possibly non-deterministic.     40  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                              4.10 Integrity constraints     4.10.1  Checking of constraints     Every constraint is either deferrable or non-deferrable. Within     a transaction, every constraint has a constraint mode; if a con-     straint is non-deferrable, then its constraint mode is always im-     mediate, otherwise it is either or immediate or deferred. Every     constraint has an initial constraint mode that specifies the     constraint mode for that constraint at the start of each SQL-     transaction and immediately after definition of that constraint.     If a constraint is deferrable, then its constraint mode may be     changed (from immediate to deferred, or from deferred to immediate)     by execution of a &lt;set constraints mode statement&gt;.     The checking of a constraint depends on its constraint mode within     the current SQL-transaction. If the constraint mode is immedi-     ate, then the constraint is effectively checked at the end of     each SQL-statement. If the constraint mode is deferred, then the     constraint is effectively checked when the constraint mode is     changed to immediate either explicitly by execution of a &lt;set con-     straints mode statement&gt;, or implicitly at the end of the current     SQL-transaction.     When a constraint is checked other than at the end of an SQL-     transaction, if it is not satisfied, then an exception condition     is raised and the SQL-statement that caused the constraint to be     checked has no effect other than entering the exception information     into the diagnostics area. When a &lt;commit statement&gt; is executed,     all constraints are effectively checked and, if any constraint     is not satisfied, then an exception condition is raised and the     transaction is terminated by an implicit &lt;rollback statement&gt;.     4.10.2  Table constraints     A table constraint is either a unique constraint, a referential     constraint or a table check constraint. A table constraint is de-     scribed by a table constraint descriptor which is either a unique     constraint descriptor, a referential constraint descriptor or a     table check constraint descriptor.     A unique constraint is described by a unique constraint descriptor.     In addition to the components of every table constraint descriptor,     a unique constraint descriptor includes:     -  an indication of whether it was defined with PRIMARY KEY or        UNIQUE, and     -  the names and positions of the unique columns specified in the        &lt;unique column list&gt;;     A referential constraint is described by a referential constraint     descriptor. In addition to the components of every table constraint     descriptor, a referential constraint descriptor includes:                                                           Concepts   41</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.10 Integrity constraints     -  the names of the referencing columns specified in the &lt;referenc-        ing columns&gt;,     -  the names of the referenced columns and referenced table speci-        fied in the &lt;referenced table and columns&gt;, and     -  the value of the &lt;match type&gt;, if specified, and the &lt;referen-        tial triggered actions&gt;, if specified.     Note: If MATCH FULL or MATCH PARTIAL is specified for a referential     constraint and if the referencing table has only one column spec-     ified in &lt;referential constraint definition&gt; for that referential     constraint, or if the referencing table has more than one specified     column for that &lt;referential constraint definition&gt;, but none of     those columns is nullable, then the effect is the same as if no     &lt;match option&gt; were specified.     A table check constraint is described by a table check constraint     descriptor. In addition to the components of every table constraint     descriptor, a table check constraint descriptor includes:     -  the &lt;search condition&gt;.     A unique constraint is satisfied if and only if no two rows in     a table have the same non-null values in the unique columns. In     addition, if the unique constraint was defined with PRIMARY KEY,     then it requires that none of the values in the specified column or     columns be the null value.     In the case that a table constraint is a referential constraint,     the table is referred to as the referencing table. The referenced     columns of a referential constraint shall be the unique columns of     some unique constraint of the referenced table.     A referential constraint is satisfied if one of the following con-     ditions is true, depending on the &lt;match option&gt; specified in the     &lt;referential constraint definition&gt;:     -  If no &lt;match type&gt; was specified then, for each row R1 of the        referencing table, either at least one of the values of the        referencing columns in R1 shall be a null value, or the value of        each referencing column in R1 shall be equal to the value of the        corresponding referenced column in some row of the referenced        table.     -  If MATCH FULL was specified then, for each row R1 of the refer-        encing table, either the value of every referencing column in R1        shall be a null value, or the value of every referencing column        in R1 shall not be null and there shall be some row R2 of the        referenced table such that the value of each referencing col-        umn in R1 is equal to the value of the corresponding referenced        column in R2.     42  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                              4.10 Integrity constraints     -  If MATCH PARTIAL was specified then, for each row R1 of the        referencing table, there shall be some row R2 of the refer-        enced table such that the value of each referencing column in        R1 is either null or is equal to the value of the corresponding        referenced column in R2.     The referencing table may be the same table as the referenced ta-     ble.     A table check constraint is satisfied if and only if the specified     &lt;search condition&gt; is not false for any row of a table.     4.10.3  Domain constraints     A domain constraint is a constraint that is specified for a domain.     It is applied to all columns that are based on that domain, and to     all values cast to that domain.     A domain constraint is described by a domain constraint descriptor.     In addition to the components of every constraint descriptor a     domain constraint descriptor includes:     -  the &lt;search condition&gt;.     A domain constraint is satisfied by SQL-data if and only if, for     any table T that has a column named C based on that domain, the     specified &lt;search condition&gt;, with each occurrence of VALUE re-     placed by C, is not false for any row of T.     A domain constraint is satisfied by the result of a &lt;cast specifi-     cation&gt; if and only if the specified &lt;search condition&gt;, with each     occurrence of VALUE replaced by that result, is not false.     4.10.4  Assertions     An assertion is a named constraint that may relate to the content     of individual rows of a table, to the entire contents of a table,     or to a state required to exist among a number of tables.     An assertion is described by an assertion descriptor. In addi-     tion to the components of every constraint descriptor an assertion     descriptor includes:     -  the &lt;search condition&gt;.     An assertion is satisfied if and only if the specified &lt;search     condition&gt; is not false.                                                           Concepts   43</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.11 SQL-schemas     4.11  SQL-schemas     An SQL-schema is a persistent descriptor that includes:     -  the &lt;schema name&gt; of the SQL-schema;     -  the &lt;authorization identifier&gt; of the owner of the SQL-schema;     -  The &lt;character set name&gt; of the default character set for the        SQL-schema; and     -  the descriptor of every component of the SQL-schema.     In this International Standard, the term &quot;schema&quot; is used only     in the sense of SQL-schema. Each component descriptor is either     a domain descriptor, a base table descriptor, a view descriptor,     an assertion descriptor, a privilege descriptor, a character set     descriptor, a collation descriptor, or a translation descriptor.     The persistent objects described by the descriptors are said to be     owned by or to have been created by the &lt;authorization identifier&gt;     of the schema.     A schema is created initially using a &lt;schema definition&gt; and may     be subsequently modified incrementally over time by the execution     of &lt;SQL schema statement&gt;s. &lt;schema name&gt;s are unique within a     catalog.     A &lt;schema name&gt; is explicitly or implicitly qualified by a &lt;catalog     name&gt; that identifies a catalog.     Base tables and views are identified by &lt;table name&gt;s. A &lt;table     name&gt; consists of a &lt;schema name&gt; and an &lt;identifier&gt;. For a per-     sistent table, the &lt;schema name&gt; identifies the schema in which     the base table or view identified by the &lt;table name&gt; was de-     fined. Base tables and views defined in different schemas can     have &lt;identifier&gt;s that are equal according to the General Rules     of Subclause 8.2, &quot;&lt;comparison predicate&gt;&quot;.     If a reference to a &lt;table name&gt; does not explicitly contain a     &lt;schema name&gt;, then a specific &lt;schema name&gt; is implied. The par-     ticular &lt;schema name&gt; associated with such a &lt;table name&gt; depends     on the context in which the &lt;table name&gt; appears and is governed     by the rules for &lt;qualified name&gt;. The default schema for &lt;prepara-     ble statement&gt;s that are dynamically prepared in the current SQL-     session through the execution of &lt;prepare statement&gt;s and &lt;execute     immediate statement&gt;s is initially implementation-defined but may     be changed by the use of &lt;set schema statement&gt;s.     44  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                           4.12 Catalogs     4.12  Catalogs     Catalogs are named collections of schemas in an SQL-environment. An     SQL-environment contains zero or more catalogs. A catalog con-     tains one or more schemas, but always contains a schema named     INFORMATION_SCHEMA that contains the views and domains of the     Information Schema. The method of creation and destruction of     catalogs is implementation-defined. The set of catalogs that     can be referenced in any SQL-statement, during any particular     SQL-transaction, or during the course of an SQL-session is also     implementation-defined. The default catalog for a &lt;module&gt; whose     &lt;module authorization clause&gt; does not specify an explicit &lt;cata-     log name&gt; to qualify the &lt;schema name&gt; is implementation-defined.     The default catalog for &lt;preparable statement&gt;s that are dynami-     cally prepared in the current SQL-session through the execution     of &lt;prepare statement&gt;s and &lt;execute immediate statement&gt;s is ini-     tially implementation-defined but may be changed by the use of &lt;set     catalog statement&gt;s.     4.13  Clusters of catalogs     A cluster is an implementation-defined collection of catalogs.     Exactly one cluster is associated with an SQL-session and it     defines the totality of the SQL-data that is available to that     SQL-session.     An instance of a cluster is described by an instance of a defi-     nition schema. Given some SQL-data object, such as a view, a con-     straint, a domain, or a base table, the definition of that object,     and of all the objects that it directly or indirectly references,     are in the same cluster of catalogs. For example, no &lt;referential     constraint definition&gt; and no &lt;joined table&gt; can &quot;cross&quot; a cluster     boundary.     Whether or not any catalog can occur simultaneously in more than     one cluster is implementation-defined.     Within a cluster, no two catalogs have the same name.     4.14  SQL-data     SQL-data is any data described by schemas that is under the control     of an SQL-implementation in an SQL-environment.                                                           Concepts   45</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.15 SQL-environment     4.15  SQL-environment     An SQL-environment comprises the following:     -  an SQL-implementation capable of processing some Level (Entry        SQL, Intermediate SQL, or Full SQL) of this International        Standard and at least one binding style; see Clause 23,        &quot;Conformance&quot; for further information about binding styles;     -  zero or more catalogs;     -  zero or more &lt;authorization identifier&gt;s;     -  zero or more &lt;module&gt;s; and     -  the SQL-data described by the schemas in the catalogs.     An SQL-environment may have other implementation-defined contents.     The rules determining which &lt;module&gt;s are considered to be within     an SQL-environment are implementation-defined.     4.16  Modules     A &lt;module&gt; is an object specified in the module language. A &lt;mod-     ule&gt; is either a persistent &lt;module&gt; or an SQL-session &lt;module&gt;.     The mechanisms by which &lt;module&gt;s are created or destroyed are     implementation-defined. A &lt;module&gt; consists of an optional &lt;module     name&gt;, a &lt;language clause&gt;, a &lt;module authorization clause&gt; with     either or both of a &lt;module authorization identifier&gt; and a &lt;schema     name&gt;, an optional &lt;module character set specification&gt; that iden-     tifies the character repertoire used for expressing the names of     schema objects used in the &lt;module&gt;, zero or more &lt;temporary table     declaration&gt;s, zero or more cursors specified by &lt;declare cur-     sor&gt;s, and one or more &lt;procedure&gt;s. All &lt;identifier&gt;s contained     in the &lt;module&gt; are expressed in either &lt;SQL language character&gt;     or the character repertoire indicated by &lt;module character set     specification&gt; unless they are specified with &quot;&lt;introducer&gt;&quot;.     A compilation unit is a segment of executable code, possibly con-     sisting of one or more subprograms. A &lt;module&gt; is associated with     a compilation unit during its execution. A single &lt;module&gt; may be     associated with multiple compilation units and multiple &lt;module&gt;s     may be associated with a single compilation unit. The manner in     which this association is specified, including the possible re-     quirement for execution of some implementation-defined statement,     is implementation-defined. Whether a compilation unit may invoke or     transfer control to other compilation units, written in the same or     a different programming language, is implementation-defined.     46  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                         4.17 Procedures     4.17  Procedures     A &lt;procedure&gt; consists of a &lt;procedure name&gt;, a sequence of &lt;pa-     rameter declaration&gt;s, and a single &lt;SQL procedure statement&gt;.     A &lt;procedure&gt; in a &lt;module&gt; is invoked by a compilation unit as-     sociated with the &lt;module&gt; by means of a host language &quot;call&quot;     statement that specifies the &lt;procedure name&gt; of the &lt;procedure&gt;     and supplies a sequence of parameter values corresponding in number     and in &lt;data type&gt; to the &lt;parameter declaration&gt;s of the &lt;proce-     dure&gt;. A call of a &lt;procedure&gt; causes the &lt;SQL procedure statement&gt;     that it contains to be executed.     4.18  Parameters     A parameter is declared in a &lt;procedure&gt; by a &lt;parameter decla-     ration&gt;. The &lt;parameter declaration&gt; specifies the &lt;data type&gt;     of its value. A parameter either assumes or supplies the value of     the corresponding argument in the call of that &lt;procedure&gt;. These     &lt;data type&gt;s map to host language types and are not nullable except     through the use of additional indicator variables.     4.18.1  Status parameters     The SQLSTATE and SQLCODE parameters are status parameters. They     are set to status codes that indicate either that a call of the     &lt;procedure&gt; completed successfully or that an exception condition     was raised during execution of the &lt;procedure&gt;.     Note: The SQLSTATE parameter is the preferred status parameter. The     SQLCODE parameter is a deprecated feature that is supported for     compatibility with earlier versions of this International Standard.     See Annex D, &quot;Deprecated features&quot;.     A &lt;procedure&gt; shall specify either the SQLSTATE parameter or the     SQLCODE parameter or both. The SQLSTATE parameter is a charac-     ter string parameter for which exception values are defined in     Clause 22, &quot;Status codes&quot;. The SQLCODE parameter is an integer pa-     rameter for which the negative exception values are implementation-     defined.     If a condition is raised that causes a statement to have no effect     other than that associated with raising the condition (that is,     not a completion condition), then the condition is said to be an     exception condition or exception. If a condition is raised that     permits a statement to have an effect other than that associated     with raising the condition (corresponding to an SQLSTATE class     value of successful completion, warning, or no data), then the     condition is said to be a completion condition.                                                           Concepts   47</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.18 Parameters     4.18.2  Data parameters     A data parameter is a parameter that is used to either assume or     supply the value of data exchanged between a host program and an     SQL-implementation.     4.18.3  Indicator parameters     An indicator parameter is an integer parameter that is specified     immediately following another parameter. Its primary use is to     indicate whether the value that the other parameter assumes or     supplies is a null value. An indicator parameter cannot immediately     follow another indicator parameter.     The other use for indicator parameters is to indicate whether     string data truncation occurred during a transfer between a host     program and an SQL-implementation in parameters or host variables.     If a non-null string value is transferred and the length of the     target data item is sufficient to accept the entire source data     item, then the indicator parameter or variable is set to 0 to in-     dicate that truncation did not occur. However, if the length of     the target data item is insufficient, then the indicator parame-     ter or variable is set to the length of the source data item (in     characters or bits, as appropriate) to indicate that truncation     occurred and to indicate the original length in characters or bits,     as appropriate, of the source.     4.19  Diagnostics area     The diagnostics area is a place where completion and exception con-     dition information is stored when an SQL-statement is executed.     There is one diagnostics area associated with an SQL-agent, regard-     less of the number of &lt;module&gt;s that the SQL-agent includes or the     number of connections in use.     At the beginning of the execution of any statement that is not an     &lt;SQL diagnostics statement&gt;, the diagnostics area is emptied. An     implementation shall place information about a completion condition     or an exception condition reported by SQLCODE or SQLSTATE into this     area. If other conditions are raised, an implementation may place     information about them into this area.     &lt;procedure&gt;s containing &lt;SQL diagnostics statement&gt;s return a code     indicating completion or exception conditions for that statement     via SQLCODE or SQLSTATE, but do not modify the diagnostics area.     An SQL-agent may choose the size of the diagnostics area with the     &lt;set transaction statement&gt;; if an SQL-agent does not specify the     size of the diagnostics area, then the size of the diagnostics     area is implementation-dependent, but shall always be able to hold     information about at least one condition. An implementation may     place information into this area about fewer conditions than are     specified. The ordering of the information about conditions placed     48  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                   4.19 Diagnostics area     into the diagnostics area is implementation-dependent, except that     the first condition in the diagnostics area always corresponds to     the condition specified by the SQLSTATE or SQLCODE value.     4.20  Standard programming languages     This International Standard specifies the actions of &lt;procedure&gt;s     in &lt;module&gt;s when those &lt;procedure&gt;s are called by programs that     conform to certain specified programming language standards. The     term &quot;standard PLN program&quot;, where PLN is the name of a program-     ming language, refers to a program that conforms to the standard     for that programming language as specified in Clause 2, &quot;Normative     references&quot;. This International Standard also specifies a mechanism     whereby SQL language may be embedded in programs that otherwise     conform to any of the same specified programming language stan-     dards.     Note: In this International Standard, for the purposes of inter-     facing with programming languages, the data types DATE, TIME,     TIMESTAMP, and INTERVAL shall be converted to or from character     strings in those programming languages by means of a &lt;cast speci-     fication&gt;. It is anticipated that future evolution of programming     language standards will support data types corresponding to these     four SQL data types; this standard will then be amended to reflect     the availability of those corresponding data types. The data type     CHARACTER is also mapped to character strings in the programming     languages. However, because the facilities available in the pro-     gramming languages do not provide the same capabilities as those     available in SQL, there shall be agreement between the host pro-     gram and SQL regarding the specific format of the character data     being exchanged. Specific syntax for this agreement is provided     in this International standard. For standard programming lan-     guages, C, COBOL, Fortran, and Pascal, bit strings are mapped to     character variables in the host language in a manner described in     Subclause 19.1, &quot;&lt;embedded SQL host program&gt;&quot;. For standard pro-     gramming languages Ada and PL/I, bit string variables are directly     supported.     4.21  Cursors     A cursor is specified by a &lt;declare cursor&gt;, &lt;dynamic declare cur-     sor&gt;, or &lt;allocate cursor statement&gt;.     For every &lt;declare cursor&gt; or &lt;dynamic declare cursor&gt; in a &lt;mod-     ule&gt;, a cursor is effectively created when an SQL-transaction (see     Subclause 4.28, &quot;SQL-transactions&quot;) referencing the &lt;module&gt; is     initiated, and destroyed when that SQL-transaction is terminated. A     cursor is also effectively created when an &lt;allocate cursor state-     ment&gt; is executed within a SQL-transaction and destroyed when that     SQL-transaction is terminated. In addition, an extended dynamic                                                           Concepts   49</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.21 Cursors     cursor is destroyed when a &lt;deallocate prepared statement&gt; is exe-     cuted that deallocates the prepared statement on which the extended     dynamic cursor is based.     A cursor is in either the open state or the closed state. The ini-     tial state of a cursor is the closed state. A cursor is placed in     the open state by an &lt;open statement&gt; or &lt;dynamic open statement&gt;     and returned to the closed state by a &lt;close statement&gt; or &lt;dynamic     close statement&gt;, a &lt;commit statement&gt;, or a &lt;rollback statement&gt;.     A cursor in the open state identifies a table, an ordering of the     rows of that table, and a position relative to that ordering. If     the &lt;declare cursor&gt; does not include an &lt;order by clause&gt;, or     includes an &lt;order by clause&gt; that does not specify the order of     the rows completely, then the rows of the table have an order that     is defined only to the extent that the &lt;order by clause&gt; specifies     an order and is otherwise implementation-dependent.     When the ordering of a cursor is not defined by an &lt;order by     clause&gt;, the relative positions of two rows is implementation-     dependent. When the ordering of a cursor is partially determined     by an &lt;order by clause&gt;, then the relative positions of two rows     are determined only by the &lt;order by clause&gt;; if the two rows have     equal values for the purpose of evaluating the &lt;order by clause&gt;,     then their relative positions are implementation-dependent.     A cursor is either read-only or updatable. If the table identified     by a cursor is not updatable or if INSENSITIVE is specified for     the cursor, then the cursor is read-only; otherwise, the cursor is     updatable. The operations of update and delete are not allowed for     read-only cursors.     The position of a cursor in the open state is either before a cer-     tain row, on a certain row, or after the last row. If a cursor is     on a row, then that row is the current row of the cursor. A cursor     may be before the first row or after the last row of a table even     though the table is empty. When a cursor is initially opened, the     position of the cursor is before the first row.     A &lt;fetch statement&gt; or &lt;dynamic fetch statement&gt; positions an open     cursor on a specified row of the cursor&#39;s ordering and retrieves     the values of the columns of that row. An &lt;update statement: po-     sitioned&gt; or &lt;dynamic update statement: positioned&gt; updates the     current row of the cursor. A &lt;delete statement: positioned&gt; or &lt;dy-     namic delete statement: positioned&gt; deletes the current row of the     cursor.     If an error occurs during the execution of an SQL-statement that     identifies an open cursor, then, except where otherwise explic-     itly defined, the effect, if any, on the position or state of that     cursor is implementation-dependent.     If a cursor is open, and the current SQL-transaction makes a change     to SQL-data other than through that cursor, and the &lt;declare cur-     sor&gt; for that cursor specified INSENSITIVE, then the effect of     that change will not be visible through that cursor before it is     closed. Otherwise, whether the effect of such a change will be     50  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                            4.21 Cursors     visible through that cursor before it is closed is implementation-     dependent.     4.22  SQL-statements     4.22.1  Classes of SQL-statements     An SQL-statement is a string of characters that conforms to the     format and syntax rules specified in this international standard.     Most SQL-statements can be prepared for execution and executed in     one of a number of ways. These are:     -  in a &lt;module&gt;, in which case it is prepared when the &lt;module&gt;        is created (see Subclause 4.16, &quot;Modules&quot;) and executed when the        containing procedure is called.     -  in an embedded SQL host program, in which case it is pre-        pared when the embedded SQL host program is preprocessed (see        Subclause 4.23, &quot;Embedded syntax&quot;).     -  being prepared and executed by the use of SQL-dynamic statements        (which are themselves executed in one of the foregoing two ways-        see Subclause 4.24, &quot;SQL dynamic statements&quot;).     -  direct invocation, in which case it is effectively prepared        immediately prior to execution (see Subclause 4.25, &quot;Direct        invocation of SQL&quot;).     There are at least five ways of classifying SQL-statements:     -  According to their effect on SQL objects, whether persistent        objects, i.e., SQL-data and schemas, or transient objects, such        as SQL-sessions and other SQL-statements.     -  According to whether or not they start a transaction, or can, or        must, be executed when no transaction is active.     -  According to whether or not they may be embedded.     -  According to whether they may be dynamically prepared and exe-        cuted.     -  According to whether or not they may be directly executed.     This International Standard permits implementations to provide ad-     ditional, implementation-defined, statements that may fall into any     of these categories. This Subclause will not mention those state-     ments again, as their classification is entirely implementation-     defined.                                                           Concepts   51</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.22 SQL-statements     4.22.2  SQL-statements classified by function     The following are the main classes of SQL-statements:     -  SQL-schema statements; these may have a persistent effect on        schemas     -  SQL-data statements; some of these, the SQL-data change state-        ments, may have a persistent effect on SQL-data     -  SQL-transaction statements; except for the &lt;commit statement&gt;,        these, and the following classes, have no effects that persist        when a session is terminated     -  SQL-connection statements     -  SQL-session statements     -  SQL-dynamic statements     -  SQL-diagnostics statements     -  SQL embedded exception declaration     The following are the SQL-schema statements:     -  &lt;schema definition&gt;     -  &lt;drop schema statement&gt;     -  &lt;domain definition&gt;     -  &lt;drop domain statement&gt;     -  &lt;table definition&gt;     -  &lt;drop table statement&gt;     -  &lt;view definition&gt;     -  &lt;drop view statement&gt;     -  &lt;assertion definition&gt;     -  &lt;drop assertion statement&gt;     -  &lt;alter table statement&gt;     -  &lt;alter domain statement&gt;     -  &lt;grant statement&gt;     -  &lt;revoke statement&gt;     -  &lt;character set definition&gt;     -  &lt;drop character set statement&gt;     52  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                     4.22 SQL-statements     -  &lt;collation definition&gt;     -  &lt;drop collation statement&gt;     -  &lt;translation definition&gt;     -  &lt;drop translation statement&gt;     The following are the SQL-data statements:     -  &lt;temporary table declaration&gt;     -  &lt;declare cursor&gt;     -  &lt;dynamic declare cursor&gt;     -  &lt;allocate cursor statement&gt;     -  &lt;dynamic select statement&gt;     -  &lt;open statement&gt;     -  &lt;dynamic open statement&gt;     -  &lt;close statement&gt;     -  &lt;dynamic close statement&gt;     -  &lt;fetch statement&gt;     -  &lt;dynamic fetch statement&gt;     -  &lt;select statement: single row&gt;     -  &lt;direct select statement: multiple rows&gt;     -  &lt;dynamic single row select statement&gt;     -  All SQL-data change statements     The following are the SQL-data change statements:     -  &lt;insert statement&gt;     -  &lt;delete statement: searched&gt;     -  &lt;delete statement: positioned&gt;     -  &lt;dynamic delete statement: positioned&gt;     -  &lt;preparable dynamic delete statement: positioned&gt;     -  &lt;update statement: searched&gt;     -  &lt;update statement: positioned&gt;     -  &lt;dynamic update statement: positioned&gt;                                                           Concepts   53</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.22 SQL-statements     -  &lt;preparable dynamic update statement: positioned&gt;     The following are the SQL-transaction statements:     -  &lt;set transaction statement&gt;     -  &lt;set constraints mode statement&gt;     -  &lt;commit statement&gt;     -  &lt;rollback statement&gt;     The following are the SQL-connection statements:     -  &lt;connect statement&gt;     -  &lt;set connection statement&gt;     -  &lt;disconnect statement&gt;     The following are the SQL-session statements:     -  &lt;set catalog statement&gt;     -  &lt;set schema statement&gt;     -  &lt;set names statement&gt;     -  &lt;set session authorization identifier statement&gt;     -  &lt;set local time zone statement&gt;     The following are the SQL-dynamic statements:     -  &lt;execute immediate statement&gt;     -  &lt;allocate descriptor statement&gt;     -  &lt;deallocate descriptor statement&gt;     -  &lt;get descriptor statement&gt;     -  &lt;set descriptor statement&gt;     -  &lt;prepare statement&gt;     -  &lt;deallocate prepared statement&gt;     -  &lt;describe input statement&gt;     -  &lt;describe output statement&gt;     -  &lt;execute statement&gt;     The following is the SQL-diagnostics statement:     -  &lt;get diagnostics statement&gt;     54  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                     4.22 SQL-statements     The following is the SQL embedded exception declaration:     -  &lt;embedded exception declaration&gt;     4.22.3  Embeddable SQL-statements     The following SQL-statements are embeddable in an embedded SQL host     program, and may be the &lt;SQL procedure statement&gt; in a &lt;procedure&gt;     in a &lt;module&gt;:     -  All SQL-schema statements     -  All SQL-transaction statements     -  All SQL-connection statements     -  All SQL-session statements     -  All SQL-dynamic statements     -  All SQL-diagnostics statements     -  The following SQL-data statements:        o &lt;allocate cursor statement&gt;        o &lt;open statement&gt;        o &lt;dynamic open statement&gt;        o &lt;close statement&gt;        o &lt;dynamic close statement&gt;        o &lt;fetch statement&gt;        o &lt;dynamic fetch statement&gt;        o &lt;select statement: single row&gt;        o &lt;insert statement&gt;        o &lt;delete statement: searched&gt;        o &lt;delete statement: positioned&gt;        o &lt;dynamic delete statement: positioned&gt;        o &lt;update statement: searched&gt;        o &lt;update statement: positioned&gt;        o &lt;dynamic update statement: positioned&gt;                                                           Concepts   55</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.22 SQL-statements     The following SQL-statements are embeddable in an embedded SQL host     program, and may occur in a &lt;module&gt;, though not in a &lt;procedure&gt;:     -  &lt;temporary table declaration&gt;     -  &lt;declare cursor&gt;     -  &lt;dynamic declare cursor&gt;     The following SQL-statements are embeddable in an embedded SQL host     program, but may not occur in a &lt;module&gt;:     -  SQL embedded exception declarations     Consequently, the following SQL-data statements are not embeddable     in an embedded SQL host program, nor may they occur in a &lt;mod-     ule&gt;, nor be the &lt;SQL procedure statement&gt; in a &lt;procedure&gt; in a     &lt;module&gt;:     -  &lt;dynamic select statement&gt;     -  &lt;dynamic single row select statement&gt;     -  &lt;direct select statement: multiple rows&gt;     -  &lt;preparable dynamic delete statement: positioned&gt;     -  &lt;preparable dynamic update statement: positioned&gt;     4.22.4  Preparable and immediately executable SQL-statements     The following SQL-statements are preparable:     -  All SQL-schema statements     -  All SQL-transaction statements     -  All SQL-session statements     -  The following SQL-data statements:        o &lt;delete statement: searched&gt;        o &lt;dynamic select statement&gt;        o &lt;dynamic single row select statement&gt;        o &lt;insert statement&gt;        o &lt;update statement: searched&gt;        o &lt;preparable dynamic delete statement: positioned&gt;        o &lt;preparable dynamic update statement: positioned&gt;        o &lt;preparable implementation-defined statement&gt;     56  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                     4.22 SQL-statements     Consequently, the following SQL-statements are not preparable:     -  All SQL-connection statements     -  All SQL-dynamic statements     -  All SQL-diagnostics statements     -  SQL embedded exception declarations     -  The following SQL-data statements:        o &lt;allocate cursor statement&gt;        o &lt;open statement&gt;        o &lt;dynamic open statement&gt;        o &lt;close statement&gt;        o &lt;dynamic close statement&gt;        o &lt;fetch statement&gt;        o &lt;dynamic fetch statement&gt;        o &lt;select statement: single row&gt;        o &lt;delete statement: positioned&gt;        o &lt;dynamic delete statement: positioned&gt;        o &lt;update statement: positioned&gt;        o &lt;dynamic update statement: positioned&gt;        o &lt;direct select statement: multiple rows&gt;        o &lt;temporary table declaration&gt;        o &lt;declare cursor&gt;        o &lt;dynamic declare cursor&gt;     Any preparable SQL-statement can be executed immediately, with the     exception of:     -  &lt;dynamic select statement&gt;     -  &lt;dynamic single row select statement&gt;                                                           Concepts   57</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.22 SQL-statements     4.22.5  Directly executable SQL-statements     The following SQL-statements may be executed directly:     -  All SQL-schema statements     -  All SQL-transaction statements     -  All SQL-connection statements     -  All SQL-session statements     -  The following SQL-data statements:        o &lt;temporary table declaration&gt;        o &lt;direct select statement: multiple rows&gt;        o &lt;insert statement&gt;        o &lt;delete statement: searched&gt;        o &lt;update statement: searched&gt;     Consequently, the following SQL-statements may not be executed     directly:     -  All SQL-dynamic statements     -  All SQL-diagnostics statements     -  SQL embedded exception declarations     -  The following SQL-data statements:        o &lt;declare cursor&gt;        o &lt;dynamic declare cursor&gt;        o &lt;allocate cursor statement&gt;        o &lt;open statement&gt;        o &lt;dynamic open statement&gt;        o &lt;close statement&gt;        o &lt;dynamic close statement&gt;        o &lt;fetch statement&gt;        o &lt;dynamic fetch statement&gt;        o &lt;select statement: single row&gt;        o &lt;dynamic select statement&gt;        o &lt;dynamic single row select statement&gt;     58  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                     4.22 SQL-statements        o &lt;delete statement: positioned&gt;        o &lt;dynamic delete statement: positioned&gt;        o &lt;preparable dynamic delete statement: positioned&gt;        o &lt;update statement: positioned&gt;        o &lt;dynamic update statement: positioned&gt;        o &lt;preparable dynamic update statement: positioned&gt;     4.22.6  SQL-statements and transaction states     Whether an &lt;execute immediate statement&gt; starts a transaction de-     pends on what SQL-statement is the value of &lt;SQL statement vari-     able&gt;. Whether an &lt;execute statement&gt; starts a transaction depends     on what SQL-statement was the value of &lt;SQL statement variable&gt;     when the prepared statement identified by &lt;SQL statement name&gt; was     prepared.     The following SQL-statements are transaction initiating SQL-     statements, i.e., if there is no current transaction, and a state-     ment of this class is executed, a transaction is initiated:     -  All SQL-schema statements     -  The following SQL-data statements:        o &lt;allocate cursor statement&gt;        o &lt;dynamic select statement&gt;        o &lt;open statement&gt;        o &lt;dynamic open statement&gt;        o &lt;close statement&gt;        o &lt;dynamic close statement&gt;        o &lt;fetch statement&gt;        o &lt;dynamic fetch statement&gt;        o &lt;select statement: single row&gt;        o &lt;direct select statement: multiple rows&gt;        o &lt;dynamic single row select statement&gt;        o &lt;insert statement&gt;        o &lt;delete statement: searched&gt;        o &lt;delete statement: positioned&gt;                                                           Concepts   59</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.22 SQL-statements        o &lt;dynamic delete statement: positioned&gt;        o &lt;preparable dynamic delete statement: positioned&gt;        o &lt;update statement: searched&gt;        o &lt;update statement: positioned&gt;        o &lt;dynamic update statement: positioned&gt;        o &lt;preparable dynamic update statement: positioned&gt;     -  The following SQL-dynamic statements:        o &lt;describe input statement&gt;        o &lt;describe output statement&gt;        o &lt;allocate descriptor statement&gt;        o &lt;deallocate descriptor statement&gt;        o &lt;get descriptor statement&gt;        o &lt;set descriptor statement&gt;        o &lt;prepare statement&gt;        o &lt;deallocate prepared statement&gt;     The following SQL-statements are not transaction initiating SQL-     statements, i.e., if there is no current transaction, and a state-     ment of this class is executed, no transaction is initiated.     -  All SQL-transaction statements     -  All SQL-connection statements     -  All SQL-session statements     -  All SQL-diagnostics statements     -  SQL embedded exception declarations     -  The following SQL-data statements:        o &lt;temporary table declaration&gt;        o &lt;declare cursor&gt;        o &lt;dynamic declare cursor&gt;        o &lt;dynamic select statement&gt;     60  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                    4.23 Embedded syntax     4.23  Embedded syntax     An &lt;embedded SQL host program&gt; (&lt;embedded SQL Ada program&gt;, &lt;em-     bedded SQL C program&gt;, &lt;embedded SQL COBOL program&gt;, &lt;embedded     SQL Fortran program&gt;, &lt;embedded SQL MUMPS program&gt;, &lt;embedded SQL     Pascal program&gt;, or &lt;embedded SQL PL/I program&gt;) is a compilation     unit that consists of programming language text and SQL text. The     programming language text shall conform to the requirements of a     specific standard programming language. The SQL text shall con-     sist of one or more &lt;embedded SQL statement&gt;s and, optionally,     one or more &lt;embedded SQL declare section&gt;s, as defined in this     International Standard. This allows database applications to be     expressed in a hybrid form in which SQL-statements are embedded     directly in a compilation unit. Such a hybrid compilation unit is     defined to be equivalent to a standard compilation unit in which     the SQL-statements have been replaced by standard procedure or     subroutine calls of SQL &lt;procedure&gt;s in a separate SQL &lt;module&gt;,     and in which each &lt;embedded SQL begin declare&gt; and each &lt;embedded     SQL end declare&gt; has been removed and the declarations contained     therein have been suitably transformed into standard host-language     syntax.     An implementation may reserve a portion of the name space in the     &lt;embedded SQL host program&gt; for the names of procedures or subrou-     tines that are generated to replace SQL-statements and for program     variables and branch labels that may be generated as required to     support the calling of these procedures or subroutines; whether     this reservation is made is implementation-defined. They may sim-     ilarly reserve name space for the &lt;module name&gt; and &lt;procedure     name&gt;s of the generated &lt;module&gt; that may be associated with the     resulting standard compilation unit. The portion of the name space     to be so reserved, if any, is implementation-defined.     4.24  SQL dynamic statements     In many cases, the SQL-statement to be executed can be coded into     a &lt;module&gt; or into a compilation unit using the embedded syntax.     In other cases, the SQL-statement is not known when the program     is written and will be generated during program execution. An     &lt;execute immediate statement&gt; can be used for a one-time prepa-     ration and execution of an SQL-statement. A &lt;prepare statement&gt;     is used to prepare the generated SQL-statement for subsequent ex-     ecution. A &lt;deallocate prepared statement&gt; is used to deallocate     SQL-statements that have been prepared with a &lt;prepare statement&gt;.     A description of the input parameters for a prepared statement     can be obtained by execution of a &lt;describe input statement&gt;. A     description of the resultant columns of a &lt;dynamic select state-     ment&gt; or &lt;dynamic single row select statement&gt; can be obtained by     execution of a &lt;describe output statement&gt;. For a statement other     than a &lt;dynamic select statement&gt;, an &lt;execute statement&gt; is used     to associate parameters with the prepared statement and execute                                                           Concepts   61</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.24 SQL dynamic statements     it as though it had been coded when the program was written. For a     &lt;dynamic select statement&gt;, the prepared &lt;cursor specification&gt; is     associated with a cursor via a &lt;dynamic declare cursor&gt; or &lt;allo-     cate cursor statement&gt;. The cursor can be opened and parameters can     be associated with the cursor with a &lt;dynamic open statement&gt;. A     &lt;dynamic fetch statement&gt; positions an open cursor on a specified     row and retrieves the values of the columns of that row. A &lt;dynamic     close statement&gt; closes a cursor that was opened with a &lt;dynamic     open statement&gt;. A &lt;dynamic delete statement: positioned&gt; is used     to delete rows through a dynamic cursor. A &lt;dynamic update state-     ment: positioned&gt; is used to update rows through a dynamic cursor.     A &lt;preparable dynamic delete statement: positioned&gt; is used to     delete rows through a dynamic cursor when the precise format of the     statement isn&#39;t known until runtime. A &lt;preparable dynamic update     statement: positioned&gt; is used to update rows through a dynamic     cursor when the precise format of the statement isn&#39;t known until     runtime.     The interface for input parameters for a prepared statement and     for the resulting values from a &lt;dynamic fetch statement&gt; or the     execution of a prepared &lt;dynamic single row select statement&gt; can     be either a list of parameters or embedded variables or an SQL     descriptor area. An SQL descriptor area consists of zero or more     item descriptor areas, together with a COUNT of the number of those     item descriptor areas. Each item descriptor area consists of the     fields specified in Table 17, &quot;Data types of &lt;key word&gt;s used in     SQL item descriptor areas&quot;, in Subclause 17.1, &quot;Description of SQL     item descriptor areas&quot;. The SQL descriptor area is allocated and     maintained by the system with the following statements: &lt;allocate     descriptor statement&gt;, &lt;deallocate descriptor statement&gt;, &lt;set     descriptor statement&gt;, and &lt;get descriptor statement&gt;.     An SQL descriptor area is identified by a &lt;descriptor name&gt;, which     is a &lt;simple value specification&gt; whose value is an &lt;identifier&gt;.     Two &lt;descriptor name&gt;s identify the same SQL descriptor area if     their values, with leading and trailing &lt;space&gt;s removed, are     equivalent according to the rules for &lt;identifier&gt; comparisons     in Subclause 5.2, &quot;&lt;token&gt; and &lt;separator&gt;&quot;.     Dynamic statements can be identified by &lt;statement name&gt;s or by     &lt;extended statement name&gt;s. Similarly, dynamic cursors can be     identified by &lt;cursor name&gt;s and by &lt;extended cursor name&gt;s. The     non-extended names are &lt;identifier&gt;s. The extended names are &lt;tar-     get specification&gt;s whose values are &lt;identifier&gt;s used to iden-     tify the statement or cursor. Two extended names are equivalent     if their values, with leading and trailing &lt;space&gt;s removed, are     equivalent according to the rules for &lt;identifier&gt; comparison in     Subclause 5.2, &quot;&lt;token&gt; and &lt;separator&gt;&quot;.     An SQL descriptor area name may be defined as global or local.     Similarly, an extended statement name or extended cursor name may     be global or local. The scope of a global name is the SQL-session.     The scope of a local name is the &lt;module&gt; in which it appears. A     reference to an entity in which one specifies a global scope is     valid only if the entity was defined as global and if the reference     62  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                             4.24 SQL dynamic statements     is from the same SQL-session in which it was defined. A reference     to an entity in which one specifies a local scope is valid only if     the entity was defined as local and if the reference is from the     same &lt;module&gt; in which it was defined. (The scope of non-extended     statement names and non-extended cursor names is always local.)     Within an SQL-session, all global prepared statements (prepared     statements with global statement names) belong to the SQL-session     &lt;module&gt;. Within an SQL-session, each local prepared statement     (prepared statements with local statement names) belongs to the     &lt;module&gt; that contains the &lt;prepare statement&gt; or &lt;execute immedi-     ate statement&gt; with which it is prepared.     Note: The SQL-session &lt;module&gt; is defined in Subclause 4.30, &quot;SQL-     sessions&quot;.     Dynamic execution of SQL-statements can generally be accomplished     in two different ways. Statements can be prepared for execution     and then later executed one or more times; when the statement is     no longer needed for execution, it can be released by the use of     a &lt;deallocate prepared statement&gt;. Alternatively, a statement that     is needed only once can be executed without the preparation step-it     can be executed immediately (not all SQL-statements can be executed     immediately).     Many SQL-statements can be written to use &quot;parameters&quot; (which are     manifested in static execution of SQL-statements as &lt;parameters&gt;     in &lt;SQL statement&gt;s contained in &lt;procedure&gt;s in &lt;module&gt;s or as     &lt;embedded variable name&gt;s in &lt;SQL statement&gt;s contained in &lt;em-     bedded SQL host program&gt;s). In SQL-statements that are executed     dynamically, the parameters are called dynamic parameters (&lt;dynamic     parameter specification&gt;s) and are represented in SQL language by a     &lt;question mark&gt; (?).     In many situations, an application that generates an SQL-statement     for dynamic execution knows in detail the required characteristics     (e.g., &lt;data type&gt;, &lt;length&gt;, &lt;precision&gt;, &lt;scale&gt;, etc.) of each     of the dynamic parameters used in the statement; similarly, the ap-     plication may also know in detail the characteristics of the values     that will be returned by execution of the statement. However, in     other cases, the application may not know this information to the     required level of detail; it is possible in some cases for the ap-     plication to ascertain the information from the Information Schema,     but in other cases (e.g., when a returned value is derived from     a computation instead of simply from a column in a table, or when     dynamic parameters are supplied) this information is not gener-     ally available except in the context of preparing the statement for     execution.     To provide the necessary information to applications, SQL per-     mits an application to request the database system to describe a     prepared statement. The description of a statement identifies the     number of dynamic parameters (describe input) and their data type     information or it identifies the number of values to be returned                                                           Concepts   63</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.24 SQL dynamic statements     (describe output) and their data type information. The descrip-     tion of a statement is placed into the SQL descriptor areas already     mentioned.     Many, but not all, SQL-statements can be prepared and executed     dynamically.     Note: The complete list of statements that may be dynamically pre-     pared and executed is defined in Subclause 4.22.4, &quot;Preparable and     immediately executable SQL-statements&quot;.     Certain &quot;set statements&quot; (&lt;set catalog statement&gt;, &lt;set schema     statement&gt;, and &lt;set names statement&gt;) have no effect other than     to set up default information (&lt;catalog name&gt;, &lt;schema name&gt;,     and &lt;character set&gt;, respectively) to be applied to other SQL-     statements that are prepared or executed immediately or that are     invoked directly.     Syntax errors and Access Rule violations caused by the preparation     or immediate execution of &lt;preparable statement&gt;s are identi-     fied when the statement is prepared (by &lt;prepare statement&gt;) or     when it is executed (by &lt;execute statement&gt; or &lt;execute immediate     statement&gt;); such violations are indicated by the raising of an     exception condition.     4.25  Direct invocation of SQL     Direct invocation of SQL is a mechanism for executing direct SQL-     statements, known as &lt;direct SQL statement&gt;s. In direct invocation     of SQL, the method of invoking &lt;direct SQL statement&gt;s, the method     of raising conditions that result from the execution of &lt;direct SQL     statement&gt;s, the method of accessing the diagnostics information     that results from the execution of &lt;direct SQL statement&gt;s, and the     method of returning the results are implementation-defined.     4.26  Privileges     A privilege authorizes a given category of &lt;action&gt; to be per-     formed on a specified base table, view, column, domain, character     set, collation, or translation by a specified &lt;authorization iden-     tifier&gt;. The mapping of &lt;authorization identifier&gt;s to operating     system users is implementation-dependent. The &lt;action&gt;s that can be     specified are:     -  INSERT     -  INSERT (&lt;column name list&gt;)     -  UPDATE     -  UPDATE (&lt;column name list&gt;)     -  DELETE     64  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                         4.26 Privileges     -  SELECT     -  REFERENCES     -  REFERENCES (&lt;column name list&gt;)     -  USAGE     An &lt;authorization identifier&gt; is specified for each &lt;schema defini-     tion&gt; and &lt;module&gt; as well as for each SQL-session.     A schema that is owned by a given &lt;authorization identifier&gt; may     contain privilege descriptors that describe privileges granted to     other &lt;authorization identifier&gt;s (grantees). The granted priv-     ileges apply to objects defined in the current schema. The WITH     GRANT OPTION clause of a &lt;grant statement&gt; specifies whether the     recipient of a privilege (acting as a grantor) may grant it to     others.     When an SQL-session is initiated, the &lt;authorization identifier&gt;     for the SQL-session, called the SQL-session &lt;authorization identi-     fier&gt;, is determined in an implementation-dependent manner, unless     the session is initiated using a &lt;connect statement&gt;. Subsequently,     the SQL-session &lt;authorization identifier&gt; can be redefined by the     successful execution of a &lt;set session authorization identifier     statement&gt;.     A &lt;module&gt; may specify an &lt;authorization identifier&gt;, called a     &lt;module authorization identifier&gt;. If the &lt;module authorization     identifier&gt; is specified, then that &lt;module authorization iden-     tifier&gt; is used as the current &lt;authorization identifier&gt; for the     execution of all &lt;procedure&gt;s in the &lt;module&gt;. If the &lt;module au-     thorization identifier&gt; is not specified, then the SQL-session     &lt;authorization identifier&gt; is used as the current &lt;authorization     identifier&gt; for the execution of each &lt;procedure&gt; in the &lt;module&gt;.     A &lt;schema definition&gt; may specify an &lt;authorization identifier&gt;,     called a &lt;schema authorization identifier&gt;. If the &lt;schema autho-     rization identifier&gt; is specified, then that is used as the current     &lt;authorization identifier&gt; for the creation of the schema. If the     &lt;module authorization identifier&gt; is not specified, then the &lt;mod-     ule authorization identifier&gt; or the SQL-session &lt;authorization     identifier&gt; is used as the current &lt;authorization identifier&gt; for     the creation of the schema.     The current &lt;authorization identifier&gt; determines the privileges     for the execution of each SQL-statement. For direct SQL, the SQL-     session &lt;authorization identifier&gt; is always the current &lt;autho-     rization identifier&gt;.     Each privilege is represented by a privilege descriptor. A privi-     lege descriptor contains:     -  the identification of the table, column, domain, character set,        collation, or translation that the descriptor describes;     -  the &lt;authorization identifier&gt; of the grantor of the privilege;                                                           Concepts   65</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.26 Privileges     -  the &lt;authorization identifier&gt; of the grantee of the privilege;     -  identification of the action that the privilege allows; and     -  an indication of whether or not the privilege is grantable.     A privilege descriptor with an action of INSERT, UPDATE, DELETE,     SELECT, or REFERENCES is called a table privilege descriptor and     identifies the existence of a privilege on the table identified by     the privilege descriptor.     A privilege descriptor with an action of SELECT (&lt;column name     list&gt;), INSERT (&lt;column name list&gt;), UPDATE (&lt;column name list&gt;),     or REFERENCES (&lt;column name list&gt;) is called a column privilege de-     scriptor and identifies the existence of a privilege on the column     in the table identified by the privilege descriptor.     Note: In this International Standard, a SELECT column privilege     cannot be explicitly granted or revoked. However, for the sake     of compatibility with planned future language extensions, SELECT     column privilege descriptors will appear in the Information Schema.     A table privilege descriptor specifies that the privilege iden-     tified by the action (unless the action is DELETE) is to be au-     tomatically granted by the grantor to the grantee on all columns     subsequently added to the table.     A privilege descriptor with an action of USAGE is called a usage     privilege descriptor and identifies the existence of a privilege on     the domain, character set, collation, or translation identified by     the privilege descriptor.     A grantable privilege is a privilege associated with a schema that     may be granted by a &lt;grant statement&gt;.     The phrase applicable privileges refers to the privileges defined     by the privilege descriptors that define privileges granted to the     current &lt;authorization identifier&gt;.     The set of applicable privileges for the current &lt;authorization     identifier&gt; consists of the privileges defined by the privilege     descriptors associated with that &lt;authorization identifier&gt; and     the privileges defined by the privilege descriptors associated with     PUBLIC.     Privilege descriptors that represent privileges for the owner of     an object have a special grantor value, &quot;_SYSTEM&quot;. This value is     reflected in the Information Schema for all privileges that apply     to the owner of the object.     4.27  SQL-agents     An SQL-agent is an implementation-dependent entity that causes the     execution of SQL-statements.     66  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                   4.28 SQL-transactions     4.28  SQL-transactions     An SQL-transaction (sometimes simply called a &quot;transaction&quot;) is     a sequence of executions of SQL-statements that is atomic with     respect to recovery. These operations are performed by one or more     compilation units and &lt;module&gt;s or by the direct invocation of SQL.     It is implementation-defined whether or not the non-dynamic or     dynamic execution of an SQL-data statement or the execution of     an &lt;SQL dynamic data statement&gt; is permitted to occur within the     same SQL-transaction as the non-dynamic or dynamic execution of     an SQL-schema statement. If it does occur, then the effect on any     open cursor, prepared dynamic statement, or deferred constraint     is implementation-defined. There may be additional implementation-     defined restrictions, requirements, and conditions. If any such     restrictions, requirements, or conditions are violated, then an     implementation-defined exception condition or a completion con-     dition warning with an implementation-defined subclass code is     raised.     Each &lt;module&gt; or direct invocation of SQL that executes an     SQL-statement of an SQL-transaction is associated with that     SQL-transaction. An SQL-transaction is initiated when no SQL-     transaction is currently active and a &lt;procedure&gt; is called that     results in the execution of a transaction-initiating SQL-statement     or by direct invocation of SQL that results in the execution of a     transaction-initiating &lt;direct SQL statement&gt;. An SQL-transaction     is terminated by a &lt;commit statement&gt; or a &lt;rollback statement&gt;.     If an SQL-transaction is terminated by successful execution of a     &lt;commit statement&gt;, then all changes made to SQL-data or schemas by     that SQL-transaction are made persistent and accessible to all con-     current and subsequent SQL-transactions. If an SQL-transaction is     terminated by a &lt;rollback statement&gt; or unsuccessful execution of     a &lt;commit statement&gt;, then all changes made to SQL-data or schemas     by that SQL-transaction are canceled. Committed changes cannot be     canceled. If execution of a &lt;commit statement&gt; is attempted, but     certain exception conditions are raised, it is unknown whether or     not the changes made to SQL-data or schemas by that SQL-transaction     are canceled or made persistent.     An SQL-transaction has a constraint mode for each integrity con-     straint. The constraint mode for an integrity constraint in an     SQL-transaction is described in Subclause 4.10, &quot;Integrity con-     straints&quot;.     An SQL-transaction has an access mode that is either read-only or     read-write. The access mode may be explicitly set by a &lt;set trans-     action statement&gt;; otherwise, it is implicitly set to read-write.     The term read-only applies only to viewed tables and persistent     base tables.     An SQL-transaction has a diagnostics area limit, which is a pos-     itive integer that specifies the maximum number of conditions     that can be placed in the diagnostics area during execution of     an SQL-statement in this SQL-transaction.                                                           Concepts   67</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.28 SQL-transactions     SQL-transactions initiated by different SQL-agents that access     the same SQL-data or schemas and overlap in time are concurrent     SQL-transactions.     An SQL-transaction has an isolation level that is READ UNCOMMITTED,     READ COMMITTED, REPEATABLE READ, or SERIALIZABLE. The isolation     level of an SQL-transaction defines the degree to which the opera-     tions on SQL-data or schemas in that SQL-transaction are affected     by the effects of and can affect operations on SQL-data or schemas     in concurrent SQL-transactions. The isolation level of a SQL-     transaction is SERIALIZABLE by default. The level can be explicitly     set by the &lt;set transaction statement&gt;.     The execution of concurrent SQL-transactions at isolation level     SERIALIZABLE is guaranteed to be serializable. A serializable exe-     cution is defined to be an execution of the operations of concur-     rently executing SQL-transactions that produces the same effect as     some serial execution of those same SQL-transactions. A serial exe-     cution is one in which each SQL-transaction executes to completion     before the next SQL-transaction begins.     The isolation level specifies the kind of phenomena that can occur     during the execution of concurrent SQL-transactions. The following     phenomena are possible:     1) P1 (&quot;Dirty read&quot;): SQL-transaction T1 modifies a row. SQL-        transaction T2 then reads that row before T1 performs a COMMIT.        If T1 then performs a ROLLBACK, T2 will have read a row that was        never committed and that may thus be considered to have never        existed.     2) P2 (&quot;Non-repeatable read&quot;): SQL-transaction T1 reads a row. SQL-        transaction T2 then modifies or deletes that row and performs        a COMMIT. If T1 then attempts to reread the row, it may receive        the modified value or discover that the row has been deleted.     3) P3 (&quot;Phantom&quot;): SQL-transaction T1 reads the set of rows N        that satisfy some &lt;search condition&gt;. SQL-transaction T2 then        executes SQL-statements that generate one or more rows that        satisfy the &lt;search condition&gt; used by SQL-transaction T1. If        SQL-transaction T1 then repeats the initial read with the same        &lt;search condition&gt;, it obtains a different collection of rows.     The four isolation levels guarantee that each SQL-transaction will     be executed completely or not at all, and that no updates will be     lost. The isolation levels are different with respect to phenomena     P1, P2, and P3. Table 9, &quot;SQL-transaction isolation levels and the     three phenomena&quot; specifies the phenomena that are possible and not     possible for a given isolation level.     68  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                   4.28 SQL-transactions     __Table_9-SQL-transaction_isolation_levels_and_the_three_phenomena_     _Level__________________P1______P2_______P3________________________    | READ UNCOMMITTED     | Possib|e Possib|e Possible                |    |                      |       |        |                          |    | READ COMMITTED       | Not   | Possibl| Possible                 |                             Possible    | REPEATABLE READ      | Not   | Not    | Possible                 |    |                      | Possib|e Possib|e                         |    |                      |       |        |                          |    | SERIALIZABLE         | Not   | Not    | Not Possible             |    |______________________|_Possib|e_Possib|e_________________________|    |                      |       |        |                          |    |Note: The exclusion of|these p|enomena |or SQL-transactions ex-   |     ecuting at isolation level SERIALIZABLE is a consequence of the     requirement that such transactions be serializable.     Changes made to SQL-data or schemas by an SQL-transaction in an     SQL-session may be perceived by that SQL-transaction in that     same SQL-session, and by other SQL-transactions, or by that same     SQL-transaction in other SQL-sessions, at isolation level READ     UNCOMMITTED, but cannot be perceived by other SQL-transactions at     isolation level READ COMMITTED, REPEATABLE READ, or SERIALIZABLE     until the former SQL-transaction terminates with a &lt;commit state-     ment&gt;.     Regardless of the isolation level of the SQL-transaction, phenomena     P1, P2, and P3 shall not occur during the implied reading of schema     definitions performed on behalf of executing an SQL-statement, the     checking of integrity constraints, and the execution of referen-     tial actions associated with referential constraints. The schema     definitions that are implicitly read are implementation-dependent.     This does not affect the explicit reading of rows from tables in     the Information Schema, which is done at the isolation level of the     SQL-transaction.     The execution of a &lt;rollback statement&gt; may be initiated implicitly     by an implementation when it detects the inability to guarantee the     serializability of two or more concurrent SQL-transactions. When     this error occurs, an exception condition is raised: transaction     rollback-serialization failure.     The execution of a &lt;rollback statement&gt; may be initiated implicitly     by an implementation when it detects unrecoverable errors. When     such an error occurs, an exception condition is raised: transaction     rollback with an implementation-defined subclass code.     The execution of an SQL-statement within an SQL-transaction has     no effect on SQL-data or schemas other than the effect stated in     the General Rules for that SQL-statement, in the General Rules     for Subclause 11.8, &quot;&lt;referential constraint definition&gt;&quot;, and     in the General Rules for Subclause 12.3, &quot;&lt;procedure&gt;&quot;. Together     with serializable execution, this implies that all read opera-     tions are repeatable within an SQL-transaction at isolation level     SERIALIZABLE, except for:                                                           Concepts   69</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.28 SQL-transactions     1) the effects of changes to SQL-data or schemas and its contents        made explicitly by the SQL-transaction itself,     2) the effects of differences in parameter values supplied to pro-        cedures, and     3) the effects of references to time-varying system variables such        as CURRENT_DATE and CURRENT_USER.     In some environments (e.g., remote database access), an SQL-     transaction can be part of an encompassing transaction that is     controlled by an agent other than the SQL-agent. The encompass-     ing transaction may involve different resource managers, the     SQL-environment being just one instance of such a manager. In     such environments, an encompassing transaction shall be ter-     minated via that other agent, which in turn interacts with the     SQL-environment via an interface that may be different from SQL     (COMMIT or ROLLBACK), in order to coordinate the orderly termi-     nation of the encompassing transaction. When an SQL-transaction     is part of an encompassing transaction that is controlled by an     agent other than an SQL-agent and a &lt;rollback statement&gt; is ini-     tiated implicitly by an implementation, then the implementation     will interact with that other agent to terminate that encompassing     transaction. The specification of the interface between such agents     and the SQL-environment is beyond the scope of this International     Standard. However, it is important to note that the semantics of an     SQL-transaction remain as defined in the following sense:     -  When an agent that is different from the SQL-agent requests        the SQL-environment to rollback an SQL-transaction, the General        Rules of Subclause 14.4, &quot;&lt;rollback statement&gt;&quot;, are performed.     -  When such an agent requests the SQL-environment to commit an        SQL-transaction, the General Rules of Subclause 14.3, &quot;&lt;commit        statement&gt;&quot;, are performed. To guarantee orderly termination        of the encompassing transaction, this commit operation may be        processed in several phases not visible to the application; not        all the General Rules of Subclause 14.3, &quot;&lt;commit statement&gt;&quot;,        need to be executed in a single phase.     However, even in such environments, the SQL-agent interacts di-     rectly with the SQL-server to set attributes (such as read-only     or read-write, isolation level, and constraints mode) that are     specific to the SQL-transaction model.     4.29  SQL-connections     An SQL-connection is an association between an SQL-client and an     SQL-server. An SQL-connection may be established and named by a     &lt;connect statement&gt;, which identifies the desired SQL-server by     means of an &lt;SQL-server name&gt;. A &lt;connection name&gt; is specified     70  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                    4.29 SQL-connections     as a &lt;simple value specification&gt; whose value is an &lt;identi-     fier&gt;. Two &lt;connection name&gt;s identify the same SQL-connection     if their values, with leading and trailing &lt;space&gt;s removed, are     equivalent according to the rules for &lt;identifier&gt; comparison in     Subclause 5.2, &quot;&lt;token&gt; and &lt;separator&gt;&quot;. It is implementation-     defined how an implementation uses &lt;SQL-server name&gt; to determine     the location, identity, and communication protocol required to     access the SQL-server and create an SQL-session.     An SQL-connection is an active SQL-connection if any SQL-statement     that initiates or requires an SQL-transaction has been executed at     its SQL-server during the current SQL-transaction.     An SQL-connection is either current or dormant. If the SQL-     connection established by the most recently executed implicit     or explicit &lt;connect statement&gt; or &lt;set connection statement&gt;     has not been terminated, then that SQL-connection is the current     SQL-connection; otherwise, there is no current SQL-connection. An     existing SQL-connection that is not the current SQL-connection is a     dormant SQL-connection.     An SQL-implementation may detect the loss of the current SQL-     connection during execution of any SQL-statement. When such a     connection failure is detected, an exception condition is raised:     transaction rollback-statement completion unknown. This excep-     tion condition indicates that the results of the actions performed     in the SQL-server on behalf of the statement are unknown to the     SQL-agent.     Similarly, an SQL-implementation may detect the loss of the current     SQL-connection during the execution of a &lt;commit statement&gt;. When     such a connection failure is detected, an exception condition is     raised: connection exception-transaction resolution unknown. This     exception condition indicates that the SQL-implementation cannot     verify whether the SQL-transaction was committed successfully,     rolled back, or left active.     A user may initiate an SQL-connection between the SQL-client as-     sociated with the SQL-agent and a specific SQL-server by executing     a &lt;connect statement&gt;. Otherwise, an SQL-connection between the     SQL-client and an implementation-defined default SQL-server is     initiated when a &lt;procedure&gt; is called and no SQL-connection is     current. The SQL-connection associated with an implementation-     defined default SQL-server is called the default SQL-connection.     An SQL-connection is terminated either by executing a &lt;disconnect     statement&gt;, or following the last call to a &lt;procedure&gt; within the     last active &lt;module&gt;, or by the last execution of a &lt;direct SQL     statement&gt; through the direct invocation of SQL. The mechanism and     rules by which an SQL-environment determines whether a call to a     &lt;procedure&gt; is the last call within the last active &lt;module&gt; or     the last execution of a &lt;direct SQL statement&gt; through the direct     invocation of SQL are implementation-defined.                                                           Concepts   71</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.29 SQL-connections     An implementation shall support at least one SQL-connection and     may require that the SQL-server be identified at the binding time     chosen by the implementation. If an implementation permits more     than one concurrent SQL-connection, then the SQL-agent may connect     to more than one SQL-server and select the SQL-server by executing     a &lt;set connection statement&gt;.     4.30  SQL-sessions     An SQL-session spans the execution of a sequence of consecutive     SQL-statements invoked by a single user from a single SQL-agent or     by the direct invocation of SQL.     An SQL-session is associated with an SQL-connection. The SQL-     session associated with the default SQL-connection is called the     default SQL-session. An SQL-session is either current or dormant.     The current SQL-session is the SQL-session associated with the cur-     rent SQL-connection. A dormant SQL-session is an SQL-session that     is associated with a dormant SQL-connection.     An SQL-session has an SQL-session &lt;module&gt; that is different     from any other &lt;module&gt; that exists simultaneously in the SQL-     environment. The SQL-session &lt;module&gt; contains the global prepared     SQL-statements that belong to the SQL-session. The SQL-session     &lt;module&gt; contains a &lt;module authorization clause&gt; that speci-     fies SCHEMA &lt;schema name&gt;, where the value of &lt;schema name&gt; is     implementation-dependent.     Within an SQL-session, declared local temporary tables are effec-     tively created by &lt;temporary table declaration&gt;s. Declared local     temporary tables are accessible only to invocations of &lt;proce-     dure&gt;s in the &lt;module&gt; in which they are created. The definitions     of declared local temporary tables persist until the end of the     SQL-session.     An SQL-session has a unique implementation-dependent SQL-session     identifier. This SQL-session identifier is different from the SQL-     session identifier of any other concurrent SQL-session. The SQL-     session identifier is used to effectively define implementation-     defined schemas that contain the instances of any global temporary     tables, created local temporary tables, or declared local temporary     tables within the SQL-session.     An SQL-session has an &lt;authorization identifier&gt; that is initially     set to an implementation-defined value when the SQL-session is     started, unless the SQL-session is started as a result of suc-     cessful execution of a &lt;connect statement&gt;, in which case the     &lt;authorization identifier&gt; of the SQL-session is set to the value     of the implicit or explicit &lt;user name&gt; contained in the &lt;connect     statement&gt;.     72  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                       4.30 SQL-sessions     An SQL-session has a default catalog name that is used to effec-     tively qualify unqualified &lt;schema name&gt;s that are contained in     &lt;preparable statement&gt;s when those statements are prepared in the     current SQL-session by either an &lt;execute immediate statement&gt;     or a &lt;prepare statement&gt; or are contained in &lt;direct SQL state-     ment&gt;s when those statements are invoked directly. The default     catalog name is initially set to an implementation-defined value     but can subsequently be changed by the successful execution of a     &lt;set catalog statement&gt; or &lt;set schema statement&gt;.     An SQL-session has a default unqualified schema name that is used     to effectively qualify unqualified &lt;qualified name&gt;s that are con-     tained in &lt;preparable statement&gt;s when those statements are pre-     pared in the current SQL-session by either an &lt;execute immediate     statement&gt; or a &lt;prepare statement&gt; or are contained in &lt;direct SQL     statement&gt;s when those statements are invoked directly. The default     unqualified schema name is initially set to an implementation-     defined value but can subsequently be changed by the successful     execution of a &lt;set schema statement&gt;.     An SQL-session has a default character set name that is used to     identify the character set implicit for &lt;identifier&gt;s and &lt;charac-     ter string literal&gt;s that are contained in &lt;preparable statement&gt;s     when those statements are prepared in the current SQL-session by     either an &lt;execute immediate statement&gt; or a &lt;prepare statement&gt; or     are contained in &lt;direct SQL statement&gt;s when those statements are     invoked directly. The default character set name is initially set     to an implementation-defined value but can subsequently be changed     by the successful execution of a &lt;set names statement&gt;.     An SQL-session has a default local time zone displacement, which is     a value of data type INTERVAL HOUR TO MINUTE. The default local     time zone displacement is initially set to an implementation-     defined value but can subsequently be changed by successful exe-     cution of a &lt;set local time zone statement&gt;.     An SQL-session has context that is preserved when an SQL-session     is made dormant and restored when the SQL-session is made current.     This context comprises:     -  the current SQL-session identifier,     -  the current &lt;authorization identifier&gt;,     -  the identities of all instances of temporary tables,     -  the SQL-session &lt;module&gt;,     -  the current default catalog name,     -  the current default unqualified schema name,     -  the current character set name substitution value,     -  the current default time zone,                                                           Concepts   73</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.30 SQL-sessions     -  the current constraint mode for each integrity constraint,     -  the current transaction access mode,     -  the cursor position of all open cursors,     -  the contents of all SQL dynamic descriptor areas,     -  the current transaction isolation level, and     -  the current transaction diagnostics area limit.     4.31  Client-server operation     Within an SQL-environment, an SQL-implementation may be considered     to effectively contain an SQL-client component and one or more     SQL-server components.     When an SQL-agent is active, it is bound in some implementation-     defined manner to a single SQL-client. That SQL-client processes     the explicit or implicit &lt;SQL connection statement&gt; for the first     call to a &lt;procedure&gt; by an SQL-agent. The SQL-client communicates     with, either directly or possibly through other agents such as RDA,     one or more SQL-servers. An SQL-session involves an SQL-agent, an     SQL-client, and a single SQL-server.     &lt;module&gt;s associated with the SQL-agent exist in the SQL-     environment containing the SQL-client associated with the SQL-     agent.     Called &lt;procedure&gt;s (and, analogously, &lt;direct SQL statement&gt;s)     containing an &lt;SQL connection statement&gt; or an &lt;SQL diagnostics     statement&gt; are processed by the SQL-client. Following the suc-     cessful execution of a &lt;connect statement&gt; or a &lt;set connection     statement&gt;, the &lt;module&gt;s associated with the SQL-agent are ef-     fectively materialized with an implementation-dependent &lt;module     name&gt; in the SQL-server. Other called &lt;procedure&gt;s and &lt;direct SQL     statement&gt;s are processed by the SQL-server.     A call by the SQL-agent to a &lt;procedure&gt; containing an &lt;SQL di-     agnostics statement&gt; fetches information from the diagnostics     area associated with the SQL-client. Following the execution of     an &lt;SQL procedure statement&gt; by an SQL-server, diagnostic in-     formation is passed in an implementation-dependent manner into     the SQL-agent&#39;s diagnostics area in the SQL-client. The effect     on diagnostic information of incompatibilities between the char-     acter repertoires supported by the SQL-client and SQL-server is     implementation-dependent.     74  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                 4.32 Information Schema     4.32  Information Schema     In each catalog in an SQL-environment, there is a schema, the     Information Schema, with the name INFORMATION_SCHEMA, contain-     ing a number of view descriptors, one base table descriptor ,     and several domain descriptors. The data accessible through these     views is a representation of all of the descriptors in all of the     schemas in that catalog. The &lt;query expression&gt; of each view en-     sures that a given user can access only those rows of the view     that represent descriptors on which he has privileges. The rows     of each view are required to represent correctly the descriptors     in the catalog as they existed at the start of the current SQL-     transaction, as modified subsequently by any changes made by the     current SQL-transaction. The SELECT privilege is granted on each     of the Information Schema views to PUBLIC WITH GRANT OPTION so they     can be queried by any user and so that the SELECT privilege can     be further granted on views that reference the Information Schema     views. No further privilege is granted on them, so they cannot be     updated.     The viewed tables in INFORMATION_SCHEMA are defined in terms of     a collection of base tables in a schema named DEFINITION_SCHEMA,     the Definition Schema. The only purpose of the definition of these     base tables is to provide a data model to support the Information     Schema. An implementation need do no more than simulate the exis-     tence of the base tables as viewed through the Information Schema     views.     The Information Schema describes itself. It does not describe the     base tables or views of the Definition Schema. If an implemen-     tation has defined additional objects that are associated with     INFORMATION_SCHEMA, then those objects shall also be described in     the Information Schema views.     4.33  Leveling     Three levels of conformance are specified in this International     Standard.     Entry SQL includes the statements for defining schemas, data ma-     nipulation language, referential integrity, check constraints, and     default clause from ISO/IEC 9075:1989, and options for module lan-     guage and embedded SQL interfaces to seven different programming     languages, as well as direct execution of the data manipulation     statements. It also includes features related to deprecated fea-     tures from ISO/IEC 9075:1989 (commas and parentheses in parameter     lists, the SQLSTATE parameter, and renaming columns in the &lt;se-     lect list&gt;), features related to incompatibilities with ISO/IEC     9075:1989 (colons preceding &lt;parameter name&gt;s, WITH CHECK OPTION     constraint clarifications), and aids for transitioning from ISO/IEC     9075:1989 to this International Standard (&lt;delimited identifier&gt;s).                                                           Concepts   75</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     4.33 Leveling     Finally, it contains changes to correct defects found in ISO/IEC     9075:1989 (see Annex F, &quot;Maintenance and interpretation of SQL&quot;).     Intermediate SQL includes major new facilities such as statements     for changing schemas, dynamic SQL, and isolation levels for SQL-     transactions. It also includes multiple-module support and cascade     delete on referential actions, as well as numerous functional en-     hancements such as row and table expressions, union join, character     string operations, table intersection and difference operations,     simple domains, the CASE expression, casting between data types,     a diagnostics management capability for data administration and     more comprehensive error analysis, multiple character repertoires,     interval and simplified datetime data types, and variable-length     character strings. It also includes a requirement for a flagger     facility to aid in writing portable applications.     Full SQL increases orthogonality and includes deferred constraint     checking and named constraints. Other technical enhancements in-     clude additional user options to define datetime data types,     self-referencing updates and deletes, cascade update on referen-     tial actions, subqueries in check constraints, scrolled cursors,     character translations, a bit string data type, temporary tables,     additional referential constraint options, and simple assertions.     4.34  SQL Flagger     An SQL Flagger is an implementation-provided facility that is able     to identify SQL language extensions, or other SQL processing al-     ternatives, that may be provided by a conforming SQL-implementation     (see Subclause 23.3, &quot;Extensions and options&quot;). An SQL Flagger     is intended to assist SQL programmers in producing SQL language     that is both portable and interoperable among different conform-     ing SQL-implementations operating under different levels of this     International Standard.     An SQL Flagger is intended to effect a static check of SQL lan-     guage. There is no requirement to detect extensions that cannot be     determined until the General Rules are evaluated.     An SQL-implementation need only flag SQL language that is not oth-     erwise in error as far as that implementation is concerned.     Note: If a system is processing SQL language that contains er-     rors, then it may be very difficult within a single statement to     determine what is an error and what is an extension. As one pos-     sibility, an implementation may choose to check SQL language in     two steps; first through its normal syntax analyzer and secondly     through the SQL Flagger. The first step produces error messages     for nonstandard SQL language that the implementation cannot process     or recognize. The second step processes SQL language that contains     no errors as far as that implementation is concerned; it detects     and flags at one time all nonstandard SQL language that could be     processed by that implementation. Any such two-step process should     be transparent to the end user.     76  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                        4.34 SQL Flagger     In order to provide upward compatibility for its own customer base,     or to provide performance advantages under special circumstances, a     conforming SQL-implementation may provide user options to process     conforming SQL language in a nonconforming manner. If this is the     case, then it is required that the implementation also provide a     flagger option, or some other implementation-defined means, to     detect SQL conforming language that may be processed differently     under the various user options. This flagger feature allows an     application programmer to identify conforming SQL language that may     perform differently in alternative processing environments provided     by a conforming SQL-implementation. It also provides a valuable     tool in identifying SQL elements that may have to be modified if     SQL language is to be moved from a nonconforming to a conforming     SQL processing environment.     An SQL Flagger provides one or more of the following &quot;level of     flagging&quot; options:     -  Entry SQL Flagging     -  Intermediate SQL Flagging     -  Full SQL Flagging     An SQL Flagger that provides one of these options shall be able to     identify SQL language constructs that violate the indicated level     of SQL language as defined in Subclause 4.33, &quot;Leveling&quot;.     An SQL Flagger provides one or more of the following &quot;extent of     checking&quot; options:     -  Syntax Only     -  Catalog Lookup     Under the Syntax Only option, the SQL Flagger analyzes only the SQL     language that is presented; it checks for violations of any Syntax     Rules that can be determined without access to the Information     Schema.     Under the Catalog Lookup option, the SQL Flagger assumes the avail-     ability of Definition Schema information and checks for violations     of all Syntax Rules and Access Rules, except Access Rules that deal     with privileges. For example, some Syntax Rules place restrictions     on data types; this flagger option would identify extensions that     relax such restrictions. In order to avoid security breaches, this     option may view the Definition Schema only through the eyes of a     specific Information Schema.                                                           Concepts   77</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     78  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002     5  Lexical elements     5.1  &lt;SQL terminal character&gt;     Function     Define the terminal symbols of the SQL language and the elements of     strings.     Format     &lt;SQL terminal character&gt; ::=            &lt;SQL language character&gt;          | &lt;SQL embedded language character&gt;     &lt;SQL embedded language character&gt; ::=            &lt;left bracket&gt;          | &lt;right bracket&gt;     &lt;SQL language character&gt; ::=            &lt;simple Latin letter&gt;          | &lt;digit&gt;          | &lt;SQL special character&gt;     &lt;simple Latin letter&gt; ::=            &lt;simple Latin upper case letter&gt;          | &lt;simple Latin lower case letter&gt;     &lt;simple Latin upper case letter&gt; ::=                A | B | C | D | E | F | G | H | I | J | K | L | M | N | O          | P | Q | R | S | T | U | V | W | X | Y | Z     &lt;simple Latin lower case letter&gt; ::=                a | b | c | d | e | f | g | h | i | j | k | l | m | n | o          | p | q | r | s | t | u | v | w | x | y | z     &lt;digit&gt; ::=          0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9     &lt;SQL special character&gt; ::=            &lt;space&gt;          | &lt;double quote&gt;          | &lt;percent&gt;          | &lt;ampersand&gt;          | &lt;quote&gt;          | &lt;left paren&gt;          | &lt;right paren&gt;          | &lt;asterisk&gt;                                                   Lexical elements   79</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.1 &lt;SQL terminal character&gt;          | &lt;plus sign&gt;          | &lt;comma&gt;          | &lt;minus sign&gt;          | &lt;period&gt;          | &lt;solidus&gt;          | &lt;colon&gt;          | &lt;semicolon&gt;          | &lt;less than operator&gt;          | &lt;equals operator&gt;          | &lt;greater than operator&gt;          | &lt;question mark&gt;          | &lt;underscore&gt;          | &lt;vertical bar&gt;     &lt;space&gt; ::= !! space character in character set in use     &lt;double quote&gt; ::= &quot;     &lt;percent&gt; ::= %     &lt;ampersand&gt; ::= &amp;     &lt;quote&gt; ::= &#39;     &lt;left paren&gt; ::= (     &lt;right paren&gt; ::= )     &lt;asterisk&gt; ::= *     &lt;plus sign&gt; ::= +     &lt;comma&gt; ::= ,     &lt;minus sign&gt; ::= -     &lt;period&gt; ::= .     &lt;solidus&gt; ::= /     &lt;colon&gt; ::= :     &lt;semicolon&gt; ::= ;     &lt;less than operator&gt; ::= &lt;     &lt;equals operator&gt; ::= =     &lt;greater than operator&gt; ::= &gt;     &lt;question mark&gt; ::= ?     &lt;left bracket&gt; ::= [     80  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                            5.1 &lt;SQL terminal character&gt;     &lt;right bracket&gt; ::= ]     &lt;underscore&gt; ::= _     &lt;vertical bar&gt; ::= |     Syntax Rules        None.     Access Rules        None.     General Rules     1) There is a one-to-one correspondence between the symbols con-        tained in &lt;simple Latin upper case letter&gt; and the symbols        contained in &lt;simple Latin lower case letter&gt; such that, for        all i, the symbol defined as the i-th alternative for &lt;simple        Latin upper case letter&gt; corresponds to the symbol defined as        the i-th alternative for &lt;simple Latin lower case letter&gt;.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:          None.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:          None.                                                   Lexical elements   81</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.2 &lt;token&gt; and &lt;separator&gt;     5.2  &lt;token&gt; and &lt;separator&gt;     Function     Specify lexical units (tokens and separators) that participate in     SQL language.     Format     &lt;token&gt; ::=            &lt;nondelimiter token&gt;          | &lt;delimiter token&gt;     &lt;nondelimiter token&gt; ::=            &lt;regular identifier&gt;          | &lt;key word&gt;          | &lt;unsigned numeric literal&gt;          | &lt;national character string literal&gt;          | &lt;bit string literal&gt;          | &lt;hex string literal&gt;     &lt;regular identifier&gt; ::= &lt;identifier body&gt;     &lt;identifier body&gt; ::=          &lt;identifier start&gt; [ &#123; &lt;underscore&gt; | &lt;identifier part&gt; &#125;... ]     &lt;identifier start&gt; ::= !! See the Syntax Rules     &lt;identifier part&gt; ::=            &lt;identifier start&gt;          | &lt;digit&gt;     &lt;delimited identifier&gt; ::=          &lt;double quote&gt; &lt;delimited identifier body&gt; &lt;double quote&gt;     &lt;delimited identifier body&gt; ::= &lt;delimited identifier part&gt;...     &lt;delimited identifier part&gt; ::=            &lt;nondoublequote character&gt;          | &lt;doublequote symbol&gt;     &lt;nondoublequote character&gt; ::= !! See the Syntax Rules     &lt;doublequote symbol&gt; ::= &lt;double quote&gt;&lt;double quote&gt;     &lt;delimiter token&gt; ::=            &lt;character string literal&gt;          | &lt;date string&gt;          | &lt;time string&gt;          | &lt;timestamp string&gt;          | &lt;interval string&gt;          | &lt;delimited identifier&gt;     82  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                             5.2 &lt;token&gt; and &lt;separator&gt;          | &lt;SQL special character&gt;          | &lt;not equals operator&gt;          | &lt;greater than or equals operator&gt;          | &lt;less than or equals operator&gt;          | &lt;concatenation operator&gt;          | &lt;double period&gt;          | &lt;left bracket&gt;          | &lt;right bracket&gt;     &lt;not equals operator&gt; ::= &lt;&gt;     &lt;greater than or equals operator&gt; ::= &gt;=     &lt;less than or equals operator&gt; ::= &lt;=     &lt;concatenation operator&gt; ::= ||     &lt;double period&gt; ::= ..     &lt;separator&gt; ::= &#123; &lt;comment&gt; | &lt;space&gt; | &lt;newline&gt; &#125;...     &lt;comment&gt; ::=          &lt;comment introducer&gt; [ &lt;comment character&gt;... ] &lt;newline&gt;     &lt;comment character&gt; ::=            &lt;nonquote character&gt;          | &lt;quote&gt;     &lt;comment introducer&gt; ::= &lt;minus sign&gt;&lt;minus sign&gt;[&lt;minus sign&gt;...]     &lt;newline&gt; ::= !! implementation-defined end-of-line indicator     &lt;key word&gt; ::=            &lt;reserved word&gt;          | &lt;non-reserved word&gt;     &lt;non-reserved word&gt; ::=            ADA          | C | CATALOG_NAME | CHARACTER_SET_CATALOG | CHARACTER_SET_          NAME          | CHARACTER_SET_SCHEMA | CLASS_ORIGIN | COBOL | COLLATION_          CATALOG          | COLLATION_NAME | COLLATION_SCHEMA | COLUMN_NAME | COMMAND_          FUNCTION | COMMITTED          | CONDITION_NUMBER | CONNECTION_NAME | CONSTRAINT_CATALOG | CONSTRAINT_          NAME          | CONSTRAINT_SCHEMA | CURSOR_NAME          | DATA | DATETIME_INTERVAL_CODE | DATETIME_INTERVAL_          PRECISION | DYNAMIC_FUNCTION          | FORTRAN          | LENGTH          | MESSAGE_LENGTH | MESSAGE_OCTET_LENGTH | MESSAGE_TEXT | MORE | MUMPS                                                   Lexical elements   83</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.2 &lt;token&gt; and &lt;separator&gt;          | NAME | NULLABLE | NUMBER          | PASCAL | PLI          | REPEATABLE | RETURNED_LENGTH | RETURNED_OCTET_LENGTH | RETURNED_          SQLSTATE          | ROW_COUNT          | SCALE | SCHEMA_NAME | SERIALIZABLE | SERVER_NAME | SUBCLASS_          ORIGIN          | TABLE_NAME | TYPE          | UNCOMMITTED | UNNAMED     &lt;reserved word&gt; ::=            ABSOLUTE | ACTION | ADD | ALL | ALLOCATE | ALTER | AND          | ANY | ARE | AS | ASC          | ASSERTION | AT | AUTHORIZATION | AVG          | BEGIN | BETWEEN | BIT | BIT_LENGTH | BOTH | BY          | CASCADE | CASCADED | CASE | CAST | CATALOG | CHAR | CHARACTER | CHAR_          LENGTH          | CHARACTER_LENGTH | CHECK | CLOSE | COALESCE | COLLATE | COLLATION          | COLUMN | COMMIT | CONNECT | CONNECTION | CONSTRAINT          | CONSTRAINTS | CONTINUE          | CONVERT | CORRESPONDING | COUNT | CREATE | CROSS | CURRENT          | CURRENT_DATE | CURRENT_TIME | CURRENT_TIMESTAMP | CURRENT_          USER | CURSOR          | DATE | DAY | DEALLOCATE | DEC | DECIMAL | DECLARE | DEFAULT | DEFERRABLE          | DEFERRED | DELETE | DESC | DESCRIBE | DESCRIPTOR | DIAGNOSTICS          | DISCONNECT | DISTINCT | DOMAIN | DOUBLE | DROP          | ELSE | END | END-EXEC | ESCAPE | EXCEPT | EXCEPTION          | EXEC | EXECUTE | EXISTS          | EXTERNAL | EXTRACT          | FALSE | FETCH | FIRST | FLOAT | FOR | FOREIGN | FOUND | FROM | FULL          | GET | GLOBAL | GO | GOTO | GRANT | GROUP          | HAVING | HOUR          | IDENTITY | IMMEDIATE | IN | INDICATOR | INITIALLY | INNER | INPUT          | INSENSITIVE | INSERT | INT | INTEGER | INTERSECT | INTERVAL | INTO | IS          | ISOLATION          | JOIN          | KEY          | LANGUAGE | LAST | LEADING | LEFT | LEVEL | LIKE | LOCAL | LOWER          | MATCH | MAX | MIN | MINUTE | MODULE | MONTH          | NAMES | NATIONAL | NATURAL | NCHAR | NEXT | NO | NOT | NULL          | NULLIF | NUMERIC          | OCTET_LENGTH | OF | ON | ONLY | OPEN | OPTION | OR          | ORDER | OUTER          | OUTPUT | OVERLAPS     84  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                             5.2 &lt;token&gt; and &lt;separator&gt;          | PAD | PARTIAL | POSITION | PRECISION | PREPARE | PRESERVE | PRIMARY          | PRIOR | PRIVILEGES | PROCEDURE | PUBLIC          | READ | REAL | REFERENCES | RELATIVE | RESTRICT | REVOKE | RIGHT          | ROLLBACK | ROWS          | SCHEMA | SCROLL | SECOND | SECTION | SELECT | SESSION | SESSION_          USER | SET          | SIZE | SMALLINT | SOME | SPACE | SQL | SQLCODE | SQLERROR | SQLSTATE          | SUBSTRING | SUM | SYSTEM_USER          | TABLE | TEMPORARY | THEN | TIME | TIMESTAMP | TIMEZONE_          HOUR | TIMEZONE_MINUTE          | TO | TRAILING | TRANSACTION | TRANSLATE | TRANSLATION | TRIM | TRUE          | UNION | UNIQUE | UNKNOWN | UPDATE | UPPER | USAGE | USER | USING          | VALUE | VALUES | VARCHAR | VARYING | VIEW          | WHEN | WHENEVER | WHERE | WITH | WORK | WRITE          | YEAR          | ZONE     Note: The list of &lt;reserved word&gt;s is considerably longer than     the analogous list of &lt;key word&gt;s in ISO/IEC 9075:1989. To assist     users of this International Standard avoid such words in a possible     future revision, the following list of potential &lt;reserved word&gt;s     is provided. Readers must understand that there is no guarantee     that all of these words will, in fact, become &lt;reserved word&gt;s     in any future revision; furthermore, it is almost certain that     additional words will be added to this list as any possible future     revision emerges.      The words are: AFTER, ALIAS, ASYNC, BEFORE, BOOLEAN, BREADTH,     COMPLETION, CALL, CYCLE, DATA, DEPTH, DICTIONARY, EACH, ELSEIF,     EQUALS, GENERAL, IF, IGNORE, LEAVE, LESS, LIMIT, LOOP, MODIFY,     NEW, NONE, OBJECT, OFF, OID, OLD, OPERATION, OPERATORS, OTHERS,     PARAMETERS, PENDANT, PREORDER, PRIVATE, PROTECTED, RECURSIVE, REF,     REFERENCING, REPLACE, RESIGNAL, RETURN, RETURNS, ROLE, ROUTINE,     ROW, SAVEPOINT, SEARCH, SENSITIVE, SEQUENCE, SIGNAL, SIMILAR,     SQLEXCEPTION, SQLWARNING, STRUCTURE, TEST, THERE, TRIGGER, TYPE,     UNDER, VARIABLE, VIRTUAL, VISIBLE, WAIT, WHILE, and WITHOUT.     Syntax Rules     1) An &lt;identifier start&gt; is one of:        a) A &lt;simple Latin letter&gt;; or        b) A character that is identified as a letter in the character          repertoire identified by the &lt;module character set specifica-          tion&gt; or by the &lt;character set specification&gt;; or                                                   Lexical elements   85</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.2 &lt;token&gt; and &lt;separator&gt;        c) A character that is identified as a syllable in the char-          acter repertoire identified by the &lt;module character set          specification&gt; or by the &lt;character set specification&gt;; or        d) A character that is identified as an ideograph in the char-          acter repertoire identified by the &lt;module character set          specification&gt; or by the &lt;character set specification&gt;.     2) With the exception of the &lt;space&gt; character explicitly contained        in &lt;timestamp string&gt; and &lt;interval string&gt; and the permitted        &lt;separator&gt;s in &lt;bit string literal&gt;s and &lt;hex string literal&gt;s,        a &lt;token&gt;, other than a &lt;character string literal&gt;, a &lt;national        character string literal&gt;, or a &lt;delimited identifier&gt;, shall        not include a &lt;space&gt; character or other &lt;separator&gt;.     3) A &lt;nondoublequote character&gt; is one of:        a) Any &lt;SQL language character&gt; other than a &lt;double quote&gt;;        b) Any character other than a &lt;double quote&gt; in the character          repertoire identified by the &lt;module character set specifica-          tion&gt;; or        c) Any character other than a &lt;double quote&gt; in the character          repertoire identified by the &lt;character set specification&gt;.     4) The two &lt;doublequote&gt;s contained in a &lt;doublequote symbol&gt; shall        not be separated by any &lt;separator&gt;.     5) Any &lt;token&gt; may be followed by a &lt;separator&gt;. A &lt;nondelimiter        token&gt; shall be followed by a &lt;delimiter token&gt; or a &lt;separa-        tor&gt;. If the Format does not allow a &lt;nondelimiter token&gt; to be        followed by a &lt;delimiter token&gt;, then that &lt;nondelimiter token&gt;        shall be followed by a &lt;separator&gt;.     6) There shall be no &lt;space&gt; nor &lt;newline&gt; separating the &lt;minus        sign&gt;s of a &lt;comment introducer&gt;.     7) SQL text containing one or more instances of &lt;comment&gt; is equiv-        alent to the same SQL text with the &lt;comment&gt; replaced with        &lt;newline&gt;.     8) The sum of the number of &lt;identifier start&gt;s and the number        of &lt;identifier part&gt;s in a &lt;regular identifier&gt; shall not be        greater than 128.     9) The &lt;delimited identifier body&gt; of a &lt;delimited identifier&gt;        shall not comprise more than 128 &lt;delimited identifier part&gt;s.     10)The &lt;identifier body&gt; of a &lt;regular identifier&gt; is equivalent        to an &lt;identifier body&gt; in which every letter that is a lower-        case letter is replaced by the equivalent upper-case letter        or letters. This treatment includes determination of equiva-        lence, representation in the Information and Definition Schemas,        representation in the diagnostics area, and similar uses.     86  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                             5.2 &lt;token&gt; and &lt;separator&gt;     11)The &lt;identifier body&gt; of a &lt;regular identifier&gt; (with every        letter that is a lower-case letter replaced by the equivalent        upper-case letter or letters), treated as the repetition of        a &lt;character string literal&gt; that specifies a &lt;character set        specification&gt; of SQL_TEXT, shall not be equal, according to        the comparison rules in Subclause 8.2, &quot;&lt;comparison predicate&gt;&quot;,        to any &lt;reserved word&gt; (with every letter that is a lower-case        letter replaced by the equivalent upper-case letter or letters),        treated as the repetition of a &lt;character string literal&gt; that        specifies a &lt;character set specification&gt; of SQL_TEXT.        Note: It is the intention that no &lt;key word&gt; specified in this        International Standard or revisions thereto shall end with an        &lt;underscore&gt;.     12)Two &lt;regular identifier&gt;s are equivalent if their &lt;identifier        body&gt;s, considered as the repetition of a &lt;character string        literal&gt; that specifies a &lt;character set specification&gt; of        SQL_TEXT, compare equally according to the comparison rules        in Subclause 8.2, &quot;&lt;comparison predicate&gt;&quot;.     13)A &lt;regular identifier&gt; and a &lt;delimited identifier&gt; are equiva-        lent if the &lt;identifier body&gt; of the &lt;regular identifier&gt; (with        every letter that is a lower-case letter replaced by the equiva-        lent upper-case letter or letters) and the &lt;delimited identifier        body&gt; of the &lt;delimited identifier&gt; (with all occurrences of        &lt;quote&gt; replaced by &lt;quote symbol&gt; and all occurrences of &lt;dou-        blequote symbol&gt; replaced by &lt;double quote&gt;), considered as        the repetition of a &lt;character string literal&gt; that specifies a        &lt;character set specification&gt; of SQL_TEXT and an implementation-        defined collation that is sensitive to case, compare equally        according to the comparison rules in Subclause 8.2, &quot;&lt;comparison        predicate&gt;&quot;.     14)Two &lt;delimited identifier&gt;s are equivalent if their &lt;delimited        identifier body&gt;s (with all occurrences of &lt;quote&gt; replaced        by &lt;quote symbol&gt; and all occurrences of &lt;doublequote symbol&gt;        replaced by &lt;doublequote&gt;), considered as the repetition of a        &lt;character string literal&gt; that specifies a &lt;character set spec-        ification&gt; of SQL_TEXT and an implementation-defined collation        that is sensitive to case, compare equally according to the        comparison rules in Subclause 8.2, &quot;&lt;comparison predicate&gt;&quot;.     15)For the purposes of identifying &lt;key word&gt;s, any &lt;simple Latin        lower case letter&gt; contained in a candidate &lt;key word&gt; shall        be effectively treated as the corresponding &lt;simple Latin upper        case letter&gt;.     Access Rules        None.                                                   Lexical elements   87</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.2 &lt;token&gt; and &lt;separator&gt;     General Rules        None.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) No &lt;identifier body&gt; shall end in an &lt;underscore&gt;.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) No &lt;regular identifier&gt; or &lt;delimited identifier body&gt; shall          contain more than 18 &lt;character representation&gt;s.        b) An &lt;identifier body&gt; shall contain no &lt;simple Latin lower          case letter&gt;.     88  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                           5.3 &lt;literal&gt;     5.3  &lt;literal&gt;     Function     Specify a non-null value.     Format     &lt;literal&gt; ::=            &lt;signed numeric literal&gt;          | &lt;general literal&gt;     &lt;unsigned literal&gt; ::=            &lt;unsigned numeric literal&gt;          | &lt;general literal&gt;     &lt;general literal&gt; ::=            &lt;character string literal&gt;          | &lt;national character string literal&gt;          | &lt;bit string literal&gt;          | &lt;hex string literal&gt;          | &lt;datetime literal&gt;          | &lt;interval literal&gt;     &lt;character string literal&gt; ::=          [ &lt;introducer&gt;&lt;character set specification&gt; ]          &lt;quote&gt; [ &lt;character representation&gt;... ] &lt;quote&gt;            [ &#123; &lt;separator&gt;... &lt;quote&gt; [ &lt;character representation&gt;... ] &lt;quote&gt; &#125;... ]     &lt;introducer&gt; ::= &lt;underscore&gt;     &lt;character representation&gt; ::=            &lt;nonquote character&gt;          | &lt;quote symbol&gt;     &lt;nonquote character&gt; ::= !! See the Syntax Rules.     &lt;quote symbol&gt; ::= &lt;quote&gt;&lt;quote&gt;     &lt;national character string literal&gt; ::=          N &lt;quote&gt; [ &lt;character representation&gt;... ] &lt;quote&gt;            [ &#123; &lt;separator&gt;... &lt;quote&gt; [ &lt;character representation&gt;... ] &lt;quote&gt; &#125;... ]     &lt;bit string literal&gt; ::=          B &lt;quote&gt; [ &lt;bit&gt;... ] &lt;quote&gt;            [ &#123; &lt;separator&gt;... &lt;quote&gt; [ &lt;bit&gt;... ] &lt;quote&gt; &#125;... ]     &lt;hex string literal&gt; ::=          X &lt;quote&gt; [ &lt;hexit&gt;... ] &lt;quote&gt;            [ &#123; &lt;separator&gt;... &lt;quote&gt; [ &lt;hexit&gt;... ] &lt;quote&gt; &#125;... ]                                                   Lexical elements   89</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.3 &lt;literal&gt;     &lt;bit&gt; ::= 0 | 1     &lt;hexit&gt; ::= &lt;digit&gt; | A | B | C | D | E | F | a | b | c | d | e | f     &lt;signed numeric literal&gt; ::=          [ &lt;sign&gt; ] &lt;unsigned numeric literal&gt;     &lt;unsigned numeric literal&gt; ::=            &lt;exact numeric literal&gt;          | &lt;approximate numeric literal&gt;     &lt;exact numeric literal&gt; ::=            &lt;unsigned integer&gt; [ &lt;period&gt; [ &lt;unsigned integer&gt; ] ]          | &lt;period&gt; &lt;unsigned integer&gt;     &lt;sign&gt; ::= &lt;plus sign&gt; | &lt;minus sign&gt;     &lt;approximate numeric literal&gt; ::= &lt;mantissa&gt; E &lt;exponent&gt;     &lt;mantissa&gt; ::= &lt;exact numeric literal&gt;     &lt;exponent&gt; ::= &lt;signed integer&gt;     &lt;signed integer&gt; ::= [ &lt;sign&gt; ] &lt;unsigned integer&gt;     &lt;unsigned integer&gt; ::= &lt;digit&gt;...     &lt;datetime literal&gt; ::=            &lt;date literal&gt;          | &lt;time literal&gt;          | &lt;timestamp literal&gt;     &lt;date literal&gt; ::=          DATE &lt;date string&gt;     &lt;time literal&gt; ::=          TIME &lt;time string&gt;     &lt;timestamp literal&gt; ::=          TIMESTAMP &lt;timestamp string&gt;     &lt;date string&gt; ::=          &lt;quote&gt; &lt;date value&gt; &lt;quote&gt;     &lt;time string&gt; ::=          &lt;quote&gt; &lt;time value&gt; [ &lt;time zone interval&gt; ] &lt;quote&gt;     &lt;timestamp string&gt; ::=          &lt;quote&gt; &lt;date value&gt; &lt;space&gt; &lt;time value&gt; [ &lt;time zone interval&gt; ] &lt;quote&gt;     &lt;time zone interval&gt; ::=     90  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                           5.3 &lt;literal&gt;          &lt;sign&gt; &lt;hours value&gt; &lt;colon&gt; &lt;minutes value&gt;     &lt;date value&gt; ::=          &lt;years value&gt; &lt;minus sign&gt; &lt;months value&gt; &lt;minus sign&gt; &lt;days value&gt;     &lt;time value&gt; ::=          &lt;hours value&gt; &lt;colon&gt; &lt;minutes value&gt; &lt;colon&gt; &lt;seconds value&gt;     &lt;interval literal&gt; ::=          INTERVAL [ &lt;sign&gt; ] &lt;interval string&gt; &lt;interval qualifier&gt;     &lt;interval string&gt; ::=          &lt;quote&gt; &#123; &lt;year-month literal&gt; | &lt;day-time literal&gt; &#125; &lt;quote&gt;     &lt;year-month literal&gt; ::=            &lt;years value&gt;          | [ &lt;years value&gt; &lt;minus sign&gt; ] &lt;months value&gt;     &lt;day-time literal&gt; ::=            &lt;day-time interval&gt;          | &lt;time interval&gt;     &lt;day-time interval&gt; ::=          &lt;days value&gt;            [ &lt;space&gt; &lt;hours value&gt; [ &lt;colon&gt; &lt;minutes value&gt; [ &lt;colon&gt; &lt;seconds value&gt; ] ] ]     &lt;time interval&gt; ::=            &lt;hours value&gt; [ &lt;colon&gt; &lt;minutes value&gt; [ &lt;colon&gt; &lt;seconds value&gt; ] ]          | &lt;minutes value&gt; [ &lt;colon&gt; &lt;seconds value&gt; ]          | &lt;seconds value&gt;     &lt;years value&gt; ::= &lt;datetime value&gt;     &lt;months value&gt; ::= &lt;datetime value&gt;     &lt;days value&gt; ::= &lt;datetime value&gt;     &lt;hours value&gt; ::= &lt;datetime value&gt;     &lt;minutes value&gt; ::= &lt;datetime value&gt;     &lt;seconds value&gt; ::=            &lt;seconds integer value&gt; [ &lt;period&gt; [ &lt;seconds fraction&gt; ] ]     &lt;seconds integer value&gt; ::= &lt;unsigned integer&gt;     &lt;seconds fraction&gt; ::= &lt;unsigned integer&gt;                                                   Lexical elements   91</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.3 &lt;literal&gt;     &lt;datetime value&gt; ::= &lt;unsigned integer&gt;     Syntax Rules     1) In a &lt;character string literal&gt; or &lt;national character string        literal&gt;, the sequence:          &lt;quote&gt; &lt;character representation&gt;... &lt;quote&gt;          &lt;separator&gt;... &lt;quote&gt; &lt;character representation&gt;... &lt;quote&gt;        is equivalent to the sequence          &lt;quote&gt; &lt;character representation&gt;... &lt;character representa-          tion&gt;... &lt;quote&gt;        Note: The &lt;character representation&gt;s in the equivalent se-        quence are in the same sequence and relative sequence as in the        original &lt;character string literal&gt;.     2) In a &lt;bit string literal&gt;, the sequence          &lt;quote&gt; &lt;bit&gt;... &lt;quote&gt; &lt;separator&gt;... &lt;quote&gt; &lt;bit&gt;...          &lt;quote&gt;        is equivalent to the sequence          &lt;quote&gt; &lt;bit&gt;... &lt;bit&gt;... &lt;quote&gt;        Note: The &lt;bit&gt;s in the equivalent sequence are in the same        sequence and relative sequence as in the original &lt;bit string        literal&gt;.     3) In a &lt;hex string literal&gt;, the sequence          &lt;quote&gt; &lt;hexit&gt;... &lt;quote&gt; &lt;separator&gt;... &lt;quote&gt; &lt;hexit&gt;...          &lt;quote&gt;        is equivalent to the sequence          &lt;quote&gt; &lt;hexit&gt;... &lt;hexit&gt;... &lt;quote&gt;        Note: The &lt;hexit&gt;s in the equivalent sequence are in the same        sequence and relative sequence as in the original &lt;hex string        literal&gt;.     4) In a &lt;character string literal&gt;, &lt;national character string        literal&gt;, &lt;bit string literal&gt;, or &lt;hex string literal&gt;, a &lt;sep-        arator&gt; shall contain a &lt;newline&gt;.     5) A &lt;nonquote character&gt; is one of:        a) Any &lt;SQL language character&gt; other than a &lt;quote&gt;;        b) Any character other than a &lt;quote&gt; in the character reper-          toire identified by the &lt;module character set specification&gt;;          or        c) Any character other than a &lt;quote&gt; in the character reper-          toire identified by the &lt;character set specification&gt; or          implied by &quot;N&quot;.     92  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                           5.3 &lt;literal&gt;     6) If a &lt;character set specification&gt; is not specified in a &lt;char-        acter string literal&gt;, then the set of characters contained        in the &lt;character string literal&gt; shall be wholly contained        in either &lt;SQL language character&gt; or the character repertoire        indicated by:        Case:        a) If the &lt;character string literal&gt; is contained in a &lt;module&gt;,          then the &lt;module character set specification&gt;,        b) If the &lt;character string literal&gt; is contained in a &lt;schema          definition&gt; that is not contained in a &lt;module&gt;, then the          &lt;schema character set specification&gt;,        c) If the &lt;character string literal&gt; is contained in a &lt;prepara-          ble statement&gt; that is prepared in the current SQL-session          by an &lt;execute immediate statement&gt; or a &lt;prepare statement&gt;          or in a &lt;direct SQL statement&gt; that is invoked directly, then          the default character set name for the SQL-session.     7) If a &lt;character set specification&gt; is specified in a &lt;character        string literal&gt;, then        a) There shall be no &lt;separator&gt; between the &lt;introducer&gt; and          the &lt;character set specification&gt;.        b) The set of characters contained in the &lt;character string lit-          eral&gt; shall be wholly contained in the character repertoire          indicated by the &lt;character set specification&gt;.     8) A &lt;national character string literal&gt; is equivalent to a        &lt;character string literal&gt; with the &quot;N&quot; replaced by &quot;&lt;intro-        ducer&gt;&lt;character set specification&gt;&quot;, where &quot;&lt;character set        specification&gt;&quot; is an implementation-defined &lt;character set        name&gt;.     9) The data type of a &lt;character string literal&gt; is fixed-length        character string. The length of a &lt;character string literal&gt;        is the number of &lt;character representation&gt;s that it contains.        Each &lt;quote symbol&gt; contained in &lt;character string literal&gt;        represents a single &lt;quote&gt; in both the value and the length of        the &lt;character string literal&gt;. The two &lt;quote&gt;s contained in a        &lt;quote symbol&gt; shall not be separated by any &lt;separator&gt;.        Note: &lt;character string literal&gt;s are allowed to be zero-length        strings (i.e., to contain no characters) even though it is        not permitted to declare a &lt;data type&gt; that is CHARACTER with        &lt;length&gt; zero.     10)The data type of a &lt;bit string literal&gt; is fixed-length bit        string. The length of a &lt;bit string literal&gt; is the number of        bits that it contains.                                                   Lexical elements   93</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.3 &lt;literal&gt;     11)The data type of a &lt;hex string literal&gt; is fixed-length bit        string. Each &lt;hexit&gt; appearing in the literal is equivalent        to a quartet of bits: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C,        D, E, and F are interpreted as 0000, 0001, 0010, 0011, 0100,        0101, 0110, 0111, 1000, 1001, 1010, 1011, 1100, 1101, 1110,        and 1111, respectively. The &lt;hexit&gt;s a, b, c, d, e, and f have        respectively the same values as the &lt;hexit&gt;s A, B, C, D, E, and        F.     12)An &lt;exact numeric literal&gt; without a &lt;period&gt; has an implied        &lt;period&gt; following the last &lt;digit&gt;.     13)The data type of an &lt;exact numeric literal&gt; is exact numeric.        The precision of an &lt;exact numeric literal&gt; is the number of        &lt;digit&gt;s that it contains. The scale of an &lt;exact numeric lit-        eral&gt; is the number of &lt;digit&gt;s to the right of the &lt;period&gt;.     14)The data type of an &lt;approximate numeric literal&gt; is approximate        numeric. The precision of an &lt;approximate numeric literal&gt; is        the precision of its &lt;mantissa&gt;.     15)The data type of a &lt;date literal&gt; is DATE.     16)The data type of a &lt;time literal&gt; that does not specify &lt;time        zone interval&gt; is TIME(P), where P is the number of digits in        &lt;seconds fraction&gt;, if specified, and 0 otherwise. The data        type of a &lt;time literal&gt; that specifies &lt;time zone interval&gt;        is TIME(P) WITH TIME ZONE, where P is the number of digits in        &lt;seconds fraction&gt;, if specified, and 0 otherwise.     17)The data type of a &lt;timestamp literal&gt; that does not specify        &lt;time zone interval&gt; is TIMESTAMP(P), where P is the number of        digits in &lt;seconds fraction&gt;, if specified, and 0 otherwise.        The data type of a &lt;timestamp literal&gt; that specifies &lt;time zone        interval&gt; is TIMESTAMP(P) WITH TIME ZONE, where P is the number        of digits in &lt;seconds fraction&gt;, if specified, and 0 otherwise.     18)If &lt;time zone interval&gt; is not specified, then the effective        &lt;time zone interval&gt; of the datetime data type is the current        default time zone displacement for the SQL-session.     19)Let datetime component be either &lt;years value&gt;, &lt;months value&gt;,        &lt;days value&gt;, &lt;hours value&gt;, &lt;minutes value&gt;, or &lt;seconds        value&gt;.     20)Let N be the number of &lt;datetime field&gt;s in the precision of the        &lt;interval literal&gt;, as specified by &lt;interval qualifier&gt;.        The &lt;interval literal&gt; being defined shall contain N datetime        components.        The data type of &lt;interval literal&gt; specified with an &lt;interval        qualifier&gt; is INTERVAL with the &lt;interval qualifier&gt;.     94  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                           5.3 &lt;literal&gt;     21)Within a &lt;datetime literal&gt;, the &lt;years value&gt; shall contain        four digits. The &lt;seconds integer value&gt; and other datetime        components, with the exception of &lt;seconds fraction&gt;, shall each        contain two digits.     22)Within the definition of a &lt;datetime literal&gt;, the &lt;datetime        value&gt;s are constrained by the natural rules for dates and times        according to the Gregorian calendar.     23)Within the definition of an &lt;interval literal&gt;, the &lt;datetime        value&gt;s are constrained by the natural rules for intervals ac-        cording to the Gregorian calendar.     24)Within the definition of a &lt;year-month literal&gt;, the &lt;inter-        val qualifier&gt; shall not specify DAY, HOUR, MINUTE, or SECOND.        Within the definition of a &lt;day-time literal&gt;, the &lt;interval        qualifier&gt; shall not specify YEAR or MONTH.     25)Within the definition of a &lt;datetime literal&gt;, the value of the        &lt;time zone interval&gt; shall be in the range -12:59 to +13:00.     Access Rules        None.     General Rules     1) The value of a &lt;character string literal&gt; is the sequence of        &lt;character representation&gt;s that it contains.     2) The value of a &lt;bit string literal&gt; or a &lt;hex string literal&gt; is        the sequence of bits that it contains.     3) The numeric value of an &lt;exact numeric literal&gt; is determined        by the normal mathematical interpretation of positional decimal        notation.     4) The numeric value of an &lt;approximate numeric literal&gt; is approx-        imately the product of the exact numeric value represented by        the &lt;mantissa&gt; with the number obtained by raising the number        10 to the power of the exact numeric value represented by the        &lt;exponent&gt;.     5) The &lt;sign&gt; in a &lt;signed numeric literal&gt; or an &lt;interval lit-        eral&gt; is a monadic arithmetic operator. The monadic arithmetic        operators + and - specify monadic plus and monadic minus, re-        spectively. If neither monadic plus nor monadic minus are spec-        ified in a &lt;signed numeric literal&gt; or an &lt;interval literal&gt;,        or if monadic plus is specified, then the literal is positive.        If monadic minus is specified in a &lt;signed numeric literal&gt; or        &lt;interval literal&gt;, then the literal is negative.                                                   Lexical elements   95</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.3 &lt;literal&gt;     6) Let V be the integer value of the &lt;unsigned integer&gt; contained        in &lt;seconds fraction&gt; and let N be the number of digits in the        &lt;seconds fraction&gt; respectively. The resultant value of the        &lt;seconds fraction&gt; is effectively determined as follows:        Case:        a) If &lt;seconds fraction&gt; is specified within the definition of a          &lt;datetime literal&gt;, then the effective value of the &lt;seconds          fraction&gt; is V*10 -N seconds.        b) If &lt;seconds fraction&gt; is specified within the definition of          an &lt;interval literal&gt;, then let M be the &lt;interval fractional          seconds precision&gt; specified in the &lt;interval qualifier&gt;.          Case:          i) If N &lt; M, then let V1 be V *10M-N; the effective value of             the &lt;seconds fraction&gt; is V1*10 -M seconds.         ii) If N &gt; M, then let V2 be the integer part of the quotient             of V /10N-M; the effective value of the &lt;seconds fraction&gt;             is V2*10 -M seconds.        iii) Otherwise, the effective value of the &lt;seconds fraction&gt; is             V*10 -M seconds.     7) The i-th datetime component in a &lt;datetime literal&gt; or &lt;interval        literal&gt; assigns the value of the datetime component to the        i-th &lt;datetime field&gt; in the &lt;datetime literal&gt; or &lt;interval        literal&gt;.     8) If &lt;time zone interval&gt; is specified, then the time and times-        tamp values in &lt;time literal&gt; and &lt;timestamp literal&gt; represent        a datetime in the specified time zone. Otherwise, the time and        timestamp values represent a datetime in the current default        time zone of the SQL-session. The value of the &lt;time literal&gt;        or the &lt;timestamp literal&gt; is effectively the &lt;time value&gt; or        the &lt;date value&gt; and &lt;time value&gt; together minus the &lt;time zone        interval&gt; value, followed by the &lt;time zone interval&gt;.        Note: &lt;time literal&gt;s and &lt;timestamp literal&gt;s are specified in        a time zone chosen by the SQL-agent (the default is the cur-        rent default time zone of the SQL-session). However, they are        effectively converted to UTC while maintaining the &lt;time zone        interval&gt; information that permits knowing the original time        zone value for the time or timestamp value.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) An &lt;unsigned integer&gt; that is a &lt;seconds fraction&gt; shall not          contain more than 6 &lt;digit&gt;s.     96  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                           5.3 &lt;literal&gt;        b) A &lt;general literal&gt; shall not be a &lt;bit string literal&gt; or a          &lt;hex string literal&gt;.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) A &lt;general literal&gt; shall not be a &lt;national character string          literal&gt;.        b) A &lt;general literal&gt; shall not be a &lt;datetime literal&gt; or          &lt;interval literal&gt;.        c) A &lt;character string literal&gt; shall contain at least one          &lt;character representation&gt;.        d) Conforming Entry SQL language shall contain exactly one rep-          etition of &lt;character representation&gt; (that is, it shall          contain exactly one sequence of &quot;&lt;quote&gt; &lt;character represen-          tation&gt;... &lt;quote&gt;&quot;).        e) A &lt;character string literal&gt; shall not specify a &lt;character          set specification&gt;.                                                   Lexical elements   97</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.4 Names and identifiers     5.4  Names and identifiers     Function     Specify names.     Format     &lt;identifier&gt; ::=          [ &lt;introducer&gt;&lt;character set specification&gt; ] &lt;actual identifier&gt;     &lt;actual identifier&gt; ::=            &lt;regular identifier&gt;          | &lt;delimited identifier&gt;     &lt;SQL language identifier&gt; ::=          &lt;SQL language identifier start&gt;            [ &#123; &lt;underscore&gt; | &lt;SQL language identifier part&gt; &#125;... ]     &lt;SQL language identifier start&gt; ::= &lt;simple Latin letter&gt;     &lt;SQL language identifier part&gt; ::=            &lt;simple Latin letter&gt;          | &lt;digit&gt;     &lt;authorization identifier&gt; ::= &lt;identifier&gt;     &lt;table name&gt; ::=            &lt;qualified name&gt;          | &lt;qualified local table name&gt;     &lt;qualified local table name&gt; ::=          MODULE &lt;period&gt; &lt;local table name&gt;     &lt;local table name&gt; ::= &lt;qualified identifier&gt;     &lt;domain name&gt; ::= &lt;qualified name&gt;     &lt;schema name&gt; ::=          [ &lt;catalog name&gt; &lt;period&gt; ] &lt;unqualified schema name&gt;     &lt;unqualified schema name&gt; ::= &lt;identifier&gt;     &lt;catalog name&gt; ::= &lt;identifier&gt;     &lt;qualified name&gt; ::=          [ &lt;schema name&gt; &lt;period&gt; ] &lt;qualified identifier&gt;     &lt;qualified identifier&gt; ::= &lt;identifier&gt;     &lt;column name&gt; ::= &lt;identifier&gt;     98  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                               5.4 Names and identifiers     &lt;correlation name&gt; ::= &lt;identifier&gt;     &lt;module name&gt; ::= &lt;identifier&gt;     &lt;cursor name&gt; ::= &lt;identifier&gt;     &lt;procedure name&gt; ::= &lt;identifier&gt;     &lt;SQL statement name&gt; ::=            &lt;statement name&gt;          | &lt;extended statement name&gt;     &lt;statement name&gt; ::= &lt;identifier&gt;     &lt;extended statement name&gt; ::=          [ &lt;scope option&gt; ] &lt;simple value specification&gt;     &lt;dynamic cursor name&gt; ::=            &lt;cursor name&gt;          | &lt;extended cursor name&gt;     &lt;extended cursor name&gt; ::=          [ &lt;scope option&gt; ] &lt;simple value specification&gt;     &lt;descriptor name&gt; ::=          [ &lt;scope option&gt; ] &lt;simple value specification&gt;     &lt;scope option&gt; ::=            GLOBAL          | LOCAL     &lt;parameter name&gt; ::= &lt;colon&gt; &lt;identifier&gt;     &lt;constraint name&gt; ::= &lt;qualified name&gt;     &lt;collation name&gt; ::= &lt;qualified name&gt;     &lt;character set name&gt; ::= [ &lt;schema name&gt; &lt;period&gt; ] &lt;SQL language identifier&gt;     &lt;translation name&gt; ::= &lt;qualified name&gt;     &lt;form-of-use conversion name&gt; ::= &lt;qualified name&gt;     &lt;connection name&gt; ::= &lt;simple value specification&gt;     &lt;SQL-server name&gt; ::= &lt;simple value specification&gt;     &lt;user name&gt; ::= &lt;simple value specification&gt;                                                   Lexical elements   99</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.4 Names and identifiers     Syntax Rules     1) If a &lt;character set specification&gt; is not specified in an &lt;iden-        tifier&gt;, then the set of characters contained in the &lt;identi-        fier&gt; shall be wholly contained in either &lt;SQL language charac-        ter&gt; or the character repertoire identified by:        Case:        a) If the &lt;identifier&gt; is contained in a &lt;module&gt;, then the          &lt;module character set specification&gt;,        b) If the &lt;identifier&gt; is contained in a &lt;schema definition&gt;          that is not contained in a &lt;module&gt;, then the &lt;schema charac-          ter set specification&gt;,        c) If the &lt;identifier&gt; is contained in a &lt;preparable statement&gt;          that is prepared in the current SQL-session by an &lt;execute          immediate statement&gt; or a &lt;prepare statement&gt; or in a &lt;direct          SQL statement&gt; that is invoked directly, then the default          character set name for the SQL-session.     2) If a &lt;character set specification&gt; is specified in an &lt;identi-        fier&gt;, then:        a) There shall be no &lt;separator&gt; between the &lt;introducer&gt; and          the &lt;character set specification&gt;.        b) The set of characters contained in the &lt;identifier body&gt;          or &lt;delimited identifier body&gt; shall be wholly contained          in the character repertoire indicated by the &lt;character set          specification&gt;.     3) The sum of the number of &lt;SQL language identifier start&gt;s and        the number of &lt;SQL language identifier part&gt;s in an &lt;SQL lan-        guage identifier&gt; shall not be greater than 128.     4) An &lt;SQL language identifier&gt; is equivalent to an &lt;SQL language        identifier&gt; in which every letter that is a lower-case letter        is replaced by the equivalent upper-case letter or letters. This        treatment includes determination of equivalence, representation        in the Information and Definition Schemas, representation in the        diagnostics area, and similar uses.     5) An &lt;SQL language identifier&gt; (with every letter that is a lower-        case letter replaced by the equivalent upper-case letter),        treated as the repetition of a &lt;character string literal&gt; that        specifies a &lt;character set specification&gt; of SQL_TEXT, shall not        be equal, according to the comparison rules in Subclause 8.2,        &quot;&lt;comparison predicate&gt;&quot;, to any &lt;reserved word&gt; (with every        letter that is a lower-case letter replaced by the equivalent        upper-case letter), treated as the repetition of a &lt;character        string literal&gt; that specifies a &lt;character set specification&gt;        of SQL_TEXT.     100  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                               5.4 Names and identifiers        Note: It is the intention that no &lt;key word&gt; specified in this        International standard or revisions thereto shall end with an        &lt;underscore&gt;.     6) If &lt;table name&gt; is not a &lt;qualified local table name&gt;, then the        table identified by &lt;table name&gt; shall not be a declared local        temporary table.     7) No &lt;unqualified schema name&gt; shall specify DEFINITION_SCHEMA.     8) If a &lt;qualified name&gt; does not contain a &lt;schema name&gt;, then        Case:        a) If the &lt;qualified name&gt; is contained in a &lt;schema defini-          tion&gt;, then the &lt;schema name&gt; that is specified or implicit          in the &lt;schema definition&gt; is implicit.        b) If the &lt;qualified name&gt; is contained in a &lt;preparable state-          ment&gt; that is prepared in the current SQL-session by an &lt;ex-          ecute immediate statement&gt; or a &lt;prepare statement&gt; or in          a &lt;direct SQL statement&gt; that is invoked directly, then the          default &lt;unqualified schema name&gt; for the SQL-session is          implicit.        c) Otherwise, the &lt;schema name&gt; that is specified or implicit          for the &lt;module&gt; is implicit.     9) If a &lt;schema name&gt; does not contain a &lt;catalog name&gt;, then        Case:        a) If the &lt;unqualified schema name&gt; is contained in a &lt;mod-          ule authorization clause&gt;, then an implementation-defined          &lt;catalog name&gt; is implicit.        b) If the &lt;unqualified schema name&gt; is contained in a &lt;schema          definition&gt; other than in a &lt;schema name clause&gt;, then the          &lt;catalog name&gt; that is specified or implicit in the &lt;schema          name clause&gt; is implicit.        c) If the &lt;unqualified schema name&gt; is contained in a &lt;prepara-          ble statement&gt; that is prepared in the current SQL-session          by an &lt;execute immediate statement&gt; or a &lt;prepare statement&gt;          or in a &lt;direct SQL statement&gt; that is invoked directly, then          the default catalog name for the SQL-session is implicit.        d) If the &lt;unqualified schema name&gt; is contained in a &lt;schema          name clause&gt;, then          Case:          i) If the &lt;schema name clause&gt; is contained in a &lt;module&gt;,             then the explicit or implicit &lt;catalog name&gt; contained in             the &lt;module authorization clause&gt; is implicit.                                                  Lexical elements   101</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.4 Names and identifiers         ii) Otherwise, an implementation-defined &lt;catalog name&gt; is             implicit.        e) Otherwise, the explicit or implicit &lt;catalog name&gt; contained          in the &lt;module authorization clause&gt; is implicit.     10)Two &lt;qualified name&gt;s are equal if and only if they have the        same &lt;qualified identifier&gt; and the same &lt;schema name&gt;, regard-        less of whether the &lt;schema name&gt;s are implicit or explicit.     11)Two &lt;schema name&gt;s are equal if and only if they have the same        &lt;unqualified schema name&gt; and the same &lt;catalog name&gt;, regard-        less of whether the &lt;catalog name&gt;s are implicit or explicit.     12)An &lt;identifier&gt; that is a &lt;correlation name&gt; is associated with        a table within a particular scope. The scope of a &lt;correlation        name&gt; is either a &lt;select statement: single row&gt;, &lt;subquery&gt;, or        &lt;query specification&gt; (see Subclause 6.3, &quot;&lt;table reference&gt;&quot;).        Scopes may be nested. In different scopes, the same &lt;correlation        name&gt; may be associated with different tables or with the same        table.     13)The &lt;simple value specification&gt; of &lt;extended statement name&gt; or        &lt;extended cursor name&gt; shall not be a &lt;literal&gt;.     14)The data type of the &lt;simple value specification&gt; of &lt;ex-        tended statement name&gt; shall be character string with an        implementation-defined character set and shall have an octet        length of 128 octets or less.     15)The data type of the &lt;simple value specification&gt; of &lt;extended        cursor name&gt; shall be character string with an implementation-        defined character set and shall have an octet length of 128        octets or less.     16)The data type of the &lt;simple value specification&gt; of &lt;descriptor        name&gt; shall be character string with an implementation-defined        character set and shall have an octet length of 128 octets or        less.     17)In a &lt;descriptor name&gt;, &lt;extended statement name&gt;, or &lt;extended        cursor name&gt;, if a &lt;scope option&gt; is not specified, then a        &lt;scope option&gt; of LOCAL is implicit.     18)No &lt;authorization identifier&gt; shall specify &quot;PUBLIC&quot;.     19)Those &lt;identifier&gt;s that are valid &lt;authorization identifier&gt;s        are implementation-defined.     20)Those &lt;identifier&gt;s that are valid &lt;catalog name&gt;s are implementation-        defined.     102  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                               5.4 Names and identifiers     21)If a &lt;character set name&gt; does not specify a &lt;schema name&gt;, then        INFORMATION_SCHEMA is implicit.     22)If a &lt;collation name&gt; does not specify a &lt;schema name&gt;, then        INFORMATION_SCHEMA is implicit.     23)If a &lt;translation name&gt; does not specify a &lt;schema name&gt;, then        INFORMATION_SCHEMA is implicit.     24)The &lt;data type&gt; of &lt;SQL-server name&gt;, &lt;connection name&gt;, and        &lt;user name&gt; shall be character string with an implementation-        defined character set and shall have an octet length of 128        octets or less.     25)If a &lt;form-of-use conversion name&gt; does not specify a &lt;schema        name&gt;, then INFORMATION_SCHEMA is implicit; otherwise, INFORMATION_        SCHEMA shall be specified.     Access Rules        None.     General Rules     1) A &lt;table name&gt; identifies a table.     2) Within its scope, a &lt;correlation name&gt; identifies a table.     3) A &lt;local table name&gt; identifies a declared local temporary ta-        ble.     4) A &lt;column name&gt; identifies a column.     5) A &lt;domain name&gt; identifies a domain.     6) An &lt;authorization identifier&gt; represents an authorization iden-        tifier and identifies a set of privileges.     7) A &lt;module name&gt; identifies a &lt;module&gt;.     8) A &lt;cursor name&gt; identifies a cursor.     9) A &lt;procedure name&gt; identifies a &lt;procedure&gt;.     10)A &lt;parameter name&gt; identifies a parameter.     11)A &lt;constraint name&gt; identifies a table constraint, a domain        constraint, or an assertion.     12)A &lt;statement name&gt; identifies a statement prepared by the execu-        tion of a &lt;prepare statement&gt;. The scope of a &lt;statement name&gt;        is the &lt;module&gt; in which it appears and the current SQL-session.                                                  Lexical elements   103</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     5.4 Names and identifiers     13)The value of an &lt;extended statement name&gt; identifies a statement        prepared by the execution of a &lt;prepare statement&gt;. If a &lt;scope        option&gt; of GLOBAL is specified, then the scope of the &lt;extended        statement name&gt; is the current SQL-session. If a &lt;scope option&gt;        of LOCAL is specified or implicit, then the scope of the state-        ment name is further restricted to the &lt;module&gt; in which the        &lt;extended statement name&gt; appears.     14)A &lt;dynamic cursor name&gt; identifies a cursor in an &lt;SQL dynamic        statement&gt;.     15)The value of an &lt;extended cursor name&gt; identifies a cursor cre-        ated by the execution of an &lt;allocate cursor statement&gt;. If a        &lt;scope option&gt; of GLOBAL is specified, then the scope of the        &lt;extended cursor name&gt; is the current SQL-session. If a &lt;scope        option&gt; of LOCAL is specified of implicit, then the scope of the        cursor name is further restricted to the &lt;module&gt; in which the        &lt;extended cursor name&gt; appears.     16)A &lt;descriptor name&gt; identifies an SQL descriptor area created        by the execution of an &lt;allocate descriptor statement&gt;. If a        &lt;scope option&gt; of GLOBAL is specified, then the scope of the        &lt;descriptor name&gt; is the current SQL-session. If a &lt;scope op-        tion&gt; of LOCAL is specified or implicit, then the scope of the        &lt;descriptor name&gt; is further restricted to the &lt;module&gt; in which        the &lt;descriptor name&gt; appears.     17)A &lt;catalog name&gt; identifies a catalog.     18)A &lt;schema name&gt; identifies a schema.     19)A &lt;collation name&gt; identifies a collating sequence.     20)A &lt;character set name&gt; identifies a character set.     21)A &lt;translation name&gt; identifies a character translation.     22)A &lt;form-of-use conversion name&gt; identifies a form-of-use con-        version. All &lt;form-of-use conversion name&gt;s are implementation-        defined.     23)A &lt;connection name&gt; identifies an SQL-connection.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) Conforming Intermediate SQL language shall not contain any          &lt;extended statement name&gt; or &lt;extended cursor name&gt;.        b) Conforming Intermediate SQL language shall not contain any          explicit &lt;catalog name&gt;, &lt;connection name&gt;, &lt;collation name&gt;,          &lt;translation name&gt;, &lt;form-of-use conversion name&gt;, or &lt;quali-          fied local table name&gt;.     104  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                               5.4 Names and identifiers     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) Conforming Entry SQL language shall not contain any &lt;domain          name&gt;, &lt;SQL statement name&gt;, &lt;dynamic cursor name&gt;, &lt;con-          straint name&gt;, &lt;descriptor name&gt;, or &lt;character set name&gt;.        b) An &lt;identifier&gt; shall not specify a &lt;character set specifica-          tion&gt;.                                                  Lexical elements   105</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     106  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002     6  Scalar expressions     6.1  &lt;data type&gt;     Function     Specify a data type.     Format     &lt;data type&gt; ::=            &lt;character string type&gt; [ CHARACTER SET &lt;character set specification&gt; ]          | &lt;national character string type&gt;          | &lt;bit string type&gt;          | &lt;numeric type&gt;          | &lt;datetime type&gt;          | &lt;interval type&gt;     &lt;character string type&gt; ::=            CHARACTER [ &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt; ]          | CHAR [ &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt; ]          | CHARACTER VARYING &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt;          | CHAR VARYING &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt;          | VARCHAR &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt;     &lt;national character string type&gt; ::=            NATIONAL CHARACTER [ &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt; ]          | NATIONAL CHAR [ &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt; ]          | NCHAR [ &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt; ]          | NATIONAL CHARACTER VARYING &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt;          | NATIONAL CHAR VARYING &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt;          | NCHAR VARYING &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt;     &lt;bit string type&gt; ::=            BIT [ &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt; ]          | BIT VARYING &lt;left paren&gt; &lt;length&gt; &lt;right paren&gt;     &lt;numeric type&gt; ::=            &lt;exact numeric type&gt;          | &lt;approximate numeric type&gt;     &lt;exact numeric type&gt; ::=            NUMERIC [ &lt;left paren&gt; &lt;precision&gt; [ &lt;comma&gt; &lt;scale&gt; ] &lt;right paren&gt; ]          | DECIMAL [ &lt;left paren&gt; &lt;precision&gt; [ &lt;comma&gt; &lt;scale&gt; ] &lt;right paren&gt; ]                                                Scalar expressions   107</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.1 &lt;data type&gt;          | DEC [ &lt;left paren&gt; &lt;precision&gt; [ &lt;comma&gt; &lt;scale&gt; ] &lt;right paren&gt; ]          | INTEGER          | INT          | SMALLINT     &lt;approximate numeric type&gt; ::=            FLOAT [ &lt;left paren&gt; &lt;precision&gt; &lt;right paren&gt; ]          | REAL          | DOUBLE PRECISION     &lt;length&gt; ::= &lt;unsigned integer&gt;     &lt;precision&gt; ::= &lt;unsigned integer&gt;     &lt;scale&gt; ::= &lt;unsigned integer&gt;     &lt;datetime type&gt; ::=            DATE          | TIME [ &lt;left paren&gt; &lt;time precision&gt; &lt;right paren&gt; ]          [ WITH TIME ZONE ]          | TIMESTAMP [ &lt;left paren&gt; &lt;timestamp precision&gt; &lt;right paren&gt; ]          [ WITH TIME ZONE ]     &lt;time precision&gt; ::= &lt;time fractional seconds precision&gt;     &lt;timestamp precision&gt; ::= &lt;time fractional seconds precision&gt;     &lt;time fractional seconds precision&gt; ::= &lt;unsigned integer&gt;     &lt;interval type&gt; ::= INTERVAL &lt;interval qualifier&gt;     Syntax Rules     1) CHAR is equivalent to CHARACTER. DEC is equivalent to DECIMAL.        INT is equivalent to INTEGER. VARCHAR is equivalent to CHARACTER        VARYING. NCHAR is equivalent to NATIONAL CHARACTER.     2) &quot;NATIONAL CHARACTER&quot; is equivalent to the corresponding &lt;char-        acter string type&gt; with a specification of &quot;CHARACTER SET CSN&quot;,        where &quot;CSN&quot; is an implementation-defined &lt;character set name&gt;.     3) The value of a &lt;length&gt; or a &lt;precision&gt; shall be greater than        0.     4) If &lt;length&gt; is omitted, then a &lt;length&gt; of 1 is implicit.     5) If a &lt;scale&gt; is omitted, then a &lt;scale&gt; of 0 is implicit.     6) If a &lt;precision&gt; is omitted, then an implementation-defined        &lt;precision&gt; is implicit.     7) CHARACTER specifies the data type character string.     108  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                         6.1 &lt;data type&gt;     8) Characters in a character string are numbered beginning with 1.     9) Case:        a) If VARYING is not specified in &lt;character string type&gt;, then          the length in characters of the character string is fixed and          is the value of &lt;length&gt;.        b) If VARYING is specified in &lt;character string type&gt;, then the          length in characters of the character string is variable,          with a minimum length of 0 and a maximum length of the value          of &lt;length&gt;.        The maximum value of &lt;length&gt; is implementation-defined.        &lt;length&gt; shall not be greater than this maximum value.     10)If &lt;character string type&gt; is not contained in a &lt;domain def-        inition&gt; or a &lt;column definition&gt; and CHARACTER SET is not        specified, then an implementation-defined &lt;character set speci-        fication&gt; is implicit.        Note: Subclause 11.21, &quot;&lt;domain definition&gt;&quot;, and Subclause 11.4,        &quot;&lt;column definition&gt;&quot;, specify the result when &lt;character string        type&gt; is contained in a &lt;domain definition&gt; or &lt;column defini-        tion&gt;, respectively.     11)The character set named SQL_TEXT is an implementation-defined        character set whose character repertoire is SQL_TEXT.        Note: The character repertoire SQL_TEXT is defined in Subclause 4.2,        &quot;Character strings&quot;.     12)BIT specifies the data type bit string.     13)Bits in a bit string are numbered beginning with 1.     14)Case:        a) If VARYING is not specified in &lt;bit string type&gt;, then the          length in bits of the bit string is fixed and is the value of          &lt;length&gt;.        b) If VARYING is specified in &lt;bit string type&gt;, then the length          in bits of the string is variable, with a minimum length of 0          and a maximum length of the value of &lt;length&gt;.        The maximum value of &lt;length&gt; is implementation-defined.        &lt;length&gt; shall not be greater than this maximum value.     15)The &lt;scale&gt; of an &lt;exact numeric type&gt; shall not be greater than        the &lt;precision&gt; of the &lt;exact numeric type&gt;.     16)For the &lt;exact numeric type&gt;s DECIMAL and NUMERIC:        a) The maximum value of &lt;precision&gt; is implementation-defined.          &lt;precision&gt; shall not be greater than this value.                                                Scalar expressions   109</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.1 &lt;data type&gt;        b) The maximum value of &lt;scale&gt; is implementation-defined.          &lt;scale&gt; shall not be greater than this maximum value.     17)NUMERIC specifies the data type exact numeric, with the decimal        precision and scale specified by the &lt;precision&gt; and &lt;scale&gt;.     18)DECIMAL specifies the data type exact numeric, with the decimal        scale specified by the &lt;scale&gt; and the implementation-defined        decimal precision equal to or greater than the value of the        specified &lt;precision&gt;.     19)INTEGER specifies the data type exact numeric, with binary or        decimal precision and scale of 0. The choice of binary versus        decimal precision is implementation-defined, but shall be the        same as SMALLINT.     20)SMALLINT specifies the data type exact numeric, with scale of        0 and binary or decimal precision. The choice of binary versus        decimal precision is implementation-defined, but shall be the        same as INTEGER. The precision of SMALLINT shall be less than or        equal to the precision of INTEGER.     21)FLOAT specifies the data type approximate numeric, with binary        precision equal to or greater than the value of the specified        &lt;precision&gt;. The maximum value of &lt;precision&gt; is implementation-        defined. &lt;precision&gt; shall not be greater than this value.     22)REAL specifies the data type approximate numeric, with implementation-        defined precision.     23)DOUBLE PRECISION specifies the data type approximate numeric,        with implementation-defined precision that is greater than the        implementation-defined precision of REAL.     24)For the &lt;approximate numeric type&gt;s FLOAT, REAL, and DOUBLE        PRECISION, the maximum and minimum values of the exponent are        implementation-defined.     25)If &lt;time precision&gt; is not specified, then 0 is implicit. If        &lt;timestamp precision&gt; is not specified, then 6 is implicit.     26)The maximum value of &lt;time precision&gt; and the maximum value of        &lt;timestamp precision&gt; shall be the same implementation-defined        value that is not less than 6. The values of &lt;time precision&gt;        and &lt;timestamp precision&gt; shall not be greater than that maximum        value.     27)The length of a DATE is 10 positions. The length of a TIME is 8        positions plus the &lt;time fractional seconds precision&gt;, plus 1        position if the &lt;time fractional seconds precision&gt; is greater        than 0. The length of a TIME WITH TIME ZONE is 14 positions        plus the &lt;time fractional seconds precision&gt; plus 1 position if        the &lt;time fractional seconds precision&gt; is greater than 0. The        length of a TIMESTAMP is 19 positions plus the &lt;time fractional     110  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                         6.1 &lt;data type&gt;        seconds precision&gt;, plus 1 position if the &lt;time fractional sec-        onds precision&gt; is greater than 0. The length of a TIMESTAMP        WITH TIME ZONE is 25 positions plus the &lt;time fractional sec-        onds precision&gt; plus 1 position if the &lt;time fractional seconds        precision&gt; is greater than 0.     28)If an &lt;interval qualifier&gt; in an &lt;interval type&gt; includes no        fields other than YEAR and MONTH, then the &lt;interval type&gt; is a        year-month interval. If an &lt;interval qualifier&gt; in an &lt;interval        type&gt; includes any fields other than YEAR or MONTH, then the        &lt;interval type&gt; is a day-time interval.     29)The i-th value of an interval data type corresponds to the i-th        &lt;datetime field&gt;.     30)Within the non-null values of a &lt;datetime type&gt;, the value of        the time zone interval shall be in the range -12:59 to +13:00.        Note: The range for time zone intervals is larger than many        readers might expect because it is governed by political deci-        sions in governmental bodies rather than by any natural law.     Access Rules        None.     General Rules     1) If any specification or operation attempts to cause an item of        a character type to contain a character that is not a member        of the character repertoire associated with the character item,        then an exception condition is raised: data exception-character        not in repertoire.     2) For a &lt;datetime type&gt;,        Case:        a) If DATE is specified, then the data type contains the &lt;date-          time field&gt;s years, months, and days.        b) If TIME is specified, then the data type contains the &lt;date-          time field&gt;s hours, minutes, and seconds.        c) If TIMESTAMP is specified, then the data type contains the          &lt;datetime field&gt;s years, months, days, hours, minutes, and          seconds.     3) For a &lt;datetime type&gt;, a &lt;time fractional seconds precision&gt;        that is an explicit or implicit &lt;time precision&gt; or &lt;timestamp        precision&gt; defines the number of decimal digits following the        decimal point in the SECOND &lt;datetime field&gt;.                                                Scalar expressions   111</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.1 &lt;data type&gt;     4) Table 10, &quot;Valid values for fields in datetime items&quot;, specifies        the constraints on the values of the &lt;datetime field&gt;s in a        datetime data type.     _________Table_10-Valid_values_for_fields_in_datetime_items________     _Keyword____________Valid_values_of_datetime_fields________________    | YEAR             | 0001 to 9999                                  |    |                  |                                               |    | MONTH            | 01 to 12                                      |    |                  |                                               |    | DAY              | Within the range 1 to 31, but further con-    |                         strained by the value of MONTH and YEAR                         fields, according to the rules for well-                         formed dates in the Gregorian calendar.    | HOUR             | 00 to 23                                      |    |                  |                                               |    | MINUTE           | 00 to 59                                      |    |                  |                                               |    | SECOND           | 00 to 61.9(N) where &quot;9(N)&quot; indicates the num- |                         ber of digits specified by &lt;time fractional                         seconds precision&gt;.    | TIMEZONE_HOUR    | 00 to 13                                      |    |                  |                                               |    |_TIMEZONE_MINUTE__|_00_to_59______________________________________|    |                  |                                               |        Note: Datetime data types will allow dates in the Gregorian        format to be stored in the date range 0001-01-01 CE through        9999-12-31 CE. The range for SECOND allows for as many as two        &quot;leap seconds&quot;. Interval arithmetic that involves leap seconds        or discontinuities in calendars will produce implementation-        defined results.     5) If WITH TIME ZONE is not specified, then the time zone dis-        placement of the datetime data type is effectively the current        default time zone displacement of the SQL-session.     6) If any specification or operation attempts to cause an item        of type datetime to take a value where the &lt;datetime field&gt;        YEAR has the value greater than 9999 or less than 1, then an        exception condition is raised: data exception-invalid datetime        format.     7) The values of the &lt;datetime field&gt;s within an interval data type        are constrained as follows:        a) The value corresponding to the first &lt;datetime field&gt; is          an integer with at most N digits, where N is the &lt;interval          leading field precision&gt;.        b) Table 11, &quot;Valid values for fields in INTERVAL items&quot;, spec-          ifies the constraints for the other &lt;datetime field&gt;s in the          interval data type.     112  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                         6.1 &lt;data type&gt;     _________Table_11-Valid_values_for_fields_in_INTERVAL_items________     _Keyword______Valid_values_of_INTERVAL_fields______________________    | MONTH      | 0 to 11                                             |    |            |                                                     |    | HOUR       | 0 to 23                                             |    |            |                                                     |    | MINUTE     | 0 to 59                                             |    |            |                                                     |    | SECOND     | 0 to 59.9(N) where &quot;9(N)&quot; indicates the number of   |                   digits specified by &lt;interval fractional seconds     ______________precision&gt;_in_the_&lt;interval_qualifier&gt;.______________    |8) An item o| type interval can contain positive or negative inter|    |   vals.    |                                                     |    |            |                                                     |     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) A &lt;datetime type&gt; shall not specify a &lt;time precision&gt; or          &lt;timestamp precision&gt;.        b) A &lt;data type&gt; shall not be a &lt;bit string type&gt;.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) A &lt;character string type&gt; shall not specify VARYING or          VARCHAR.        b) A &lt;data type&gt; shall not be a &lt;datetime type&gt; or an &lt;interval          type&gt;.        c) A &lt;data type&gt; shall not be a &lt;national character string type&gt;          nor specify CHARACTER SET.                                                Scalar expressions   113</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.2 &lt;value specification&gt; and &lt;target specification&gt;     6.2  &lt;value specification&gt; and &lt;target specification&gt;     Function     Specify one or more values, parameters, or variables.     Format     &lt;value specification&gt; ::=            &lt;literal&gt;          | &lt;general value specification&gt;     &lt;unsigned value specification&gt; ::=            &lt;unsigned literal&gt;          | &lt;general value specification&gt;     &lt;general value specification&gt; ::=            &lt;parameter specification&gt;          | &lt;dynamic parameter specification&gt;          | &lt;variable specification&gt;          | USER          | CURRENT_USER          | SESSION_USER          | SYSTEM_USER          | VALUE     &lt;simple value specification&gt; ::=            &lt;parameter name&gt;          | &lt;embedded variable name&gt;          | &lt;literal&gt;     &lt;target specification&gt; ::=            &lt;parameter specification&gt;          | &lt;variable specification&gt;     &lt;simple target specification&gt; ::=            &lt;parameter name&gt;          | &lt;embedded variable name&gt;     &lt;parameter specification&gt; ::=          &lt;parameter name&gt; [ &lt;indicator parameter&gt; ]     &lt;indicator parameter&gt; ::=          [ INDICATOR ] &lt;parameter name&gt;     &lt;dynamic parameter specification&gt; ::= &lt;question mark&gt;     &lt;variable specification&gt; ::=          &lt;embedded variable name&gt; [ &lt;indicator variable&gt; ]     &lt;indicator variable&gt; ::=          [ INDICATOR ] &lt;embedded variable name&gt;     114  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                    6.2 &lt;value specification&gt; and &lt;target specification&gt;     Syntax Rules     1) The data type of an &lt;indicator parameter&gt; or &lt;indicator vari-        able&gt; shall be exact numeric with a scale of 0.     2) Each &lt;parameter name&gt; shall be contained in a &lt;module&gt;. Each        &lt;embedded variable name&gt; shall be contained in an &lt;embedded        SQL statement&gt;. Each &lt;dynamic parameter specification&gt; shall        be contained in a &lt;preparable statement&gt; that is dynamically        prepared in the current SQL-session through the execution of a        &lt;prepare statement&gt; or an &lt;execute immediate statement&gt;.     3) If USER is specified, then CURRENT_USER is implicit.     4) The data type of CURRENT_USER, SESSION_USER, and SYSTEM_USER is        character string. Whether the character string is fixed-length        or variable-length, and its length if it is fixed-length or        maximum length if it is variable-length, are implementation-        defined. The character set of the character string is SQL_TEXT.     5) The &lt;value specification&gt; or &lt;unsigned value specification&gt;        VALUE shall be contained in a &lt;domain constraint&gt;. The data        type of an instance of VALUE is the &lt;data type&gt; of the &lt;domain        definition&gt; containing that &lt;domain constraint&gt;.     6) If the data type of the &lt;value specification&gt; or &lt;unsigned value        specification&gt; is character string, then the &lt;value specifi-        cation&gt; or &lt;unsigned value specification&gt; has the Coercible        coercibility attribute, and the collating sequence is deter-        mined by Subclause 4.2.3, &quot;Rules determining collating sequence        usage&quot;.     Access Rules        None.     General Rules     1) A &lt;value specification&gt; or &lt;unsigned value specification&gt; speci-        fies a value that is not selected from a table.     2) A &lt;parameter specification&gt; identifies a parameter or a parame-        ter and an indicator parameter in a &lt;module&gt;.     3) A &lt;dynamic parameter specification&gt; identifies a parameter used        by a dynamically prepared statement.     4) A &lt;variable specification&gt; identifies a host variable or a host        variable and an indicator variable.     5) A &lt;target specification&gt; specifies a parameter or variable that        can be assigned a value.                                                Scalar expressions   115</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.2 &lt;value specification&gt; and &lt;target specification&gt;     6) If a &lt;parameter specification&gt; contains an &lt;indicator parame-        ter&gt; and the value of the indicator parameter is negative, then        the value specified by the &lt;parameter specification&gt; is null.        Otherwise, the value specified by a &lt;parameter specification&gt; is        the value of the parameter identified by the &lt;parameter name&gt;.     7) If a &lt;variable specification&gt; contains an &lt;indicator vari-        able&gt; and the value of the indicator variable is negative, then        the value specified by the &lt;variable specification&gt; is null.        Otherwise, the value specified by a &lt;variable specification&gt; is        the value of the variable identified by the &lt;embedded variable        name&gt;.     8) The value specified by a &lt;literal&gt; is the value represented by        that &lt;literal&gt;.     9) The value specified by CURRENT_USER is the value of the current        &lt;authorization identifier&gt;.     10)The value specified by SESSION_USER is the value of the SQL-        session &lt;authorization identifier&gt;.     11)The value specified by SYSTEM_USER is equal to an implementation-        defined string that represents the operating system user who        executed the &lt;module&gt; that contains the SQL-statement whose ex-        ecution caused the SYSTEM_USER &lt;general value specification&gt; to        be evaluated.     12)A &lt;simple value specification&gt; specifies a &lt;value specifica-        tion&gt; or &lt;unsigned value specification&gt; that is not null and        does not have an associated &lt;indicator parameter&gt; or &lt;indicator        variable&gt;.     13)A &lt;simple target specification&gt; specifies a parameter or vari-        able that can be assigned a value that is not null.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) In Intermediate SQL, the specific data type of &lt;indicator          parameter&gt;s and &lt;indicator variable&gt;s shall be the same          implementation-defined data type.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) A &lt;general value specification&gt; shall not be a &lt;dynamic pa-          rameter specification&gt;.        b) A &lt;general value specification&gt; shall not specify VALUE.     116  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                    6.2 &lt;value specification&gt; and &lt;target specification&gt;        c) A &lt;general value specification&gt; shall not specify CURRENT_          USER, SYSTEM_USER, or SESSION_USER.          Note: Although CURRENT_USER and USER are semantically the          same, in Entry SQL, CURRENT_USER must be specified as USER.                                                Scalar expressions   117</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.3 &lt;table reference&gt;     6.3  &lt;table reference&gt;     Function     Reference a table.     Format     &lt;table reference&gt; ::=            &lt;table name&gt; [ [ AS ] &lt;correlation name&gt;                [ &lt;left paren&gt; &lt;derived column list&gt; &lt;right paren&gt; ] ]          | &lt;derived table&gt; [ AS ] &lt;correlation name&gt;                [ &lt;left paren&gt; &lt;derived column list&gt; &lt;right paren&gt; ]          | &lt;joined table&gt;     &lt;derived table&gt; ::= &lt;table subquery&gt;     &lt;derived column list&gt; ::= &lt;column name list&gt;     &lt;column name list&gt; ::=          &lt;column name&gt; [ &#123; &lt;comma&gt; &lt;column name&gt; &#125;... ]     Syntax Rules     1) A &lt;correlation name&gt; immediately contained in a &lt;table refer-        ence&gt; TR is exposed by TR. A &lt;table name&gt; immediately contained        in a &lt;table reference&gt; TR is exposed by TR if and only if TR        does not specify a &lt;correlation name&gt;.     2) Case:        a) If a &lt;table reference&gt; TR is contained in a &lt;from clause&gt; FC          with no intervening &lt;derived table&gt;, then the scope clause          SC of TR is the &lt;select statement: single row&gt; or innermost          &lt;query specification&gt; that contains FC. The scope clause of          the exposed &lt;correlation name&gt; or exposed &lt;table name&gt; of TR          is the &lt;select list&gt;, &lt;where clause&gt;, &lt;group by clause&gt;, and          &lt;having clause&gt; of SC, together with the &lt;join condition&gt; of          all &lt;joined table&gt;s contained in SC that contains TR.        b) Otherwise, the scope clause SC of TR is the outermost &lt;joined          table&gt; that contains TR with no intervening &lt;derived table&gt;.          The scope of the exposed &lt;correlation name&gt; or exposed &lt;table          name&gt; of TR is the &lt;join condition&gt; of SC and of all &lt;joined          table&gt;s contained in SC that contain TR.     3) A &lt;table name&gt; that is exposed by a &lt;table reference&gt; TR shall        not be the same as any other &lt;table name&gt; that is exposed by a        &lt;table reference&gt; with the same scope clause as TR.     118  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                   6.3 &lt;table reference&gt;     4) A &lt;correlation name&gt; that is exposed by a &lt;table reference&gt; TR        shall not be the same as any other &lt;correlation name&gt; that is        exposed by a &lt;table reference&gt; with the same scope clause as TR        and shall not be the same as the &lt;qualified identifier&gt; of any        &lt;table name&gt; that is exposed by a &lt;table reference&gt; with the        same scope clause as TR.     5) A &lt;table name&gt; immediately contained in a &lt;table reference&gt; TR        has a scope clause and scope defined by that &lt;table reference&gt;        if and only if the &lt;table name&gt; is exposed by TR.     6) The same &lt;column name&gt; shall not be specified more than once in        a &lt;derived column list&gt;.     7) If a &lt;derived column list&gt; is specified in a &lt;table reference&gt;,        then the number of &lt;column name&gt;s in the &lt;derived column list&gt;        shall be the same as the degree of the table specified by the        &lt;derived table&gt; or the &lt;table name&gt; of that &lt;table reference&gt;,        and the name of the i-th column of that &lt;derived table&gt; or the        effective name of the i-th column of that &lt;table name&gt; is the        i-th &lt;column name&gt; in that &lt;derived column list&gt;.     8) A &lt;derived table&gt; is an updatable derived table if and only if        the &lt;query expression&gt; simply contained in the &lt;subquery&gt; of the        &lt;table subquery&gt; of the &lt;derived table&gt; is updatable.     Access Rules     1) Let T be the table identified by the &lt;table name&gt; immediately        contained in &lt;table reference&gt;. If the &lt;table reference&gt; is        contained in any of:        a) a &lt;query expression&gt; simply contained in a &lt;cursor speci-          fication&gt;, a &lt;view definition&gt;, a &lt;direct select statement:          multiple rows&gt;, or an &lt;insert statement&gt;; or        b) a &lt;table expression&gt; or &lt;select list&gt; immediately contained          in a &lt;select statement: single row&gt;; or        c) a &lt;search condition&gt; immediately contained in a &lt;delete          statement: searched&gt; or an &lt;update statement: searched&gt;; or        d) a &lt;value expression&gt; immediately contained in an &lt;update          source&gt;,        then the applicable privileges shall include SELECT for T.     General Rules     1) The &lt;correlation name&gt; or exposed &lt;table name&gt; contained in a        &lt;table reference&gt; defines that &lt;correlation name&gt; or &lt;table        name&gt; to be an identifier of the table identified by the &lt;table        name&gt; or &lt;derived table&gt; of that &lt;table reference&gt;.                                                Scalar expressions   119</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.3 &lt;table reference&gt;     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) A &lt;table reference&gt; shall not be a &lt;derived table&gt;.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) A &lt;table reference&gt; shall not be a &lt;joined table&gt;.        b) The optional &lt;key word&gt; AS shall not be specified.        c) &lt;derived column list&gt; shall not be specified.     120  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                  6.4 &lt;column reference&gt;     6.4  &lt;column reference&gt;     Function     Reference a column.     Format     &lt;column reference&gt; ::= [ &lt;qualifier&gt; &lt;period&gt; ] &lt;column name&gt;     &lt;qualifier&gt; ::=            &lt;table name&gt;          | &lt;correlation name&gt;     Syntax Rules     1) Let CR be the &lt;column reference&gt;, let CN be the &lt;column name&gt;        contained in CR, and let C be the column identified by CN.     2) If CR contains a &lt;qualifier&gt; Q, then CR shall appear within the        scope of one or more &lt;table name&gt;s or &lt;correlation name&gt;s that        are equal to Q. If there is more than one such &lt;table name&gt; or        &lt;correlation name&gt;, then the one with the most local scope is        specified. Let T be the table associated with Q.        a) T shall include a column whose &lt;column name&gt; is CN.        b) If T is a &lt;table reference&gt; in a &lt;joined table&gt; J, then CN          shall not be a common column name in J.          Note: Common column name is defined in Subclause 7.5, &quot;&lt;joined          table&gt;&quot;.     3) If CR does not contain a &lt;qualifier&gt;, then CR shall be contained        within the scope of one or more &lt;table name&gt;s or &lt;correlation        name&gt;s whose associated tables include a column whose &lt;column        name&gt; is CN. Let the phrase possible qualifiers denote those        &lt;table name&gt;s and &lt;correlation name&gt;s.        a) Case:          i) If the most local scope contains exactly one possible             qualifier, then the qualifier Q equivalent to that unique             &lt;table name&gt; or &lt;correlation name&gt; is implicit.         ii) If there is more than one possible qualifier with most             local scope, then:             1) Each possible qualifier shall be a &lt;table name&gt; or a               &lt;correlation name&gt; of a &lt;table reference&gt; that is di-               rectly contained in a &lt;joined table&gt; J.                                                Scalar expressions   121</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.4 &lt;column reference&gt;             2) CN shall be a common column name in J.               Note: Common column name is defined in Subclause 7.5,               &quot;&lt;joined table&gt;&quot;.             3) The implicit qualifier Q is implementation-dependent.               The scope of Q is that which Q would have had if J had               been replaced by the &lt;table reference&gt;:                  ( J ) AS Q        b) Let T be the table associated with Q.     4) The data type of CR is the data type of column C of T. CN shall        uniquely identify a column of T.     5) If the data type of CR is character string, then CR has the        Implicit coercibility attribute and its collating sequence is        the default collating sequence for column C of T.     6) If the data type of CR is TIME or TIMESTAMP, then the implicit        time zone of the data is the current default time zone for the        SQL-session.     7) If the data type of CR is TIME WITH TIME ZONE or TIMESTAMP WITH        TIME ZONE, then the time zone of the data is the time zone rep-        resented in the value of CR.     8) If CR is contained in a &lt;table expression&gt; TE and the scope        clause of the &lt;table reference&gt; immediately containing the &lt;ta-        ble name&gt; or &lt;correlation name&gt; Q also contains TE, then CR is        an outer reference to the table associated with Q.     9) Let CR be the &lt;column reference&gt; and let C be the column identi-        fied by CR. C is an underlying column of CR. If C is a &lt;derived        column&gt;, then every underlying column of C is an underlying        column of CR.        Note: The underlying columns of a &lt;derived column&gt; are defined        in Subclause 7.9, &quot;&lt;query specification&gt;&quot;.     Access Rules     1) The applicable privileges shall include SELECT for T if CR is        contained in any of:        a) a &lt;search condition&gt; immediately contained in a &lt;delete          statement: searched&gt; or an &lt;update statement: searched&gt;; or        b) a &lt;value expression&gt; immediately contained in an &lt;update          source&gt;.     122  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                  6.4 &lt;column reference&gt;     General Rules     1) The &lt;column reference&gt; Q.CN references column C in a given row        of T.     2) If the data type of CR is TIME, TIMESTAMP, TIME WITH TIME ZONE        or TIMESTAMP WITH TIME ZONE, then let TZ be an INTERVAL HOUR        TO MINUTE containing the value of the time zone displacement        associated with CR. The value of CR, normalized to UTC, is ef-        fectively computed as          CR + TZ.     Leveling Rules     1) The following restrictions apply for Intermediate SQL;          None.     2) The following restrictions apply for Entry SQL;          None.                                                Scalar expressions   123</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.5 &lt;set function specification&gt;     6.5  &lt;set function specification&gt;     Function     Specify a value derived by the application of a function to an     argument.     Format     &lt;set function specification&gt; ::=            COUNT &lt;left paren&gt; &lt;asterisk&gt; &lt;right paren&gt;          | &lt;general set function&gt;     &lt;general set function&gt; ::=            &lt;set function type&gt;                &lt;left paren&gt; [ &lt;set quantifier&gt; ] &lt;value expression&gt; &lt;right paren&gt;     &lt;set function type&gt; ::=          AVG | MAX | MIN | SUM | COUNT     &lt;set quantifier&gt; ::= DISTINCT | ALL     Syntax Rules     1) If &lt;set quantifier&gt; is not specified, then ALL is implicit.     2) The argument of COUNT(*) and the argument source of a &lt;general        set function&gt; is a table or a group of a grouped table as spec-        ified in Subclause 7.8, &quot;&lt;having clause&gt;&quot;, and Subclause 7.9,        &quot;&lt;query specification&gt;&quot;.        Note: argument source is defined in Subclause 7.8, &quot;&lt;having        clause&gt;&quot;.     3) Let T be the argument or argument source of a &lt;set function        specification&gt;.     4) The &lt;value expression&gt; simply contained in &lt;set function spec-        ification&gt; shall not contain a &lt;set function specification&gt; or        a &lt;subquery&gt;. If the &lt;value expression&gt; contains a &lt;column ref-        erence&gt; that is an outer reference, then that outer reference        shall be the only &lt;column reference&gt; contained in the &lt;value        expression&gt;.        Note: Outer reference is defined in Subclause 6.4, &quot;&lt;column        reference&gt;&quot;.     5) If a &lt;set function specification&gt; contains a &lt;column reference&gt;        that is an outer reference, then the &lt;set function specifica-        tion&gt; shall be contained in either:        a) a &lt;select list&gt;, or     124  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                        6.5 &lt;set function specification&gt;        b) a &lt;subquery&gt; of a &lt;having clause&gt;, in which case the scope          of the explicit or implicit &lt;qualifier&gt; of the &lt;column refer-          ence&gt; shall be a &lt;table reference&gt; that is directly contained          in the &lt;table expression&gt; that directly contains the &lt;having          clause&gt;.        Note: Outer reference is defined in Subclause 6.4, &quot;&lt;column        reference&gt;&quot;.     6) Let DT be the data type of the &lt;value expression&gt;.     7) If COUNT is specified, then the data type of the result is exact        numeric with implementation-defined precision and scale of 0.     8) If MAX or MIN is specified, then the data type of the result is        DT.     9) If SUM or AVG is specified, then:        a) DT shall not be character string, bit string, or datetime.        b) If SUM is specified and DT is exact numeric with scale          S, then the data type of the result is exact numeric with          implementation-defined precision and scale S.        c) If AVG is specified and DT is exact numeric, then the data          type of the result is exact numeric with implementation-          defined precision not less than the precision of DT and          implementation-defined scale not less than the scale of DT.        d) If DT is approximate numeric, then the data type of the          result is approximate numeric with implementation-defined          precision not less than the precision of DT.        e) If DT is interval, then the data type of the result is inter-          val with the same precision as DT.     10)If the data type of the result is character string, then the        collating sequence and the coercibility attribute are determined        as in Subclause 4.2.3, &quot;Rules determining collating sequence        usage&quot;.     Access Rules        None.     General Rules     1) Case:        a) If COUNT(*) is specified, then the result is the cardinality          of T.                                                Scalar expressions   125</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.5 &lt;set function specification&gt;        b) Otherwise, let TX be the single-column table that is the          result of applying the &lt;value expression&gt; to each row of T          and eliminating null values. If one or more null values are          eliminated, then a completion condition is raised: warning-          null value eliminated in set function.     2) If DISTINCT is specified, then let TXA be the result of elimi-        nating redundant duplicate values from TX. Otherwise, let TXA be        TX.        Case:        a) If the &lt;general set function&gt; COUNT is specified, then the          result is the cardinality of TXA.        b) If AVG, MAX, MIN, or SUM is specified, then          Case:          i) If TXA is empty, then the result is the null value.         ii) If AVG is specified, then the result is the average of the             values in TXA.        iii) If MAX or MIN is specified, then the result is respec-             tively the maximum or minimum value in TXA. These results             are determined using the comparison rules specified in             Subclause 8.2, &quot;&lt;comparison predicate&gt;&quot;.         iv) If SUM is specified, then the result is the sum of the             values in TXA. If the sum is not within the range of the             data type of the result, then an exception condition is             raised: data exception-numeric value out of range.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) If a &lt;general set function&gt; specifies DISTINCT, then the          &lt;value expression&gt; shall be a &lt;column reference&gt;.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) If a &lt;general set function&gt; specifies or implies ALL, then          COUNT shall not be specified.        b) If a &lt;general set function&gt; specifies or implies ALL, then          the &lt;value expression&gt; shall include a &lt;column reference&gt;          that references a column of T.        c) If the &lt;value expression&gt; contains a &lt;column reference&gt; that          is an outer reference, then the &lt;value expression&gt; shall be a          &lt;column reference&gt;.     126  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                        6.5 &lt;set function specification&gt;        d) No &lt;column reference&gt; contained in a &lt;set function specifica-          tion&gt; shall reference a column derived from a &lt;value expres-          sion&gt; that generally contains a &lt;set function specification&gt;.                                                Scalar expressions   127</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.6 &lt;numeric value function&gt;     6.6  &lt;numeric value function&gt;     Function     Specify a function yielding a value of type numeric.     Format     &lt;numeric value function&gt; ::=            &lt;position expression&gt;          | &lt;extract expression&gt;          | &lt;length expression&gt;     &lt;position expression&gt; ::=          POSITION &lt;left paren&gt; &lt;character value expression&gt;              IN &lt;character value expression&gt; &lt;right paren&gt;     &lt;length expression&gt; ::=            &lt;char length expression&gt;          | &lt;octet length expression&gt;          | &lt;bit length expression&gt;     &lt;char length expression&gt; ::=          &#123; CHAR_LENGTH | CHARACTER_LENGTH &#125;              &lt;left paren&gt; &lt;string value expression&gt; &lt;right paren&gt;     &lt;octet length expression&gt; ::=          OCTET_LENGTH &lt;left paren&gt; &lt;string value expression&gt; &lt;right paren&gt;     &lt;bit length expression&gt; ::=          BIT_LENGTH &lt;left paren&gt; &lt;string value expression&gt; &lt;right paren&gt;     &lt;extract expression&gt; ::=          EXTRACT &lt;left paren&gt; &lt;extract field&gt;              FROM &lt;extract source&gt; &lt;right paren&gt;     &lt;extract field&gt; ::=            &lt;datetime field&gt;          | &lt;time zone field&gt;     &lt;time zone field&gt; ::=            TIMEZONE_HOUR          | TIMEZONE_MINUTE     &lt;extract source&gt; ::=            &lt;datetime value expression&gt;          | &lt;interval value expression&gt;     128  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                            6.6 &lt;numeric value function&gt;     Syntax Rules     1) If &lt;position expression&gt; is specified, then the character reper-        toires of the two &lt;character value expression&gt;s shall be the        same.     2) If &lt;position expression&gt; is specified, then the data type of the        result is exact numeric with implementation-defined precision        and scale 0.     3) If &lt;extract expression&gt; is specified, then        Case:        a) If &lt;extract field&gt; is a &lt;datetime field&gt;, then it shall iden-          tify a &lt;datetime field&gt; of the &lt;interval value expression&gt; or          &lt;datetime value expression&gt; immediately contained in &lt;extract          source&gt;.        b) If &lt;extract field&gt; is a &lt;time zone field&gt;, then the data          type of the &lt;extract source&gt; shall be TIME WITH TIME ZONE or          TIMESTAMP WITH TIME ZONE.     4) If &lt;extract expression&gt; is specified, then        Case:        a) If &lt;datetime field&gt; does not specify SECOND, then the data          type of the result is exact numeric with implementation-          defined precision and scale 0.        b) Otherwise, the data type of the result is exact numeric          with implementation-defined precision and scale. The          implementation-defined scale shall not be less than the spec-          ified or implied &lt;time fractional seconds precision&gt; or &lt;in-          terval fractional seconds precision&gt;, as appropriate, of the          SECOND &lt;datetime field&gt; of the &lt;extract source&gt;.     5) If a &lt;length expression&gt; is specified, then the data type of the        result is exact numeric with implementation-defined precision        and scale 0.     Access Rules        None.     General Rules     1) If &lt;position expression&gt; is specified and neither &lt;character        value expression&gt; is the null value, then        Case:        a) If the first &lt;character value expression&gt; has a length of 0,          then the result is 1.                                                Scalar expressions   129</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.6 &lt;numeric value function&gt;        b) If the value of the first &lt;character value expression&gt; is          equal to an identical-length substring of contiguous char-          acters from the value of the second &lt;character value ex-          pression&gt;, then the result is 1 greater than the number of          characters within the value of the second &lt;character value          expression&gt; preceding the start of the first such substring.        c) Otherwise, the result is 0.     2) If &lt;position expression&gt; is specified and either &lt;character        value expression&gt; is the null value, then the result is the null        value.     3) If &lt;extract expression&gt; is specified, then        Case:        a) If the value of the &lt;interval value expression&gt; or the &lt;date-          time value expression&gt; is not the null value, then          Case:          i) If &lt;extract field&gt; is a &lt;datetime field&gt;, then the re-             sult is the value of the datetime field identified by that             &lt;datetime field&gt; and has the same sign as the &lt;extract             source&gt;.             Note: If the value of the identified &lt;datetime field&gt; is             zero or if &lt;extract source&gt; is not an &lt;interval value ex-             pression&gt;, then the sign is irrelevant.         ii) Otherwise, let TZ be the interval value of the implicit             or explicit time zone associated with the &lt;datetime value             expression&gt;. If &lt;extract field&gt; is TIMEZONE_HOUR, then the             result is calculated as               EXTRACT (HOUR FROM TZ)             Otherwise, the result is calculated as               EXTRACT (MINUTE FROM TZ)        b) Otherwise, the result is the null value.     4) If a &lt;char length expression&gt; is specified, then        Case:        a) Let S be the &lt;string value expression&gt;. If the value of S is          not the null value, then          Case:          i) If the data type of S is a character data type, then the             result is the number of characters in the value of S.         ii) Otherwise, the result is OCTET_LENGTH(S).        b) Otherwise, the result is the null value.     130  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                            6.6 &lt;numeric value function&gt;     5) If an &lt;octet length expression&gt; is specified, then        Case:        a) Let S be the &lt;string value expression&gt;. If the value of S is          not the null value, then the result is the smallest integer          not less than the quotient of the division (BIT_LENGTH(S)/8).        b) Otherwise, the result is the null value.     6) If a &lt;bit length expression&gt; is specified, then        Case:        a) Let S be the &lt;string value expression&gt;. If the value of S is          not the null value, then the result is the number of bits in          the value of S.        b) Otherwise, the result is the null value.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) A &lt;numeric value function&gt; shall not be a &lt;position expres-          sion&gt;.        b) A &lt;numeric value function&gt; shall not contain a &lt;length ex-          pression&gt; that is a &lt;bit length expression&gt;.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) A &lt;numeric value function&gt; shall not be a &lt;length expres-          sion&gt;.        b) A &lt;numeric value function&gt; shall not be an &lt;extract expres-          sion&gt;.                                                Scalar expressions   131</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.7 &lt;string value function&gt;     6.7  &lt;string value function&gt;     Function     Specify a function yielding a value of type character string or bit     string.     Format     &lt;string value function&gt; ::=            &lt;character value function&gt;          | &lt;bit value function&gt;     &lt;character value function&gt; ::=            &lt;character substring function&gt;          | &lt;fold&gt;          | &lt;form-of-use conversion&gt;          | &lt;character translation&gt;          | &lt;trim function&gt;     &lt;character substring function&gt; ::=          SUBSTRING &lt;left paren&gt; &lt;character value expression&gt; FROM &lt;start position&gt;                      [ FOR &lt;string length&gt; ] &lt;right paren&gt;     &lt;fold&gt; ::= &#123; UPPER | LOWER &#125; &lt;left paren&gt; &lt;character value expression&gt; &lt;right paren&gt;     &lt;form-of-use conversion&gt; ::=          CONVERT &lt;left paren&gt; &lt;character value expression&gt;              USING &lt;form-of-use conversion name&gt; &lt;right paren&gt;     &lt;character translation&gt; ::=          TRANSLATE &lt;left paren&gt; &lt;character value expression&gt;              USING &lt;translation name&gt; &lt;right paren&gt;     &lt;trim function&gt; ::=          TRIM &lt;left paren&gt; &lt;trim operands&gt; &lt;right paren&gt;     &lt;trim operands&gt; ::=          [ [ &lt;trim specification&gt; ] [ &lt;trim character&gt; ] FROM ] &lt;trim source&gt;     &lt;trim source&gt; ::= &lt;character value expression&gt;     &lt;trim specification&gt; ::=            LEADING          | TRAILING          | BOTH     &lt;trim character&gt; ::= &lt;character value expression&gt;     &lt;bit value function&gt; ::=     132  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                             6.7 &lt;string value function&gt;          &lt;bit substring function&gt;     &lt;bit substring function&gt; ::=          SUBSTRING &lt;left paren&gt; &lt;bit value expression&gt; FROM &lt;start position&gt;              [ FOR &lt;string length&gt; ] &lt;right paren&gt;     &lt;start position&gt; ::= &lt;numeric value expression&gt;     &lt;string length&gt; ::= &lt;numeric value expression&gt;     Syntax Rules     1) The data type of a &lt;start position&gt; and &lt;string length&gt; shall be        exact numeric with scale 0.     2) If &lt;character substring function&gt; is specified, then:        a) The data type of the &lt;character substring function&gt; is          variable-length character string with maximum length equal to          the fixed length or maximum variable length of the &lt;character          value expression&gt;. The character repertoire and form-of-use          of the &lt;character substring function&gt; are the same as the          character repertoire and form-of-use of the &lt;character value          expression&gt;.        b) The collating sequence and the coercibility attribute          are determined as specified for monadic operators in          Subclause 4.2.3, &quot;Rules determining collating sequence us-          age&quot;, where the first operand of SUBSTRING plays the role of          the monadic operand.     3) If &lt;fold&gt; is specified, then:        a) The data type of the result of &lt;fold&gt; is the data type of the          &lt;character value expression&gt;.        b) The collating sequence and the coercibility attribute          are determined as specified for monadic operators in          Subclause 4.2.3, &quot;Rules determining collating sequence us-          age&quot;, where the operand of the &lt;fold&gt; is the monadic operand.     4) If &lt;form-of-use conversion&gt; is specified, then:        a) A &lt;form-of-use conversion name&gt; shall identify a form-of-use          conversion.        b) The data type of the result is variable-length character          string with implementation-defined maximum length. The          character set of the result is the same as the character          repertoire of the &lt;character value expression&gt; and form-          of-use determined by the form-of-use conversion identified                                                Scalar expressions   133</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.7 &lt;string value function&gt;          by the &lt;form-of-use conversion name&gt;. Let CR be that char-          acter repertoire. The result has the Implicit coercibility          attribute and its collating sequence is X, where X is the          default collating sequence of CR.     5) If &lt;character translation&gt; is specified, then        a) A &lt;translation name&gt; shall identify a character translation.        b) The data type of the &lt;character translation&gt; is variable-          length character string with implementation-defined maximum          length and character repertoire equal to the character reper-          toire of the target character set of the translation. Let CR          be that character repertoire. The result has the Implicit co-          ercibility attribute and its collating sequence is X, where X          is the default collating sequence of CR.     6) If &lt;trim function&gt; is specified, then        a) If FROM is specified, then either &lt;trim specification&gt; or          &lt;trim character&gt; or both shall be specified.        b) If &lt;trim specification&gt; is not specified, then BOTH is im-          plicit.        c) If &lt;trim character&gt; is not specified, then &#39; &#39; is implicit.        d) If             TRIM ( SRC )          is specified, then             TRIM ( BOTH &#39; &#39; FROM SRC )          is implicit.        e) The data type of the &lt;trim function&gt; is variable-length char-          acter string with maximum length equal to the fixed length or          maximum variable length of the &lt;trim source&gt;.        f) If a &lt;trim character&gt; is specified, then &lt;trim character&gt; and          &lt;trim source&gt; shall be comparable.        g) The character repertoire and form-of-use of the &lt;trim func-          tion&gt; are the same as those of the &lt;trim source&gt;.        h) The collating sequence and the coercibility attribute          are determined as specified for monadic operators in          Subclause 4.2.3, &quot;Rules determining collating sequence us-          age&quot;, where the &lt;trim source&gt; of TRIM plays the role of the          monadic operand.     7) If &lt;bit substring function&gt; is specified, then the data type of        the &lt;bit substring function&gt; is variable-length bit string with        maximum length equal to the fixed length or maximum variable        length of the &lt;bit value expression&gt;.     134  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                             6.7 &lt;string value function&gt;     Access Rules     1) The applicable privileges shall include USAGE for every &lt;trans-        lation name&gt; contained in the &lt;string value expression&gt;.     General Rules     1) If &lt;character substring function&gt; is specified, then:        a) Let C be the value of the &lt;character value expression&gt;, let          LC be the length of C, and let S be the value of the &lt;start          position&gt;.        b) If &lt;string length&gt; is specified, then let L be the value of          &lt;string length&gt; and let E be S+L. Otherwise, let E be the          larger of LC + 1 and S.        c) If either C, S, or L is the null value, then the result of          the &lt;character substring function&gt; is the null value.        d) If E is less than S, then an exception condition is raised:          data exception-substring error.        e) Case:          i) If S is greater than LC or if E is less than 1, then the             result of the &lt;character substring function&gt; is a zero-             length string.         ii) Otherwise,             1) Let S1 be the larger of S and 1. Let E1 be the smaller               of E and LC+1. Let L1 be E1-S1.             2) The result of the &lt;character substring function&gt; is               a character string containing the L1 characters of C               starting at character number S1 in the same order that               the characters appear in C.     2) If &lt;fold&gt; is specified, then:        a) Let S be the value of the &lt;character value expression&gt;.        b) If S is the null value, then the result of the &lt;fold&gt; is the          null value.        c) Case:          i) If UPPER is specified, then the result of the &lt;fold&gt; is a             copy of S in which every &lt;simple Latin lower case letter&gt;             that has a corresponding &lt;simple Latin upper case let-             ter&gt; in the character repertoire of S is replaced by that             &lt;simple Latin upper case letter&gt;.                                                Scalar expressions   135</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.7 &lt;string value function&gt;         ii) If LOWER is specified, then the result of the &lt;fold&gt; is a             copy of S in which every &lt;simple Latin upper case letter&gt;             that has a corresponding &lt;simple Latin lower case let-             ter&gt; in the character repertoire of S is replaced by that             &lt;simple Latin lower case letter&gt;.     3) If a &lt;character translation&gt; is specified, then        Case:        a) If the value of &lt;character value expression&gt; is the null          value, then the result of the &lt;character translation&gt; is the          null value.        b) Otherwise, the value of the &lt;character translation&gt; is the          value of the &lt;character value expression&gt; after translation          to the character repertoire of the target character set of          the translation.     4) If a &lt;form-of-use conversion&gt; is specified, then        Case:        a) If the value of &lt;character value expression&gt; is the null          value, then the result of the &lt;form-of-use conversion&gt; is the          null value.        b) Otherwise, the value of the &lt;form-of-use conversion&gt; is the          value of the &lt;character value expression&gt; after the applica-          tion of the form-of-use conversion specified by &lt;form-of-use          conversion name&gt;.     5) If &lt;trim function&gt; is specified, then:        a) Let S be the value of the &lt;trim source&gt;.        b) If &lt;trim character&gt; is specified, then let SC be the value of          &lt;trim character&gt;; otherwise, let SC be &lt;space&gt;.        c) If either S or SC is the null value, then the result of the          &lt;trim function&gt; is the null value.        d) If the length in characters of SC is not 1, then an exception          condition is raised: data exception-trim error.        e) Case:          i) If BOTH is specified or if no &lt;trim specification&gt; is spec-             ified, then the result of the &lt;trim function&gt; is the value             of S with any leading or trailing characters equal to SC             removed.         ii) If TRAILING is specified, then the result of the &lt;trim             function&gt; is the value of S with any trailing characters             equal to SC removed.     136  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                             6.7 &lt;string value function&gt;        iii) If LEADING is specified, then the result of the &lt;trim func-             tion&gt; is the value of S with any leading characters equal             to SC removed.     6) If &lt;bit substring function&gt; is specified, then:        a) Let B be the value of the &lt;bit value expression&gt;, let LB be          the length in bits of B, and let S be the value of the &lt;start          position&gt;.        b) If &lt;string length&gt; is specified, then let L be the value of          &lt;string length&gt; and let E be S+L. Otherwise, let E be the          larger of LB + 1 and S.        c) If either B, S, or L is the null value, then the result of          the &lt;bit substring function&gt; is the null value.        d) If E is less than S, then an exception condition is raised:          data exception-substring error.        e) Case:          i) If S is greater than LB or if E is less than 1, then the             result of the &lt;bit substring function&gt; is a zero-length             string.         ii) Otherwise,             1) Let S1 be the larger of S and 1. Let E1 be the smaller               of E and LB+1. Let L1 be E1-S1.             2) The result of the &lt;bit substring function&gt; is a bit               string containing L1 bits of B starting at bit number S1               in the same order that the bits appear in B.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) A &lt;character value function&gt; shall not be a &lt;fold&gt;.        b) Conforming Intermediate SQL language shall contain no &lt;char-          acter translation&gt;.        c) Conforming Intermediate SQL language shall contain no &lt;form-          of-use conversion&gt;.        d) Conforming Intermediate SQL language shall contain no &lt;bit          value function&gt;.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) A &lt;character value function&gt; shall not be a &lt;character sub-          string function&gt;.                                                Scalar expressions   137</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.7 &lt;string value function&gt;        b) A &lt;character value function&gt; shall not be a &lt;trim function&gt;.     138  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                           6.8 &lt;datetime value function&gt;     6.8  &lt;datetime value function&gt;     Function     Specify a function yielding a value of type datetime.     Format     &lt;datetime value function&gt; ::=            &lt;current date value function&gt;          | &lt;current time value function&gt;          | &lt;current timestamp value function&gt;     &lt;current date value function&gt; ::= CURRENT_DATE     &lt;current time value function&gt; ::=            CURRENT_TIME [ &lt;left paren&gt; &lt;time precision&gt; &lt;right paren&gt; ]     &lt;current timestamp value function&gt; ::=            CURRENT_TIMESTAMP [ &lt;left paren&gt; &lt;timestamp precision&gt; &lt;right paren&gt; ]     Syntax Rules     1) The data type of a &lt;current date value function&gt; is DATE. The        data type of a &lt;current time value function&gt; is TIME WITH TIME        ZONE. The data type of a &lt;current timestamp value function&gt; is        TIMESTAMP WITH TIME ZONE.        Note: See the Syntax Rules of Subclause 6.1, &quot;&lt;data type&gt;&quot;, for        rules governing &lt;time precision&gt; and &lt;timestamp precision&gt;.     Access Rules        None.     General Rules     1) The &lt;datetime value function&gt;s CURRENT_DATE, CURRENT_TIME, and        CURRENT_TIMESTAMP respectively return the current date, current        time, and current timestamp; the time and timestamp values are        returned with time zone displacement equal to the current time        zone displacement of the SQL-session.     2) If specified, &lt;time precision&gt; and &lt;timestamp precision&gt; respec-        tively determine the precision of the time or timestamp value        returned.     3) If an SQL-statement generally contains more than one reference        to one or more &lt;datetime value function&gt;s, then all such ref-        erences are effectively evaluated simultaneously. The time of                                                Scalar expressions   139</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.8 &lt;datetime value function&gt;        evaluation of the &lt;datetime value function&gt; during the execution        of the SQL-statement is implementation-dependent.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) Conforming Intermediate SQL language shall contain no &lt;time          precision&gt; or &lt;timestamp precision&gt;.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) Conforming Entry SQL language shall not contain any &lt;datetime          value function&gt;.     140  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                   6.9 &lt;case expression&gt;     6.9  &lt;case expression&gt;     Function     Specify a conditional value.     Format     &lt;case expression&gt; ::=            &lt;case abbreviation&gt;          | &lt;case specification&gt;     &lt;case abbreviation&gt; ::=            NULLIF &lt;left paren&gt; &lt;value expression&gt; &lt;comma&gt;                  &lt;value expression&gt; &lt;right paren&gt;          | COALESCE &lt;left paren&gt; &lt;value expression&gt;                  &#123; &lt;comma&gt; &lt;value expression&gt; &#125;... &lt;right paren&gt;     &lt;case specification&gt; ::=            &lt;simple case&gt;          | &lt;searched case&gt;     &lt;simple case&gt; ::=          CASE &lt;case operand&gt;            &lt;simple when clause&gt;...            [ &lt;else clause&gt; ]          END     &lt;searched case&gt; ::=          CASE            &lt;searched when clause&gt;...            [ &lt;else clause&gt; ]          END     &lt;simple when clause&gt; ::= WHEN &lt;when operand&gt; THEN &lt;result&gt;     &lt;searched when clause&gt; ::= WHEN &lt;search condition&gt; THEN &lt;result&gt;     &lt;else clause&gt; ::= ELSE &lt;result&gt;     &lt;case operand&gt; ::= &lt;value expression&gt;     &lt;when operand&gt; ::= &lt;value expression&gt;     &lt;result&gt; ::= &lt;result expression&gt; | NULL     &lt;result expression&gt; ::= &lt;value expression&gt;                                                Scalar expressions   141</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.9 &lt;case expression&gt;     Syntax Rules     1) NULLIF (V1, V2) is equivalent to the following &lt;case specifica-        tion&gt;:          CASE WHEN V1=V2 THEN NULL ELSE V1 END     2) COALESCE (V1, V2) is equivalent to the following &lt;case specifi-        cation&gt;:          CASE WHEN V1 IS NOT NULL THEN V1 ELSE V2 END     3) COALESCE (V1, V2, . . . ,n ), for n &gt;= 3, is equivalent to the        following &lt;case specification&gt;:          CASE WHEN V1 IS NOT NULL THEN V1 ELSE COALESCE (V2, . . . ,n )          END     4) If a &lt;case specification&gt; specifies a &lt;simple case&gt;, then let CO        be the &lt;case operand&gt;:        a) The data type of each &lt;when operand&gt; WO shall be comparable          with the data type of the &lt;case operand&gt;.        b) The &lt;case specification&gt; is equivalent to a &lt;searched case&gt;          in which each &lt;searched when clause&gt; specifies a &lt;search          condition&gt; of the form &quot;CO=WO&quot;.     5) At least one &lt;result&gt; in a &lt;case specification&gt; shall specify a        &lt;result expression&gt;.     6) If an &lt;else clause&gt; is not specified, then ELSE NULL is im-        plicit.     7) The data type of a &lt;case specification&gt; is determined by ap-        plying Subclause 9.3, &quot;Set operation result data types&quot;, to the        data types of all &lt;result expression&gt;s in the &lt;case specifica-        tion&gt;.     Access Rules        None.     General Rules     1) Case:        a) If a &lt;result&gt; specifies NULL, then its value is the null          value.        b) If a &lt;result&gt; specifies a &lt;value expression&gt;, then its value          is the value of that &lt;value expression&gt;.     142  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                   6.9 &lt;case expression&gt;     2) Case:        a) If the &lt;search condition&gt; of some &lt;searched when clause&gt; in          a &lt;case specification&gt; is true, then the value of the &lt;case          specification&gt; is the value of the &lt;result&gt; of the first          (leftmost) &lt;searched when clause&gt; whose &lt;search condition&gt; is          true, cast as the data type of the &lt;case specification&gt;.        b) If no &lt;search condition&gt; in a &lt;case specification&gt; is true,          then the value of the &lt;case expression&gt; is the value of the          &lt;result&gt; of the explicit or implicit &lt;else clause&gt;, cast as          the data type of the &lt;case specification&gt;.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:          None.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) Conforming Entry SQL language shall not contain any &lt;case          expression&gt;.                                                Scalar expressions   143</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.10 &lt;cast specification&gt;     6.10  &lt;cast specification&gt;     Function     Specify a data conversion.     Format     &lt;cast specification&gt; ::=          CAST &lt;left paren&gt; &lt;cast operand&gt; AS &lt;cast target&gt; &lt;right paren&gt;     &lt;cast operand&gt; ::=            &lt;value expression&gt;          | NULL     &lt;cast target&gt; ::=            &lt;domain name&gt;          | &lt;data type&gt;     Syntax Rules     1) Case:        a) If a &lt;domain name&gt; is specified, then let TD be the &lt;data          type&gt; of the specified domain.        b) If a &lt;data type&gt; is specified, then let TD be the specified          &lt;data type&gt;.     2) The data type of the result of the &lt;cast specification&gt; is TD.     3) If the &lt;cast operand&gt; is a &lt;value expression&gt;, then let SD be        the underlying data type of the &lt;value expression&gt;.     4) If the &lt;cast operand&gt; is a &lt;value expression&gt;, then the valid        combinations of TD and SD in a &lt;cast specification&gt; are given by        the following table. Y indicates that the combination is syntac-        tically valid without restriction; M indicates that the combi-        nation is valid subject to other syntax rules in this Subclause        being satisfied; and N indicates that the combination is not        valid:          &lt;data type&gt;          SD of                 &lt;data type&gt; of TD          &lt;value          expression&gt;   EN   AN   VC   FC   VB   FB   D    T    TS   YM   DT              EN        Y    Y    Y    Y    N    N    N    N    N    M    M              AN        Y    Y    Y    Y    N    N    N    N    N    N    N              C         Y    Y    M    M    Y    Y    Y    Y    Y    Y    Y              B         N    N    Y    Y    Y    Y    N    N    N    N    N              D         N    N    Y    Y    N    N    Y    N    Y    N    N     144  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                               6.10 &lt;cast specification&gt;              T         N    N    Y    Y    N    N    N    Y    Y    N    N              TS        N    N    Y    Y    N    N    Y    Y    Y    N    N              YM        M    N    Y    Y    N    N    N    N    N    Y    N              DT        M    N    Y    Y    N    N    N    N    N    N    Y          Where:              EN = Exact Numeric              AN = Approximate Numeric              C  = Character (Fixed- or Variable-length)              FC = Fixed-length Character              VC = Variable-length Character              B  = Bit String (Fixed- or Variable-length)              FB = Fixed-length Bit String              VB = Variable-length Bit String              D  = Date              T  = Time              TS = Timestamp              YM = Year-Month Interval              DT = Day-Time Interval     5) If TD is an interval and SD is exact numeric, then TD shall        contain only a single &lt;datetime field&gt;.     6) If TD is exact numeric and SD is an interval, then SD shall        contain only a single &lt;datetime field&gt;.     7) If SD is character string and TD is fixed-length or variable-        length character string, then the character repertoires of SD        and TD shall be the same.     8) If TD is a fixed-length or variable-length character string,        then the collating sequence of the result of the &lt;cast speci-        fication&gt; is the default collating sequence for the character        repertoire of TD and the result of the &lt;cast specification&gt; has        the Coercible coercibility attribute.     Access Rules     1) If &lt;domain name&gt; is specified, then the applicable privileges        shall include USAGE.     General Rules     1) If the &lt;cast operand&gt; is a &lt;value expression&gt;, then let SV be        its value.     2) Case:        a) If the &lt;cast operand&gt; specifies NULL or if SV is the null          value, then the result of the &lt;cast specification&gt; is the          null value.                                                Scalar expressions   145</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.10 &lt;cast specification&gt;        b) Otherwise, let TV be the result of the &lt;cast specifica-          tion&gt; as specified in the remaining General Rules of this          Subclause.     3) If TD is exact numeric, then        Case:        a) If SD is exact numeric or approximate numeric, then          Case:          i) If there is a representation of SV in the data type TD             that does not lose any leading significant digits after             rounding or truncating if necessary, then TV is that rep-             resentation. The choice of whether to round or truncate is             implementation-defined.         ii) Otherwise, an exception condition is raised: data exception-             numeric value out of range.        b) If SD is character string, then SV is replaced by SV with any          leading or trailing &lt;space&gt;s removed.          Case:          i) If SV does not comprise a &lt;signed numeric literal&gt; as             defined by the rules for &lt;literal&gt; in Subclause 5.3,             &quot;&lt;literal&gt;&quot;, then an exception condition is raised: data             exception-invalid character value for cast.         ii) Otherwise, let LT be that &lt;signed numeric literal&gt;. The             &lt;cast specification&gt; is equivalent to               CAST ( LT AS TD )        c) If SD is an interval data type, then          Case:          i) If there is a representation of SV in the data type TD that             does not lose any leading significant digits, then TV is             that representation.         ii) Otherwise, an exception condition is raised: data exception-             numeric value out of range.     4) If TD is approximate numeric, then        Case:        a) If SD is exact numeric or approximate numeric, then          Case:          i) If there is a representation of SV in the data type TD             that does not lose any leading significant digits after     146  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                               6.10 &lt;cast specification&gt;             rounding or truncating if necessary, then TV is that rep-             resentation. The choice of whether to round or truncate is             implementation-defined.         ii) Otherwise, an exception condition is raised: data exception-             numeric value out of range.        b) If SD is character string, then SV is replaced by SV with any          leading or trailing &lt;space&gt;s removed.          Case:          i) If SV does not comprise a &lt;signed numeric literal&gt; as             defined by the rules for &lt;literal&gt; in Subclause 5.3,             &quot;&lt;literal&gt;&quot;, then an exception condition is raised: data             exception-invalid character value for cast.         ii) Otherwise, let LT be that &lt;signed numeric literal&gt;. The             &lt;cast specification&gt; is equivalent to               CAST ( LT AS TD )     5) If TD is fixed-length character string, then let LTD be the        length in characters of TD.        Case:        a) If SD is exact numeric, then let YP be the shortest character          string that conforms to the definition of &lt;exact numeric          literal&gt; in Subclause 5.3, &quot;&lt;literal&gt;&quot;, whose scale is the          same as the scale of SD and whose interpreted value is the          absolute value of SV.          If SV is less than 0, then let Y be the result of             &#39;-&#39; | YP          Otherwise, let Y be YP.          Case:          i) If Y contains any &lt;SQL language character&gt; that is not             in the repertoire of TD, then an exception condition is             raised: data exception-invalid character value for cast.         ii) If the length in characters LY of Y is equal to LTD, then             TV is Y.        iii) If the length in characters LY of Y is less than LTD, then             TV is Y extended on the right by LTD-LY &lt;space&gt;s.         iv) Otherwise, an exception condition is raised: data exception-             string data, right truncation.        b) If SD is approximate numeric, then:          i) Let YP be a character string as follows:                                                Scalar expressions   147</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.10 &lt;cast specification&gt;             Case:             1) If SV equals 0, then YP is &#39;0E0&#39;.             2) Otherwise, YP is the shortest character string that con-               forms to the definition of &lt;approximate numeric literal&gt;               in Subclause 5.3, &quot;&lt;literal&gt;&quot;, whose interpreted value               is equal to the absolute value of SV and whose &lt;man-               tissa&gt; consists of a single &lt;digit&gt; that is not &#39;0&#39;,               followed by a &lt;period&gt; and an &lt;unsigned integer&gt;.         ii) If SV is less than 0, then let Y be the result of               &#39;-&#39; | YP             otherwise, let Y be YP.        iii) Case:             1) If Y contains any &lt;SQL language character&gt; that is not               in the repertoire of TD, then an exception condition is               raised: data exception-invalid character value for cast.             2) If the length in characters LY of Y is equal to LTD,               then TV is Y.             3) If the length in characters LY of Y is less than LTD,               then TV is Y extended on the right by LTD-LY &lt;space&gt;s.             4) Otherwise, an exception condition is raised: data               exception-string data, right truncation.        c) If SD is fixed-length character string or variable-length          character string, then          Case:          i) If the length in characters of SV is equal to LTD, then TV             is SV.         ii) If the length in characters of SV is larger than LTD, then             TV is the first LTD characters of SV. If any of the re-             maining characters of SV are non-&lt;space&gt; characters, then a             completion condition is raised: warning-string data, right             truncation.        iii) If the length in characters M of SV is smaller than LTD,             then TV is SV extended on the right by LTD-M &lt;space&gt;s.        d) If SD is fixed-length bit string or variable-length bit          string, then let LSV be the value of BIT_LENGTH(SV) and let          B be the BIT_LENGTH of the character with the smallest BIT_          LENGTH in the form-of-use of TD. Let PAD be the value of the          remainder of the division LSV/B. Let NC be a character whose          bits all have the value 0.     148  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                               6.10 &lt;cast specification&gt;          If PAD is not 0, then append (B - PAD) 0-valued bits to          the least significant end of SV; a completion condition is          raised: warning-implicit zero-bit padding.          Let SVC be the possibly padded value of SV expressed as a          character string without regard to valid character encodings          and let LTDS be a character string of LTD characters of value          NC characters in the form-of-use of TD.          TV is the result of             SUBSTRING (SVC | LTDS FROM 1 FOR LTD)          Case:          i) If the length of TV is less than the length of SVC, then a             completion condition is raised: warning-string data, right             truncation.         ii) If the length of TV is greater than the length of SVC, then             a completion condition is raised: warning-implicit zero-bit             padding.        e) If SD is a datetime data type or an interval data type, then          let Y be the shortest character string that conforms to the          definition of &lt;literal&gt; in Subclause 5.3, &quot;&lt;literal&gt;&quot;, and          such that the interpreted value of Y is SV and the inter-          preted precision of Y is the precision of SD.          Case:          i) If Y contains any &lt;SQL language character&gt; that is not             in the repertoire of TD, then an exception condition is             raised: data exception-invalid character value for cast.         ii) If the length in characters LY of Y is equal to LTD, then             TV is Y.        iii) If the length in characters LY of Y is less than LTD, then             TV is Y extended on the right by LTD-LY &lt;space&gt;s.         iv) Otherwise, an exception condition is raised: data exception-             string data, right truncation.     6) If TD is variable-length character string, then let MLTD be the        maximum length in characters of TD.        Case:        a) If SD is exact numeric, then let YP be the shortest character          string that conforms to the definition of &lt;exact numeric          literal&gt; in Subclause 5.3, &quot;&lt;literal&gt;&quot;, whose scale is the          same as the scale of SD and whose interpreted value is the          absolute value of SV.          If SV is less than 0, then let Y be the result of             &#39;-&#39; | YP                                                Scalar expressions   149</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.10 &lt;cast specification&gt;          Otherwise, let Y be YP.          Case:          i) If Y contains any &lt;SQL language character&gt; that is not             in the repertoire of TD, then an exception condition is             raised: data exception-invalid character value for cast.         ii) If the length in characters LY of Y is less than or equal             to MLTD, then TV is Y.        iii) Otherwise, an exception condition is raised: data exception-             string data, right truncation.        b) If SD is approximate numeric, then          i) Let YP be a character string as follows:             Case:             1) If SV equals 0, then YP is &#39;0E0&#39;.             2) Otherwise, YP is the shortest character string that con-               forms to the definition of &lt;approximate numeric literal&gt;               in Subclause 5.3, &quot;&lt;literal&gt;&quot;, whose interpreted value               is equal to the absolute value of SV and whose &lt;man-               tissa&gt; consists of a single &lt;digit&gt; that is not &#39;0&#39;,               followed by a &lt;period&gt; and an &lt;unsigned integer&gt;.         ii) If SV is less than 0, then let Y be the result of               &#39;-&#39; | YP             otherwise, let Y be YP.        iii) Case:             1) If Y contains any &lt;SQL language character&gt; that is not               in the repertoire of TD, then an exception condition is               raised: data exception-invalid character value for cast.             2) If the length in characters LY of Y is less than or               equal to MLTD, then TV is Y.             3) Otherwise, an exception condition is raised: data               exception-string data, right truncation.        c) If SD is fixed-length character string or variable-length          character string, then          Case:          i) If the length in characters of SV is less than or equal to             MLTD, then TV is SV.     150  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                               6.10 &lt;cast specification&gt;         ii) If the length in characters of SV is larger than MLTD,             then TV is the first MLTD characters of SV. If any of the             remaining characters of SV are non-&lt;space&gt; characters,             then a completion condition is raised: warning-string data,             right truncation.        d) If SD is fixed-length bit string or variable-length bit          string, then let LSV be the value of BIT_LENGTH(SV) and let          B be the BIT_LENGTH of the character with the smallest BIT_          LENGTH in the form-of-use of TD. Let PAD be the value of the          remainder of the division LSV/B.          If PAD is not 0, then append (B - PAD) 0-valued bits to          the least significant end of SV; a completion condition is          raised: warning-implicit zero-bit padding.          Let SVC be the possible padded value of SV expressed as a          character string without regard to valid character encodings.          Case:          i) If CHARACTER_LENGTH (SVC) is not greater than MLTD, then TV             is SVC.         ii) Otherwise, TV is the result of               SUBSTRING (SVC FROM 1 FOR MLTD)             If the length of TV is less than the length of SVC, then a             completion condition is raised: warning-string data, right             truncation.        e) If SD is a datetime data type or an interval data type then          let Y be the shortest character string that conforms to the          definition of &lt;literal&gt; in Subclause 5.3, &quot;&lt;literal&gt;&quot;, and          such that the interpreted value of Y is SV and the inter-          preted precision of Y is the precision of SD.          Case:          i) If Y contains any &lt;SQL language character&gt; that is not             in the repertoire of TD, then an exception condition is             raised: data exception-invalid character value for cast.         ii) If the length in characters LY of Y is less than or equal             to MLTD, then TV is Y.        iii) Otherwise, an exception condition is raised: data exception-             string data, right truncation.     7) If TD is fixed-length bit string, then let LTD be the length in        bits of TD. Let BLSV be the result of BIT_LENGTH(SV).        Case:        a) If BLSV is equal to LTD, then TV is SV expressed as a bit          string with a length in bits of BLSV.                                                Scalar expressions   151</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.10 &lt;cast specification&gt;        b) If BLSV is larger than LTD, then TV is the first LTD bits of          SV expressed as a bit string with a length in bits of LTD,          and a completion condition is raised: warning-string data,          right truncation.        c) If BLSV is smaller than LTD, then TV is SV expressed as a bit          string extended on the right with LTD-BLSV bits whose values          are all 0 and a completion condition is raised: warning-          implicit zero-bit padding.     8) If TD is variable-length bit string, then let MLTD be the        maximum length in bits of TD. Let BLSV be the result of BIT_        LENGTH(SV).        Case:        a) If BLSV is less than or equal to MLTD, then TV is SV ex-          pressed as a bit string with a length in bits of BLSV.        b) If BLSV is larger than MLTD, then TV is the first MLTD bits          of SV expressed as a bit string with a length in bits of MLTD          and a completion condition is raised: warning-string data,          right truncation.     9) If TD is the datetime data type DATE, then        Case:        a) If SD is character string, then SV is replaced by             TRIM ( BOTH &#39; &#39; FROM SV )          Case:          i) If the rules for &lt;literal&gt; in Subclause 5.3, &quot;&lt;literal&gt;&quot;,             can be applied to SV to determine a valid value of the data             type TD, then let TV be that value.         ii) Otherwise, an exception condition is raised: data exception-             invalid character value for cast.        b) If SD is a date, then TV is SV.        c) If SD is a timestamp, then TV is the year, month, and day          &lt;datetime field&gt;s of SV adjusted to the implicit or explicit          time zone displacement of SV.     10)If TD is the datetime data type TIME, then        Case:        a) If SD is character string, then SV is replaced by             TRIM ( BOTH &#39; &#39; FROM SV )          Case:     152  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                               6.10 &lt;cast specification&gt;          i) If the rules for &lt;literal&gt; in Subclause 5.3, &quot;&lt;literal&gt;&quot;,             can be applied to SV to determine a valid value of the data             type TD, then let TV be that value.         ii) Otherwise, an exception condition is raised: data exception-             invalid character value for cast.        b) If SD is a time, then TV is SV. If TD is specified WITH TIME          ZONE, then TV also includes the implicit or explicit time          zone displacement of SV; otherwise, TV is adjusted to the          current time zone displacement of the SQL-session.        c) If SD is a timestamp, then TV is the hour, minute, and second          &lt;datetime field&gt;s of SV. If TD is specified WITH TIME ZONE,          then TV also includes the implicit or explicit time zone          displacement of SV; otherwise, TV is adjusted to the current          time zone displacement of the SQL-session.     11)If TD is the datetime data type TIMESTAMP, then        Case:        a) If SD is character string, then SV is replaced by             TRIM ( BOTH &#39; &#39; FROM SV )          Case:          i) If the rules for &lt;literal&gt; in Subclause 5.3, &quot;&lt;literal&gt;&quot;,             can be applied to SV to determine a valid value of the data             type TD, then let TV be that value.         ii) Otherwise, an exception condition is raised: data exception-             invalid character value for cast.        b) If SD is a date, then the &lt;datetime field&gt;s hour, minute,          and second of TV are set to 0 and the &lt;datetime field&gt;s year,          month, and day of TV are set to their respective values in          SV. If TD is specified WITH TIME ZONE, then the time zone          fields of TV are set to the current time zone displacement of          the SQL-session.        c) If SD is a time, then the &lt;datetime field&gt;s year, month, and          day of TV are set to their respective values in an execution          of CURRENT_DATE and the &lt;datetime field&gt;s hour, minute, and          second of TV are set to their respective values in SV. If TD          is specified WITH TIME ZONE, then the time zone fields of TV          are set to the explicit or implicit time zone interval of SV.        d) If SD is a timestamp, then TV is SV.     12)If TD is interval, then        Case:        a) If SD is exact numeric, then                                                Scalar expressions   153</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.10 &lt;cast specification&gt;          Case:          i) If the representation of SV in the data type TD would re-             sult in the loss of leading significant digits, then an             exception condition is raised: data exception-interval             field overflow.         ii) Otherwise, TV is that representation.        b) If SD is character string, then SV is replaced by             TRIM ( BOTH &#39; &#39; FROM SV )          Case:          i) If the rules for &lt;literal&gt; in Subclause 5.3, &quot;&lt;literal&gt;&quot;,             can be applied to SV to determine a valid value of the data             type TD, then let TV be that value.         ii) Otherwise, an exception condition is raised: data exception-             invalid character value for cast.        c) If SD is interval and TD and SD have the same interval preci-          sion, then TV is SV.        d) If SD is interval and TD and SD have different interval pre-          cisions, then let Q be the least significant &lt;datetime field&gt;          of TD.          i) Let Y be the result of converting SV to a scalar in units Q             according to the natural rules for intervals as defined in             the Gregorian calendar.         ii) Normalize Y to conform to the datetime qualifier &quot;P TO Q&quot;             of TD. If this would result in loss of precision of the             leading datetime field of Y, then an exception condition is             raised: data exception-interval field overflow.        iii) TV is the value of Y.     13)If the &lt;cast specification&gt; contains a &lt;domain name&gt; and that        &lt;domain name&gt; refers to a domain that contains a &lt;domain con-        straint&gt; and if TV does not satisfy the &lt;check constraint&gt; of        the &lt;domain constraint&gt;, then an exception condition is raised:        integrity constraint violation.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:          None.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) Conforming Entry SQL language shall not contain any &lt;cast          specification&gt;.     154  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                 6.11 &lt;value expression&gt;     6.11  &lt;value expression&gt;     Function     Specify a value.     Format     &lt;value expression&gt; ::=            &lt;numeric value expression&gt;          | &lt;string value expression&gt;          | &lt;datetime value expression&gt;          | &lt;interval value expression&gt;     &lt;value expression primary&gt; ::=            &lt;unsigned value specification&gt;          | &lt;column reference&gt;          | &lt;set function specification&gt;          | &lt;scalar subquery&gt;          | &lt;case expression&gt;          | &lt;left paren&gt; &lt;value expression&gt; &lt;right paren&gt;          | &lt;cast specification&gt;     Syntax Rules     1) The data type of a &lt;value expression&gt; is the data type of the        &lt;numeric value expression&gt;, &lt;string value expression&gt;, &lt;datetime        value expression&gt;, or &lt;interval value expression&gt;, respectively.     2) If the data type of a &lt;value expression primary&gt; is character        string, then the collating sequence and coercibility attribute        of the &lt;value expression primary&gt; are the collating sequence and        coercibility attribute of the &lt;unsigned value specification&gt;,        &lt;column reference&gt;, &lt;set function specification&gt;, &lt;scalar sub-        query&gt;, &lt;case expression&gt;, &lt;value expression&gt;, or &lt;cast specifi-        cation&gt; immediately contained in the &lt;value expression primary&gt;.     3) Let C be some column. Let VE be the &lt;value expression&gt;. C is an        underlying column of VE if and only if C is identified by some        &lt;column reference&gt; contained in VE.     Access Rules        None.                                                Scalar expressions   155</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.11 &lt;value expression&gt;     General Rules     1) When a &lt;value expression&gt; V is evaluated for a row of a table,        each reference to a column of that table by a &lt;column reference&gt;        directly contained in V is a reference to the value of that        column in that row.     2) If a &lt;value expression primary&gt; is a &lt;scalar subquery&gt; and the        result of the &lt;subquery&gt; is empty, then the result of the &lt;value        expression primary&gt; is the null value.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:          None.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) A &lt;value expression&gt; shall not be a &lt;datetime value expres-          sion&gt;.        b) A &lt;value expression&gt; shall not be an &lt;interval value expres-          sion&gt;.        c) A &lt;value expression primary&gt; shall not be a &lt;case expres-          sion&gt;.        d) A &lt;value expression primary&gt; shall not be a &lt;cast specifica-          tion&gt;.        e) A &lt;value expression primary&gt; shall not be a &lt;scalar subquery&gt;          except when the &lt;value expression primary&gt; is simply con-          tained in a &lt;value expression&gt; that is simply contained in          the second &lt;row value constructor&gt; of a &lt;comparison predi-          cate&gt;.     156  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                         6.12 &lt;numeric value expression&gt;     6.12  &lt;numeric value expression&gt;     Function     Specify a numeric value.     Format     &lt;numeric value expression&gt; ::=            &lt;term&gt;          | &lt;numeric value expression&gt; &lt;plus sign&gt; &lt;term&gt;          | &lt;numeric value expression&gt; &lt;minus sign&gt; &lt;term&gt;     &lt;term&gt; ::=            &lt;factor&gt;          | &lt;term&gt; &lt;asterisk&gt; &lt;factor&gt;          | &lt;term&gt; &lt;solidus&gt; &lt;factor&gt;     &lt;factor&gt; ::=          [ &lt;sign&gt; ] &lt;numeric primary&gt;     &lt;numeric primary&gt; ::=            &lt;value expression primary&gt;          | &lt;numeric value function&gt;     Syntax Rules     1) If the data type of both operands of a dyadic arithmetic opera-        tor is exact numeric, then the data type of the result is exact        numeric, with precision and scale determined as follows:        a) Let S1 and S2 be the scale of the first and second operands          respectively.        b) The precision of the result of addition and subtraction is          implementation-defined, and the scale is the maximum of S1          and S2.        c) The precision of the result of multiplication is implementation-          defined, and the scale is S1 + S2.        d) The precision and scale of the result of division is          implementation-defined.     2) If the data type of either operand of a dyadic arithmetic op-        erator is approximate numeric, then the data type of the re-        sult is approximate numeric. The precision of the result is        implementation-defined.     3) The data type of a &lt;factor&gt; is that of the immediately contained        &lt;numeric primary&gt;.                                                Scalar expressions   157</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.12 &lt;numeric value expression&gt;     4) The data type of a &lt;numeric primary&gt; shall be numeric.     Access Rules        None.     General Rules     1) If the value of any &lt;numeric primary&gt; simply contained in a        &lt;numeric value expression&gt; is the null value, then the result of        the &lt;numeric value expression&gt; is the null value.     2) If the &lt;numeric value expression&gt; contains only a &lt;numeric pri-        mary&gt;, then the value of the &lt;numeric value expression&gt; is the        value of the specified &lt;numeric primary&gt;.     3) The monadic arithmetic operators &lt;plus sign&gt; and &lt;minus sign&gt;        (+ and -, respectively) specify monadic plus and monadic minus,        respectively. Monadic plus does not change its operand. Monadic        minus reverses the sign of its operand.     4) The dyadic arithmetic operators &lt;plus sign&gt;, &lt;minus sign&gt;, &lt;as-        terisk&gt;, and &lt;solidus&gt; (+, -, *, and /, respectively) specify        addition, subtraction, multiplication, and division, respec-        tively. If the value of a divisor is zero, then an exception        condition is raised: data exception-division by zero.     5) If the type of the result of an arithmetic operation is exact        numeric, then        Case:        a) If the operator is not division and the mathematical result          of the operation is not exactly representable with the pre-          cision and scale of the result type, then an exception con-          dition is raised: data exception-numeric value out of range.        b) If the operator is division and the approximate mathemati-          cal result of the operation represented with the precision          and scale of the result type loses one or more leading sig-          nificant digits after rounding or truncating if necessary,          then an exception condition is raised: data exception-numeric          value out of range. The choice of whether to round or trun-          cate is implementation-defined.     6) If the type of the result of an arithmetic operation is approx-        imate numeric and the exponent of the approximate mathematical        result of the operation is not within the implementation-defined        exponent range for the result type, then an exception condition        is raised: data exception-numeric value out of range.     158  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                         6.12 &lt;numeric value expression&gt;     Leveling Rules     1) The following restrictions apply for Intermediate SQL:          None.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:          None.                                                Scalar expressions   159</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.13 &lt;string value expression&gt;     6.13  &lt;string value expression&gt;     Function     Specify a character string value or a bit string value.     Format     &lt;string value expression&gt; ::=            &lt;character value expression&gt;          | &lt;bit value expression&gt;     &lt;character value expression&gt; ::=            &lt;concatenation&gt;          | &lt;character factor&gt;     &lt;concatenation&gt; ::=          &lt;character value expression&gt; &lt;concatenation operator&gt;          &lt;character factor&gt;     &lt;character factor&gt; ::=          &lt;character primary&gt; [ &lt;collate clause&gt; ]     &lt;character primary&gt; ::=            &lt;value expression primary&gt;          | &lt;string value function&gt;     &lt;bit value expression&gt; ::=            &lt;bit concatenation&gt;          | &lt;bit factor&gt;     &lt;bit concatenation&gt; ::=          &lt;bit value expression&gt; &lt;concatenation operator&gt; &lt;bit factor&gt;     &lt;bit factor&gt; ::= &lt;bit primary&gt;     &lt;bit primary&gt; ::=            &lt;value expression primary&gt;          | &lt;string value function&gt;     Syntax Rules     1) The data type of a &lt;character primary&gt; shall be character        string.     2) Character strings of different character repertoires shall        not be mixed in a &lt;character value expression&gt;. The character        repertoire of a &lt;character value expression&gt; is the character        repertoire of its components.     160  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                          6.13 &lt;string value expression&gt;     3) Case:        a) If &lt;concatenation&gt; is specified, then:          Let D1 be the data type of the &lt;character value expression&gt;          and let D2 be the data type of the &lt;character factor&gt;. Let          M be the length in characters of D1 plus the length in char-          acters of D2. Let VL be the implementation-defined maximum          length of a variable-length character string and let FL be          the implementation-defined maximum length of a fixed-length          character string.          Case:          i) If the data type of the &lt;character value expression&gt; or             &lt;character factor&gt; is variable-length character string,             then the data type of the &lt;concatenation&gt; is variable-             length character string with maximum length equal to the             lesser of M and VL.         ii) If the data type of the &lt;character value expression&gt; and             &lt;character factor&gt; is fixed-length character string, then M             shall not be greater than FL and the data type of the &lt;con-             catenation&gt; is fixed-length character string with length M.        b) Otherwise, the data type of the &lt;character value expression&gt;          is the data type of the &lt;character factor&gt;.     4) Case:        a) If &lt;character factor&gt; is specified, then          Case:          i) If &lt;collate clause&gt; is specified, then the &lt;character value             expression&gt; has the collating sequence given in &lt;collate             clause&gt;, and has the Explicit coercibility attribute.         ii) Otherwise, if &lt;value expression primary&gt; or &lt;string value             function&gt; are specified, then the collating sequence and             coercibility attribute of the &lt;character factor&gt; are spec-             ified in Subclause 6.2, &quot;&lt;value specification&gt; and &lt;target             specification&gt;&quot;, and Subclause 6.7, &quot;&lt;string value func-             tion&gt;&quot;, respectively.        b) If &lt;concatenation&gt; is specified, then the collating sequence          and the coercibility attribute are determined as specified          for dyadic operators in Subclause 4.2.3, &quot;Rules determining          collating sequence usage&quot;.     5) The data type of a &lt;bit primary&gt; shall be bit string.                                                Scalar expressions   161</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.13 &lt;string value expression&gt;     6) Case:        a) If &lt;bit concatenation&gt; is specified, then let D1 be the          data type of the &lt;bit value expression&gt;, let D2 be the data          type of the &lt;bit factor&gt;, let M be the length in bits of D1          plus the length in bits of D2, let VL be the implementation-          defined maximum length of a variable-length bit string, and          let FL be the implementation-defined maximum length of a          fixed-length bit string.          Case:          i) If the data type of the &lt;bit value expression&gt; or &lt;bit             factor&gt; is variable-length bit string, then the data type             of the &lt;bit concatenation&gt; is variable-length bit string             with maximum length equal to the lesser of M and VL.         ii) If the data type of the &lt;bit value expression&gt; and &lt;bit             factor&gt; is fixed-length bit string, then M shall not be             greater than FL and the data type of the &lt;bit concatena-             tion&gt; is fixed-length bit string with length M.        b) Otherwise, the data type of a &lt;bit value expression&gt; is the          data type of the &lt;bit factor&gt;.     Access Rules        None.     General Rules     1) If the value of any &lt;character primary&gt; simply contained in a        &lt;character value expression&gt; is the null value, then the result        of the &lt;character value expression&gt; is the null value.     2) If &lt;concatenation&gt; is specified, then let S1 and S2 be the re-        sult of the &lt;character value expression&gt; and &lt;character factor&gt;,        respectively.        Case:        a) If either S1 or S2 is the null value, then the result of the          &lt;concatenation&gt; is the null value.        b) Otherwise, let S be the string consisting of S1 followed by          S2 and let M be the length of S.          Case:          i) If the data type of either S1 or S2 is variable-length             character string, then             Case:             1) If M is less than or equal to VL, then the result of the               &lt;concatenation&gt; is S with length M.     162  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                          6.13 &lt;string value expression&gt;             2) If M is greater than VL and the right-most M-VL charac-               ters of S are all the &lt;space&gt; character, then the result               of the &lt;concatenation&gt; is the first VL characters of S               with length VL.             3) Otherwise, an exception condition is raised: data               exception-string data, right truncation.         ii) If the data types of both S1 and S2 are fixed-length char-             acter string, then the result of the &lt;concatenation&gt; is             S.     3) If the value of any &lt;bit primary&gt; simply contained in a &lt;bit        value expression&gt; is the null value, then the result of the &lt;bit        value expression&gt; is the null value.     4) If &lt;bit concatenation&gt; is specified, then let S1 and S2 be the        result of the &lt;bit value expression&gt; and &lt;bit factor&gt;, respec-        tively.        Case:        a) If either S1 or S2 is the null value, then the result of the          &lt;bit concatenation&gt; is the null value.        b) Otherwise, let S be the string consisting of S1 followed by          S2 and let M be the length in bits of S.          Case:          i) If the data type of either S1 or S2 is variable-length bit             string, then             Case:             1) If M is less than or equal to VL, then the result of the               &lt;bit concatenation&gt; is S with length M.             2) If M is greater than VL and the right-most M-VL bits of               S are all 0-valued, then the result of the &lt;bit concate-               nation&gt; is the first VL bits of S with length VL.             3) Otherwise, an exception condition is raised: data               exception-string data, right truncation.         ii) If the data types of both S1 and S2 are fixed-length bit             string, then the result of the &lt;bit concatenation&gt; is S.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) Conforming Intermediate SQL language shall not contain any          &lt;collate clause&gt;.        b) Conforming Intermediate SQL language shall contain no &lt;bit          value expression&gt;.                                                Scalar expressions   163</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.13 &lt;string value expression&gt;     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) A &lt;character value expression&gt; shall not be a &lt;concatena-          tion&gt;.     164  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                        6.14 &lt;datetime value expression&gt;     6.14  &lt;datetime value expression&gt;     Function     Specify a datetime value.     Format     &lt;datetime value expression&gt; ::=            &lt;datetime term&gt;          | &lt;interval value expression&gt; &lt;plus sign&gt; &lt;datetime term&gt;          | &lt;datetime value expression&gt; &lt;plus sign&gt; &lt;interval term&gt;          | &lt;datetime value expression&gt; &lt;minus sign&gt; &lt;interval term&gt;     &lt;datetime term&gt; ::=            &lt;datetime factor&gt;     &lt;datetime factor&gt; ::=            &lt;datetime primary&gt; [ &lt;time zone&gt; ]     &lt;datetime primary&gt; ::=            &lt;value expression primary&gt;          | &lt;datetime value function&gt;     &lt;time zone&gt; ::=          AT &lt;time zone specifier&gt;     &lt;time zone specifier&gt; ::=            LOCAL          | TIME ZONE &lt;interval value expression&gt;     Syntax Rules     1) The data type of a &lt;datetime primary&gt; shall be datetime.     2) Case:        a) If the &lt;datetime value expression&gt; is a &lt;datetime term&gt;, then          the precision of the result of the &lt;datetime value expres-          sion&gt; is the precision of the &lt;datetime value function&gt; or          &lt;value expression primary&gt; that it simply contains.        b) Otherwise, the precision of the result of the &lt;datetime value          expression&gt; is the precision of the &lt;datetime value expres-          sion&gt; or &lt;datetime term&gt; that it simply contains.     3) If an &lt;interval value expression&gt; or &lt;interval term&gt; is spec-        ified, then the &lt;interval value expression&gt; or &lt;interval term&gt;        shall only contain &lt;datetime field&gt;s that are contained within        the &lt;datetime value expression&gt; or &lt;datetime term&gt;.                                                Scalar expressions   165</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.14 &lt;datetime value expression&gt;     4) The data type of the &lt;interval value expression&gt; immediately        contained in a &lt;time zone specifier&gt; shall be INTERVAL HOUR TO        MINUTE.     5) Case:        a) If the data type of the &lt;datetime primary&gt; is DATE, then          &lt;time zone&gt; shall not be specified.        b) If the data type of the &lt;datetime primary&gt; is TIME or          TIMESTAMP and &lt;time zone&gt; is not specified, then &quot;AT LOCAL&quot;          is implicit.     Access Rules        None.     General Rules     1) If the result of any &lt;datetime primary&gt;, &lt;interval value expres-        sion&gt;, &lt;datetime value expression&gt;, or &lt;interval term&gt; simply        contained in a &lt;datetime value expression&gt; is the null value,        then the result of the &lt;datetime value expression&gt; is the null        value.     2) If &lt;time zone&gt; is specified or implied and the &lt;interval value        expression&gt; immediately contained in &lt;time zone specifier&gt; is        the null value, then the result of the &lt;datetime value expres-        sion&gt; is the null value.     3) If a &lt;datetime value expression&gt; immediately contains the opera-        tor + or -, then the result is effectively evaluated as follows:        a) Case:          i) If &lt;datetime value expression&gt; immediately contains the             operator + and the &lt;interval value expression&gt; or &lt;interval             term&gt; is not negative, or if &lt;datetime value expression&gt;             immediately contains the operator - and the &lt;interval term&gt;             is negative, then successive &lt;datetime field&gt;s of the &lt;in-             terval value expression&gt; or &lt;interval term&gt; are added to             the corresponding fields of the &lt;datetime value expression&gt;             or &lt;datetime term&gt;.         ii) Otherwise, successive &lt;datetime field&gt;s of the &lt;interval             value expression&gt; or &lt;interval term&gt; are subtracted from             the corresponding fields of the &lt;datetime value expression&gt;             or &lt;datetime term&gt;.        b) Arithmetic is performed so as to maintain the integrity of          the datetime data type that is the result of the &lt;datetime          value expression&gt;. This may involve carry from or to the          immediately next more significant &lt;datetime field&gt;. If the          data type of the &lt;datetime value expression&gt; is TIME, then     166  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                        6.14 &lt;datetime value expression&gt;          arithmetic on the HOUR &lt;datetime field&gt; is undertaken modulo          24. If the &lt;interval value expression&gt; or &lt;interval term&gt; is          a year-month interval, then the DAY field of the result is          the same as the DAY field of the &lt;datetime term&gt; or &lt;datetime          value expression&gt;.        c) If, after the preceding step, any &lt;datetime field&gt; of the          result is outside the permissible range of values for the          field or the result is invalid based on the natural rules for          dates and times, then an exception condition is raised: data          exception-datetime field overflow.          Note: For the permissible range of values for &lt;datetime          field&gt;s, see Table 10, &quot;Valid values for fields in datetime          items&quot;.     4) If &lt;time zone&gt; is specified or implied, then:        a) If LOCAL is specified, then let TZ be the current default          time zone displacement of the SQL-session. Otherwise, let          TZ be the value of the &lt;simple value specification&gt; simply          contained in the &lt;time zone&gt;.        b) If the value of the &lt;interval value expression&gt; immediately          contained in &lt;time zone specifier&gt; is less than INTERVAL          -&#39;12:59&#39; or greater than INTERVAL +&#39;13:00&#39;, then an excep-          tion condition is raised: data exception-invalid time zone          displacement value.        c) Let DV be the value of the &lt;datetime primary&gt; directly con-          tained in the &lt;datetime value expression&gt; expressed as a          datetime normalized to UTC.        d) The value of the &lt;datetime value expression&gt; is calculated          as:             DV - TZ     Leveling Rules     1) The following restrictions apply for Intermediate SQL:          None.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) Conforming Entry SQL language shall not contain any &lt;datetime          value expression&gt;.                                                Scalar expressions   167</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.15 &lt;interval value expression&gt;     6.15  &lt;interval value expression&gt;     Function     Specify an interval value.     Format     &lt;interval value expression&gt; ::=            &lt;interval term&gt;          | &lt;interval value expression 1&gt; &lt;plus sign&gt; &lt;interval term 1&gt;          | &lt;interval value expression 1&gt; &lt;minus sign&gt; &lt;interval term 1&gt;          | &lt;left paren&gt; &lt;datetime value expression&gt; &lt;minus sign&gt;                &lt;datetime term&gt; &lt;right paren&gt; &lt;interval qualifier&gt;     &lt;interval term&gt; ::=            &lt;interval factor&gt;          | &lt;interval term 2&gt; &lt;asterisk&gt; &lt;factor&gt;          | &lt;interval term 2&gt; &lt;solidus&gt; &lt;factor&gt;          | &lt;term&gt; &lt;asterisk&gt; &lt;interval factor&gt;     &lt;interval factor&gt; ::=          [ &lt;sign&gt; ] &lt;interval primary&gt;     &lt;interval primary&gt; ::=            &lt;value expression primary&gt; [ &lt;interval qualifier&gt; ]     &lt;interval value expression 1&gt; ::= &lt;interval value expression&gt;     &lt;interval term 1&gt; ::= &lt;interval term&gt;     &lt;interval term 2&gt; ::= &lt;interval term&gt;     Syntax Rules     1) The data type of an &lt;interval value expression&gt; is interval. The        data type of an &lt;interval primary&gt; shall be interval.     2) An &lt;interval primary&gt; shall specify &lt;interval qualifier&gt; only if        the &lt;interval primary&gt; specifies a &lt;dynamic parameter specifica-        tion&gt;.     3) Case:        a) If the &lt;interval value expression&gt; simply contains an &lt;in-          terval qualifier&gt;, then the result contains the &lt;datetime          field&gt;s specified in the &lt;interval qualifier&gt;.        b) If the &lt;interval value expression&gt; is an &lt;interval term&gt;,          then the result of an &lt;interval value expression&gt; contains          the same &lt;datetime field&gt;s as the &lt;interval primary&gt;.     168  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                        6.15 &lt;interval value expression&gt;        c) If &lt;interval term 1&gt; is specified, then the result contains          all the &lt;datetime field&gt;s that are contained within either          &lt;interval value expression 1&gt; or &lt;interval term 1&gt;.     4) Case:        a) If &lt;interval term 1&gt; is a year-month interval, then &lt;interval          value expression 1&gt; shall be a year-month interval.        b) If &lt;interval term 1&gt; is a day-time interval, then &lt;interval          value expression 1&gt; shall be a day-time interval.     5) If &lt;datetime value expression&gt; is specified, then &lt;datetime        value expression&gt; and &lt;datetime term&gt; shall be comparable.     Access Rules        None.     General Rules     1) If an &lt;interval term&gt; specifies &quot;&lt;term&gt; * &lt;interval factor&gt;&quot;,        then let T and F be respectively the value of the &lt;term&gt; and        the value of the &lt;interval factor&gt;. The result of the &lt;interval        term&gt; is the result of F * T.     2) If the result of any &lt;interval primary&gt;, &lt;datetime value ex-        pression&gt;, &lt;datetime term&gt;, or &lt;factor&gt; simply contained in an        &lt;interval value expression&gt; is the null value, then the result        of the &lt;interval value expression&gt; is the null value.     3) If the &lt;sign&gt; of an &lt;interval factor&gt; is &lt;minus sign&gt;, then the        value of the &lt;interval factor&gt; is the negative of the value of        the &lt;interval primary&gt;.     4) If &lt;interval term 2&gt; is specified, then:        a) Let X be the value of &lt;interval term 2&gt; and let Y be the          value of &lt;factor&gt;.        b) Let P and Q be respectively the most significant and least          significant &lt;datetime field&gt;s of &lt;interval term 2&gt;.        c) Let E be an exact numeric result of the operation             CAST (CAST (X AS INTERVAL Q) AS E1)          where E1 is an exact numeric data type of sufficient scale          and precision so as to not lose significant digits.        d) Let OP be the operator * or / specified in the &lt;interval          value expression&gt;.                                                Scalar expressions   169</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     6.15 &lt;interval value expression&gt;        e) Let I, the result of the &lt;interval value expression&gt; ex-          pressed in terms of the &lt;datetime field&gt; Q, be the result          of             CAST ((E OP Y) AS INTERVAL Q).        f) The result of the &lt;interval value expression&gt; is             CAST (I AS INTERVAL W)          where W is an &lt;interval qualifier&gt; identifying the &lt;datetime          field&gt;s P TO Q, but with &lt;interval leading field precision&gt;          such that significant digits are not lost.     5) If &lt;interval term 1&gt; is specified, then let P and Q be respec-        tively the most significant and least significant &lt;datetime        field&gt;s in &lt;interval term 1&gt; and &lt;interval value expression 1&gt;,        let X be the value of &lt;interval value expression 1&gt;, and let Y        be the value of &lt;interval term 1&gt;.        a) Let A be an exact numeric result of the operation             CAST (CAST (X AS INTERVAL Q) AS E1)          where E1 is an exact numeric data type of sufficient scale          and precision so as to not lose significant digits.        b) Let B be an exact numeric result of the operation             CAST (CAST (Y AS INTERVAL Q) AS E2)          where E2 is an exact numeric data type of sufficient scale          and precision so as to not lose significant digits.        c) Let OP be the operator + or - specified in the &lt;interval          value expression&gt;.        d) Let I, the result of the &lt;interval value expression&gt; ex-          pressed in terms of the &lt;datetime field&gt; Q, be the result          of:             CAST ((A OP B) AS INTERVAL Q)        e) The result of the &lt;interval value expression&gt; is             CAST (I AS INTERVAL W)          where W is an &lt;interval qualifier&gt; identifying the &lt;datetime          field&gt;s P TO Q, but with &lt;interval leading field precision&gt;          such that significant digits are not lost.     6) If &lt;datetime value expression&gt; is specified, then let Y be the        least significant &lt;datetime field&gt; specified by &lt;interval qual-        ifier&gt;. Let A be the value represented by &lt;datetime value ex-        pression&gt; and let B be the value represented by &lt;datetime term&gt;.     170  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                        6.15 &lt;interval value expression&gt;        Evaluation of &lt;interval value expression&gt; proceeds as follows:        a) A and B are converted to integer scalars A2 and B2 respec-          tively in units Y as displacements from some implementation-          dependent start datetime.        b) The result is determined by effectively computing A2-B2 and          then converting the difference to an interval using an &lt;in-          terval qualifier&gt; whose &lt;end field&gt; is Y and whose &lt;start          field&gt; is sufficiently significant to avoid loss of signif-          icant digits. That interval is then converted to an inter-          val using the specified &lt;interval qualifier&gt;, rounding or          truncating if necessary. The choice of whether to round or          truncate is implementation-defined.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:          None.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) Conforming Entry SQL language shall not contain any &lt;interval          value expression&gt;.                                                Scalar expressions   171</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     172  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002     7  Query expressions     7.1  &lt;row value constructor&gt;     Function     Specify an ordered set of values to be constructed into a row or     partial row.     Format     &lt;row value constructor&gt; ::=            &lt;row value constructor element&gt;          | &lt;left paren&gt; &lt;row value constructor list&gt; &lt;right paren&gt;          | &lt;row subquery&gt;     &lt;row value constructor list&gt; ::=          &lt;row value constructor element&gt;              [ &#123; &lt;comma&gt; &lt;row value constructor element&gt; &#125;... ]     &lt;row value constructor element&gt; ::=            &lt;value expression&gt;          | &lt;null specification&gt;          | &lt;default specification&gt;     &lt;null specification&gt; ::=          NULL     &lt;default specification&gt; ::=          DEFAULT     Syntax Rules     1) If a &lt;row value constructor&gt; simply contains a &lt;null speci-        fication&gt; or a &lt;default specification&gt;, then the &lt;row value        constructor&gt; shall be simply contained in a &lt;query expression&gt;        that is simply contained in an &lt;insert statement&gt;.     2) A &lt;row value constructor element&gt; immediately contained in a        &lt;row value constructor&gt; shall not be a &lt;value expression&gt; of the        form &quot;&lt;left paren&gt; &lt;value expression&gt; &lt;right paren&gt;&quot;.        Note: This Rule removes a syntactic ambiguity. A &lt;row value        constructor&gt; of this form is permitted, but is parsed in the        form &quot;&lt;left paren&gt; &lt;row value constructor list&gt; &lt;right paren&gt;&quot;.                                                 Query expressions   173</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.1 &lt;row value constructor&gt;     3) A &lt;row value constructor&gt; that immediately contains a &lt;row value        constructor element&gt; X is equivalent to a &lt;row value construc-        tor&gt; of the form          ( X )     4) The data types of the column or columns of a &lt;row value con-        structor&gt; are the data types of the &lt;row value constructor ele-        ment&gt; or &lt;row value constructor element&gt;s or the columns of the        &lt;row subquery&gt; simply contained in the &lt;row value constructor&gt;.     5) If a &lt;row value constructor&gt; is derived from a &lt;row subquery&gt;,        then the degree of the &lt;row value constructor&gt; is the degree        of the table resulting from the &lt;row subquery&gt;; otherwise, the        degree of the &lt;row value constructor&gt; is the number of &lt;row        value constructor element&gt;s that occur in its specification.     Access Rules        None.     General Rules     1) The value of a &lt;null specification&gt; is the null value.     2) The value of a &lt;default specification&gt; is the default value in-        dicated in the column descriptor for the corresponding column in        the explicit or implicit &lt;insert column list&gt; simply contained        in the &lt;insert statement&gt;.     3) Case:        a) If a &lt;row value constructor list&gt; is specified, then the re-          sult of the &lt;row value constructor&gt; is a row of columns whose          i-th column has an implementation-dependent name different          from the &lt;column name&gt; of all other columns contained in the          SQL-statement and whose value is the value of the i-th &lt;row          value constructor element&gt; in the &lt;row value constructor          list&gt;.        b) If the &lt;row value constructor&gt; is a &lt;row subquery&gt;, then:          i) Let R be the result of the &lt;row subquery&gt; and let D be the             degree of R.         ii) If the cardinality of R is 0, then the result of the &lt;row             value constructor&gt; is D null values.        iii) If the cardinality of R is 1, then the result of the &lt;row             value constructor&gt; is R.     174  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                             7.1 &lt;row value constructor&gt;     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) A &lt;row value constructor&gt; that is not simply contained in          a &lt;table value constructor&gt; shall not contain more than one          &lt;row value constructor element&gt;.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) A &lt;row value constructor element&gt; shall not specify DEFAULT.                                                 Query expressions   175</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.2 &lt;table value constructor&gt;     7.2  &lt;table value constructor&gt;     Function     Specify a set of &lt;row value constructor&gt;s to be constructed into a     table.     Format     &lt;table value constructor&gt; ::=          VALUES &lt;table value constructor list&gt;     &lt;table value constructor list&gt; ::=          &lt;row value constructor&gt; [ &#123; &lt;comma&gt; &lt;row value constructor&gt; &#125;... ]     Syntax Rules     1) All &lt;row value constructor&gt;s shall be of the same degree.     Access Rules        None.     General Rules     1) Let Ti be a table whose j-th column has the same data type as        the j-th &lt;value expression&gt; in the i-th &lt;row value construc-        tor&gt; and let Ti contain one row whose j-th column has the same        value as the j-th &lt;value expression&gt; in the i-th &lt;row value        constructor&gt;.     2) The result of the &lt;table value constructor&gt; is the same as the        result of          T1 [ UNION ALL T2 [ . . . UNION ALL n ] . . . ]     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) A &lt;table value constructor&gt; shall contain exactly one &lt;row          value constructor&gt; that shall be of the form &quot;(&lt;row value          constructor list&gt;)&quot;.        b) A &lt;table value constructor&gt; shall be the &lt;query expression&gt;          of an &lt;insert statement&gt;.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:          None.     176  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                  7.3 &lt;table expression&gt;     7.3  &lt;table expression&gt;     Function     Specify a table or a grouped table.     Format     &lt;table expression&gt; ::=          &lt;from clause&gt;          [ &lt;where clause&gt; ]          [ &lt;group by clause&gt; ]          [ &lt;having clause&gt; ]     Syntax Rules     1) The result of a &lt;table expression&gt; is a derived table in which        the descriptor of the i-th column is the same as the descriptor        of the i-th column of the table specified by the &lt;from clause&gt;.     2) Let C be some column. Let TE be the &lt;table expression&gt;. C is an        underlying column of TE if and only if C is an underlying column        of some &lt;column reference&gt; contained in TE.     Access Rules        None.     General Rules     1) If all optional clauses are omitted, then the result of the &lt;ta-        ble expression&gt; is the same as the result of the &lt;from clause&gt;.        Otherwise, each specified clause is applied to the result of        the previously specified clause and the result of the &lt;table ex-        pression&gt; is the result of the application of the last specified        clause.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:          None.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) If the table identified in the &lt;from clause&gt; is a grouped          view, then the &lt;table expression&gt; shall not contain a &lt;where          clause&gt;, &lt;group by clause&gt;, or &lt;having clause&gt;.                                                 Query expressions   177</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.4 &lt;from clause&gt;     7.4  &lt;from clause&gt;     Function     Specify a table derived from one or more named tables.     Format     &lt;from clause&gt; ::= FROM &lt;table reference&gt; [ &#123; &lt;comma&gt; &lt;table reference&gt; &#125;... ]     Syntax Rules     1) Case:        a) If the &lt;from clause&gt; contains a single &lt;table reference&gt; with          no intervening &lt;derived table&gt; or &lt;joined table&gt;, then the          descriptor of the result of the &lt;from clause&gt; is the same          as the descriptor of the table identified by that &lt;table          reference&gt;.        b) If the &lt;from clause&gt; contains more than one &lt;table reference&gt;          with no intervening &lt;derived table&gt; or &lt;joined table&gt;, then          the descriptors of the columns of the result of the &lt;from          clause&gt; are the descriptors of the columns of the tables          identified by the &lt;table reference&gt;s, in the order in which          the &lt;table reference&gt;s appear in the &lt;from clause&gt; and in the          order in which the columns are defined within each table.     Access Rules        None.     General Rules     1) Case:        a) If the &lt;from clause&gt; contains a single &lt;table reference&gt; with          no intervening &lt;derived table&gt; or &lt;joined table&gt;, then the          result of the &lt;from clause&gt; is the table identified by that          &lt;table reference&gt;.        b) If the &lt;from clause&gt; contains more than one &lt;table reference&gt;          with no intervening &lt;derived table&gt; or &lt;joined table&gt;, then          the result of the &lt;from clause&gt; is the extended Cartesian          product of the tables identified by those &lt;table reference&gt;s.          The extended Cartesian product, CP, is the multiset of all          rows R such that R is the concatenation of a row from each          of the identified tables in the order in which they are iden-          tified. The cardinality of CP is the product of the cardi-          nalities of the identified tables. The ordinal position of a     178  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                       7.4 &lt;from clause&gt;          column in CP is N+S, where N is the ordinal position of that          column in the identified table T from which it is derived and          S is the sum of the degrees of the tables identified before T          in the &lt;from clause&gt;.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:          None.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) If the table identified by &lt;table name&gt; is a grouped view,          then the &lt;from clause&gt; shall contain exactly one &lt;table ref-          erence&gt;.                                                 Query expressions   179</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.5 &lt;joined table&gt;     7.5  &lt;joined table&gt;     Function     Specify a table derived from a Cartesian product, inner or outer     join, or union join.     Format     &lt;joined table&gt; ::=            &lt;cross join&gt;          | &lt;qualified join&gt;          | &lt;left paren&gt; &lt;joined table&gt; &lt;right paren&gt;     &lt;cross join&gt; ::=          &lt;table reference&gt; CROSS JOIN &lt;table reference&gt;     &lt;qualified join&gt; ::=          &lt;table reference&gt; [ NATURAL ] [ &lt;join type&gt; ] JOIN            &lt;table reference&gt; [ &lt;join specification&gt; ]     &lt;join specification&gt; ::=            &lt;join condition&gt;          | &lt;named columns join&gt;     &lt;join condition&gt; ::= ON &lt;search condition&gt;     &lt;named columns join&gt; ::=          USING &lt;left paren&gt; &lt;join column list&gt; &lt;right paren&gt;     &lt;join type&gt; ::=            INNER          | &lt;outer join type&gt; [ OUTER ]          | UNION     &lt;outer join type&gt; ::=            LEFT          | RIGHT          | FULL     &lt;join column list&gt; ::= &lt;column name list&gt;     Syntax Rules     1) Let TR1 and TR2 be the first and second &lt;table reference&gt;s of        the &lt;joined table&gt;, respectively. Let T1 and T2 be the tables        identified by TR1 and TR2, respectively. Let TA and TB be the        correlation names of TR1 and TR2, respectively. Let CP be:          SELECT * FROM TR1, TR2     2) If a &lt;qualified join&gt; is specified, then     180  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                      7.5 &lt;joined table&gt;        Case:        a) If NATURAL is specified, then a &lt;join specification&gt; shall          not be specified.        b) If UNION is specified, then neither NATURAL nor a &lt;join spec-          ification&gt; shall be specified.        c) Otherwise, a &lt;join specification&gt; shall be specified.     3) If a &lt;qualified join&gt; is specified and a &lt;join type&gt; is not        specified, then INNER is implicit.     4) If a &lt;qualified join&gt; containing a &lt;join condition&gt; is speci-        fied, then;        a) Each &lt;column reference&gt; directly contained in the &lt;search          condition&gt; shall unambiguously reference a column of T1 or T2          or be an outer reference.        b) If a &lt;value expression&gt; directly contained in the &lt;search          condition&gt; is a &lt;set function specification&gt;, then the          &lt;joined table&gt; shall be contained in a &lt;having clause&gt; or          &lt;select list&gt; and the &lt;set function specification&gt; shall          contain a &lt;column reference&gt; that is an outer reference.        Note: Outer reference is defined in Subclause 6.4, &quot;&lt;column        reference&gt;&quot;.     5) If neither NATURAL is specified nor a &lt;join specification&gt; sim-        ply containing a &lt;named columns join&gt; is specified, then the        descriptors of the columns of the result of the &lt;joined table&gt;        are the same as the descriptors of the columns of CP.     6) If NATURAL is specified or if a &lt;join specification&gt; simply        containing a &lt;named columns join&gt; is specified, then:        a) If NATURAL is specified, then let common column name be a          &lt;column name&gt; that is the &lt;column name&gt; of exactly one column          of T1 and the &lt;column name&gt; of exactly one column of T2. T1          shall not have any duplicate common column names and T2 shall          not have any duplicate common column names. Let corresponding          join columns refer to all columns of T1 and T2 that have          common column names, if any.        b) If a &lt;named columns join&gt; is specified, then every &lt;column          name&gt; in the &lt;join column list&gt; shall be the &lt;column name&gt;          of exactly one column of T1 and the &lt;column name&gt; of exactly          one column of T2. Let common column name be the name of such          a column. Let corresponding join columns refer to the columns          of T1 and T2 identified in the &lt;join column list&gt;.        c) Let 1 and C2 be a pair of corresponding join columns con-          tained in T1 and T2, respectively. C1 and C2 shall be compa-          rable.                                                 Query expressions   181</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.5 &lt;joined table&gt;        d) Let SLCC be a &lt;select list&gt; of &lt;derived column&gt;s of the form             COALESCE ( TA.C, TB.C ) AS C          for every column C that is a corresponding join column, taken          in order of their ordinal positions in T1.        e) Let SL1 be a &lt;select list&gt; of those &lt;column name&gt;s of T1          that are not corresponding join columns, taken in order of          their ordinal positions in T1, and let SLT2 be a &lt;select          list&gt; of those &lt;column name&gt;s of T2 that are not correspond-          ing join columns, taken in order of their ordinal positions          in T2.        f) The descriptors of the columns of the result of the &lt;joined          table&gt; are the same as the descriptors of the columns of the          result of             SELECT SLCC, SLT1, SLT2 FROM TR1, TR2     7) For every column CR of the result of the &lt;joined table&gt; that        is not a corresponding join column and that corresponds to a        column C1 of T1, CR is possibly nullable if any of the following        conditions are true:        a) RIGHT, FULL, or UNION is specified, or        b) INNER, LEFT, or CROSS JOIN is specified or implicit and 1 is          possibly nullable.     8) For every column CR of the result of the &lt;joined table&gt; that        is not a corresponding join column and that corresponds to a        column C2 of T2, CR is possibly nullable if any of the following        conditions are true:        a) LEFT, FULL, or UNION is specified, or        b) INNER, RIGHT, or CROSS JOIN is specified or implicit and C          is possibly nullable.     9) For every column CR of the result of the &lt;joined table&gt; that        is a corresponding join column and that corresponds to a column        C1 of T1 and C2 of T2, CR is possibly nullable if any of the        following conditions are true:        a) RIGHT, FULL, or UNION is specified and 1 is possibly nul-          lable, or        b) LEFT, FULL, or UNION is specified and 2 is possibly nul-          lable.     10)The &lt;joined table&gt; is a read-only table.     182  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                      7.5 &lt;joined table&gt;     Access Rules        None.     General Rules     1) Case:        a) If &lt;join type&gt; is UNION, then let T be the empty set.        b) If a &lt;cross join&gt; is specified, then let T be the multiset of          rows of CP.        c) If a &lt;join condition&gt; is specified, then let T be the multi-          set of rows of CP for which the specified &lt;search condition&gt;          is true.        d) If NATURAL is specified or &lt;named columns join&gt; is specified,          then          Case:          i) If there are corresponding join columns, then let T be the             multiset of rows of CP for which the corresponding join             columns have equal values.         ii) Otherwise, let T be the multiset of rows of CP.     2) Let P1 be the multiset of rows of T1 for which there exists in T        some row that is the concatenation of some row R1 of T1 and some        row R2 of T2. Let P2 be the multiset of rows of T2 for which        there exists in T some row that is the concatenation of some row        R1 of T1 and some row R2 of T2.     3) Let U1 be those rows of T1 that are not in P1 and let U2 be        those rows of T2 that are not in P2.     4) Let D1 and D2 be the degree of T1 and T2, respectively. Let        X1 be U1 extended on the right with D2 columns containing the        null value. Let X2 be U2 extended on the left with D1 columns        containing the null value.     5) Let XN1 and XN2 be effective distinct names for X1 and X2, re-        spectively. Let TN be an effective name for T.        Case:        a) If INNER or &lt;cross join&gt; is specified, then let S be the          multiset of rows of T.        b) If LEFT is specified, then let S be the multiset of rows          resulting from:             SELECT * FROM TN             UNION ALL             SELECT * FROM XN1                                                 Query expressions   183</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.5 &lt;joined table&gt;        c) If RIGHT is specified, then let S be the multiset of rows          resulting from:             SELECT * FROM TN             UNION ALL             SELECT * FROM XN2        d) If FULL is specified, then let S be the multiset of rows          resulting from:             SELECT * FROM TN             UNION ALL             SELECT * FROM XN1             UNION ALL             SELECT * FROM XN2        e) If UNION is specified, then let S be the multiset of rows          resulting from:             SELECT * FROM XN1             UNION ALL             SELECT * FROM XN2     6) Let SN be an effective name of S.        Case:        a) If NATURAL is specified or a &lt;named columns join&gt; is speci-          fied, then the result of the &lt;joined table&gt; is the multiset          of rows resulting from:             SELECT SLCC, SLT1, SLT2 FROM SN        b) Otherwise, the result of the &lt;joined table&gt; is S.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) Conforming Intermediate SQL language shall contain no &lt;cross          join&gt;.        b) Conforming Intermediate SQL language shall not specify UNION          JOIN.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) Conforming Entry SQL language shall not contain any &lt;joined          table&gt;.     184  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                      7.6 &lt;where clause&gt;     7.6  &lt;where clause&gt;     Function     Specify a table derived by the application of a &lt;search condition&gt;     to the result of the preceding &lt;from clause&gt;.     Format     &lt;where clause&gt; ::= WHERE &lt;search condition&gt;     Syntax Rules     1) Let T be the result of the preceding &lt;from clause&gt;. Each &lt;column        reference&gt; directly contained in the &lt;search condition&gt; shall        unambiguously reference a column of T or be an outer reference.        Note: Outer reference is defined in Subclause 6.4, &quot;&lt;column        reference&gt;&quot;.     2) If a &lt;value expression&gt; directly contained in the &lt;search condi-        tion&gt; is a &lt;set function specification&gt;, then the &lt;where clause&gt;        shall be contained in a &lt;having clause&gt; or &lt;select list&gt; and the        &lt;column reference&gt; in the &lt;set function specification&gt; shall be        an outer reference.        Note: Outer reference is defined in Subclause 6.4, &quot;&lt;column        reference&gt;&quot;.     3) No &lt;column reference&gt; contained in a &lt;subquery&gt; in the &lt;search        condition&gt; that references a column of T shall be specified in a        &lt;set function specification&gt;.     Access Rules        None.     General Rules     1) The &lt;search condition&gt; is applied to each row of T. The result        of the &lt;where clause&gt; is a table of those rows of T for which        the result of the &lt;search condition&gt; is true.     2) Each &lt;subquery&gt; in the &lt;search condition&gt; is effectively exe-        cuted for each row of T and the results used in the application        of the &lt;search condition&gt; to the given row of T. If any executed        &lt;subquery&gt; contains an outer reference to a column of T, then        the reference is to the value of that column in the given row of        T.        Note: Outer reference is defined in Subclause 6.4, &quot;&lt;column        reference&gt;&quot;.                                                 Query expressions   185</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.6 &lt;where clause&gt;     Leveling Rules     1) The following restrictions apply for Intermediate SQL:          None.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) A &lt;value expression&gt; directly contained in the &lt;search condi-          tion&gt; shall not include a reference to a column that gener-          ally contains a &lt;set function specification&gt;.     186  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                   7.7 &lt;group by clause&gt;     7.7  &lt;group by clause&gt;     Function     Specify a grouped table derived by the application of the &lt;group by     clause&gt; to the result of the previously specified clause.     Format     &lt;group by clause&gt; ::=          GROUP BY &lt;grouping column reference list&gt;     &lt;grouping column reference list&gt; ::=          &lt;grouping column reference&gt; [ &#123; &lt;comma&gt; &lt;grouping column reference&gt; &#125;... ]     &lt;grouping column reference&gt; ::=          &lt;column reference&gt; [ &lt;collate clause&gt; ]     Syntax Rules     1) If no &lt;where clause&gt; is specified, then let T be the result of        the preceding &lt;from clause&gt;; otherwise, let T be the result of        the preceding &lt;where clause&gt;.     2) Each &lt;column reference&gt; in the &lt;group by clause&gt; shall unambigu-        ously reference a column of T. A column referenced in a &lt;group        by clause&gt; is a grouping column.     3) For every grouping column, if &lt;collate clause&gt; is specified,        then the data type of the &lt;column reference&gt; shall be character        string. The column descriptor of the corresponding column in the        result has the collating sequence specified in &lt;collate clause&gt;        and the coercibility attribute Explicit.     Access Rules        None.     General Rules     1) The result of the &lt;group by clause&gt; is a partitioning of T into        a set of groups. The set is the minimum number of groups such        that, for each grouping column of each group of more than one        row, no two values of that grouping column are distinct.     2) Every row of a given group contains equal values of a given        grouping column. When a &lt;search condition&gt; or &lt;value expression&gt;        is applied to a group, a reference to a grouping column is a        reference to that value.        Note: See the General Rules of Subclause 8.2, &quot;&lt;comparison pred-        icate&gt;&quot;.                                                 Query expressions   187</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.7 &lt;group by clause&gt;     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) Conforming Intermediate SQL language shall not contain any          &lt;collate clause&gt;.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:          None.     188  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                     7.8 &lt;having clause&gt;     7.8  &lt;having clause&gt;     Function     Specify a grouped table derived by the elimination of groups from     the result of the previously specified clause that do not meet the     &lt;search condition&gt;.     Format     &lt;having clause&gt; ::= HAVING &lt;search condition&gt;     Syntax Rules     1) If neither a &lt;where clause&gt; nor a &lt;group by clause&gt; is speci-        fied, then let T be the result of the preceding &lt;from clause&gt;;        if a &lt;where clause&gt; is specified, but a &lt;group by clause&gt; is        not specified, then let T be the result of the preceding &lt;where        clause&gt;; otherwise, let T be the result of the preceding &lt;group        by clause&gt;. Each &lt;column reference&gt; directly contained in the        &lt;search condition&gt; shall unambiguously reference a grouping        column of T or be an outer reference.        Note: Outer reference is defined in Subclause 6.4, &quot;&lt;column        reference&gt;&quot;.     2) Each &lt;column reference&gt; contained in a &lt;subquery&gt; in the &lt;search        condition&gt; that references a column of T shall reference a        grouping column of T or shall be specified within a &lt;set func-        tion specification&gt;.     3) The &lt;having clause&gt; is possibly non-deterministic if it contains        a reference to a column C of T that has a data type of character        string and:        a) C is specified within a &lt;set function specification&gt; that          specifies MIN or MAX, or        b) C is a grouping column of T.     Access Rules        None.     General Rules     1) Let T be the result of the preceding &lt;from clause&gt;, &lt;where        clause&gt;, or &lt;group by clause&gt;. If that clause is not a &lt;group        by clause&gt;, then T consists of a single group and does not have        a grouping column.     2) The &lt;search condition&gt; is applied to each group of T. The result        of the &lt;having clause&gt; is a grouped table of those groups of T        for which the result of the &lt;search condition&gt; is true.                                                 Query expressions   189</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.8 &lt;having clause&gt;     3) When the &lt;search condition&gt; is applied to a given group of T,        that group is the argument or argument source of each &lt;set func-        tion specification&gt; directly contained in the &lt;search condition&gt;        unless the &lt;column reference&gt; in the &lt;set function specifica-        tion&gt; is an outer reference.        Note: Outer reference is defined in Subclause 6.4, &quot;&lt;column        reference&gt;&quot;.     4) Each &lt;subquery&gt; in the &lt;search condition&gt; is effectively exe-        cuted for each group of T and the result used in the application        of the &lt;search condition&gt; to the given group of T. If any exe-        cuted &lt;subquery&gt; contains an outer reference to a column of T,        then the reference is to the values of that column in the given        group of T.        Note: Outer reference is defined in Subclause 6.4, &quot;&lt;column        reference&gt;&quot;.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:          None.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:          None.     190  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                               7.9 &lt;query specification&gt;     7.9  &lt;query specification&gt;     Function     Specify a table derived from the result of a &lt;table expression&gt;.     Format     &lt;query specification&gt; ::=          SELECT [ &lt;set quantifier&gt; ] &lt;select list&gt; &lt;table expression&gt;     &lt;select list&gt; ::=            &lt;asterisk&gt;          | &lt;select sublist&gt; [ &#123; &lt;comma&gt; &lt;select sublist&gt; &#125;... ]     &lt;select sublist&gt; ::=            &lt;derived column&gt;          | &lt;qualifier&gt; &lt;period&gt; &lt;asterisk&gt;     &lt;derived column&gt; ::= &lt;value expression&gt; [ &lt;as clause&gt; ]     &lt;as clause&gt; ::= [ AS ] &lt;column name&gt;     Syntax Rules     1) Let T be the result of the &lt;table expression&gt;.     2) The degree of the table specified by a &lt;query specification&gt; is        equal to the cardinality of the &lt;select list&gt;.     3) Case:        a) If the &lt;select list&gt; &quot;*&quot; is simply contained in a &lt;subquery&gt;          that is immediately contained in an &lt;exists predicate&gt;, then          the &lt;select list&gt; is equivalent to a &lt;value expression&gt; that          is an arbitrary &lt;literal&gt;.        b) Otherwise, the &lt;select list&gt; &quot;*&quot; is equivalent to a &lt;value          expression&gt; sequence in which each &lt;value expression&gt; is a          &lt;column reference&gt; that references a column of T and each          column of T is referenced exactly once. The columns are ref-          erenced in the ascending sequence of their ordinal position          within T.     4) The &lt;select sublist&gt; &quot;&lt;qualifier&gt;.*&quot; for some &lt;qualifier&gt; Q is        equivalent to a &lt;value expression&gt; sequence in which each &lt;value        expression&gt; is a &lt;column reference&gt; CR that references a column        of T that is not a common column of a &lt;joined table&gt;. Each col-        umn of T that is not a common column of a &lt;joined table&gt; shall        be referenced exactly once. The columns shall be referenced in        the ascending sequence of their ordinal positions within T.        Note: common column of a &lt;joined table&gt; is defined in Subclause 7.5,        &quot;&lt;joined table&gt;&quot;.                                                 Query expressions   191</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.9 &lt;query specification&gt;     5) Let C be some column. Let QS be the &lt;query specification&gt;. Let        DCi, for i ranging from 1 to the number of &lt;derived column&gt;s        inclusively, be the i-th &lt;derived column&gt; simply contained in        the &lt;select list&gt; of QS. For all i, C is an underlying column        of DCi, and of any &lt;column reference&gt; that identifies DCi, if        and only if C is an underlying column of the &lt;value expression&gt;        of DCi, or C is an underlying column of the &lt;table expression&gt;        immediately contained in QS.     6) Each &lt;column reference&gt; directly contained in each &lt;value ex-        pression&gt; and each &lt;column reference&gt; contained in a &lt;set        function specification&gt; directly contained in each &lt;value ex-        pression&gt; shall unambiguously reference a column of T.     7) If T is a grouped table, then each &lt;column reference&gt; in each        &lt;value expression&gt; that references a column of T shall refer-        ence a grouping column or be specified within a &lt;set function        specification&gt;. If T is not a grouped table and any &lt;value ex-        pression&gt; contains a &lt;set function specification&gt; that contains        a reference to a column of T or any &lt;value expression&gt; directly        contains a &lt;set function specification&gt; that does not contain an        outer reference, then every &lt;column reference&gt; in every &lt;value        expression&gt; that references a column of T shall be specified        within a &lt;set function specification&gt;.     8) Each column of the table that is the result of a &lt;query spec-        ification&gt; has a column descriptor that includes a data type        descriptor that is the same as the data type descriptor of the        &lt;value expression&gt; from which the column was derived.     9) Case:        a) If the i-th &lt;derived column&gt; in the &lt;select list&gt; specifies          an &lt;as clause&gt; that contains a &lt;column name&gt; C, then the          &lt;column name&gt; of the i-th column of the result is C.        b) If the i-th &lt;derived column&gt; in the &lt;select list&gt; does not          specify an &lt;as clause&gt; and the &lt;value expression&gt; of that          &lt;derived column&gt; is a single &lt;column reference&gt;, then the          &lt;column name&gt; of the i-th column of the result is C.        c) Otherwise, the &lt;column name&gt; of the i-th column of the &lt;query          specification&gt; is implementation-dependent and different          from the &lt;column name&gt; of any column, other than itself, of          a table referenced by any &lt;table reference&gt; contained in the          SQL-statement.     10)A column of the table that is the result of a &lt;query specifica-        tion&gt; is possibly nullable if and only if it contains a &lt;column        reference&gt; for a column C that is possibly nullable, an &lt;indica-        tor parameter&gt;, an &lt;indicator variable&gt;, a &lt;subquery&gt;, CAST NULL        AS X (X represents a &lt;data type&gt; or a &lt;domain name&gt;), SYSTEM_        USER, or a &lt;set function specification&gt; that does not contain        COUNT.     192  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                               7.9 &lt;query specification&gt;     11)Let TREF be the &lt;table reference&gt;s that are simply contained        in the &lt;from clause&gt; of the &lt;table expression&gt;. The simply un-        derlying tables of the &lt;query specification&gt; are the tables        identified by the &lt;table name&gt;s and &lt;derived table&gt;s contained        in TREF without an intervening &lt;derived table&gt;.     12)A &lt;query specification&gt; QS is updatable if and only if the fol-        lowing conditions hold:        a) QS does not specify DISTINCT.        b) Every &lt;value expression&gt; contained in the &lt;select list&gt; imme-          diately contained in QS consists of a &lt;column reference&gt;, and          no &lt;column reference&gt; appears more than once.        c) The &lt;from clause&gt; immediately contained in the &lt;table ex-          pression&gt; immediately contained in QS specifies exactly one          &lt;table reference&gt; and that &lt;table reference&gt; refers either to          a base table or to an updatable derived table.          Note: updatable derived table is defined in Subclause 6.3,          &quot;&lt;table reference&gt;&quot;.        d) If the &lt;table expression&gt; immediately contained in QS imme-          diately contains a &lt;where clause&gt; WC, then no leaf generally          underlying table of QS shall be a generally underlying table          of any &lt;query expression&gt; contained in WC.        e) The &lt;table expression&gt; immediately contained in QS does not          include a &lt;group by clause&gt; or a &lt;having clause&gt;.     13)A &lt;query specification&gt; is possibly non-deterministic if any of        the following conditions are true:        a) The &lt;set quantifier&gt; DISTINCT is specified and one of the          columns of T has a data type of character string; or        b) The &lt;query specification&gt; directly contains a &lt;having clause&gt;          that is possibly non-deterministic; or        c) The &lt;select list&gt; contains a reference to a column C of T          that has a data type of character string and either          i) C is specified with a &lt;set function specification&gt; that             specifies MIN or MAX, or         ii) C is a grouping column of T.     Access Rules        None.                                                 Query expressions   193</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.9 &lt;query specification&gt;     General Rules     1) Case:        a) If T is not a grouped table, then          Case:          i) If the &lt;select list&gt; contains a &lt;set function specifica-             tion&gt; that contains a reference to a column of T or di-             rectly contains a &lt;set function specification&gt; that does             not contain an outer reference, then T is the argument or             argument source of each such &lt;set function specification&gt;             and the result of the &lt;query specification&gt; is a table con-             sisting of 1 row. The i-th value of the row is the value             specified by the i-th &lt;value expression&gt;.         ii) If the &lt;select list&gt; does not include a &lt;set function spec-             ification&gt; that contains a reference to T, then each &lt;value             expression&gt; is applied to each row of T yielding a table of             M rows, where M is the cardinality of T. The i-th column of             the table contains the values derived by the evaluation of             the i-th &lt;value expression&gt;.             Case:             1) If the &lt;set quantifier&gt; DISTINCT is not specified, then               the table is the result of the &lt;query specification&gt;.             2) If the &lt;set quantifier&gt; DISTINCT is specified, then the               result of the &lt;query specification&gt; is the table derived               from that table by the elimination of any redundant               duplicate rows.        b) If T is a grouped table, then          Case:          i) If T has 0 groups, then the result of the &lt;query specifica-             tion&gt; is an empty table.         ii) If T has one or more groups, then each &lt;value expression&gt;             is applied to each group of T yielding a table of M rows,             where M is the number of groups in T. The i-th column of             the table contains the values derived by the evaluation of             the i-th &lt;value expression&gt;. When a &lt;value expression&gt; is             applied to a given group of T, that group is the argument             or argument source of each &lt;set function specification&gt; in             the &lt;value expression&gt;.             Case:             1) If the &lt;set quantifier&gt; DISTINCT is not specified, then               the table is the result of the &lt;query specification&gt;.     194  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                               7.9 &lt;query specification&gt;             2) If the &lt;set quantifier&gt; DISTINCT is specified, then the               result of the &lt;query specification&gt; is the table derived               from T by the elimination of any redundant duplicate               rows.     Leveling Rules     1) The following restrictions apply for Intermediate SQL:        a) The &lt;set quantifier&gt; DISTINCT shall not be specified more          than once in a &lt;query specification&gt;, excluding any &lt;sub-          query&gt; of that &lt;query specification&gt;.     2) The following restrictions apply for Entry SQL in addition to        any Intermediate SQL restrictions:        a) A &lt;query specification&gt; is not updatable if the &lt;where          clause&gt; of the &lt;table expression&gt; contains a &lt;subquery&gt;.        b) A &lt;select sublist&gt; shall be a &lt;derived column&gt;.        c) If the &lt;table expression&gt; of the &lt;query specification&gt; is a          grouped view, then the &lt;select list&gt; shall not contain a &lt;set          function specification&gt;.                                                 Query expressions   195</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.10 &lt;query expression&gt;     7.10  &lt;query expression&gt;     Function     Specify a table.     Format     &lt;query expression&gt; ::=            &lt;non-join query expression&gt;          | &lt;joined table&gt;     &lt;non-join query expression&gt; ::=            &lt;non-join query term&gt;          | &lt;query expression&gt; UNION  [ ALL ] [ &lt;corresponding spec&gt; ] &lt;query term&gt;          | &lt;query expression&gt; EXCEPT [ ALL ] [ &lt;corresponding spec&gt; ] &lt;query term&gt;     &lt;query term&gt; ::=            &lt;non-join query term&gt;          | &lt;joined table&gt;     &lt;non-join query term&gt; ::=            &lt;non-join query primary&gt;          | &lt;query term&gt; INTERSECT [ ALL ] [ &lt;corresponding spec&gt; ] &lt;query primary&gt;     &lt;query primary&gt; ::=            &lt;non-join query primary&gt;          | &lt;joined table&gt;     &lt;non-join query primary&gt; ::=            &lt;simple table&gt;          | &lt;left paren&gt; &lt;non-join query expression&gt; &lt;right paren&gt;     &lt;simple table&gt; ::=            &lt;query specification&gt;          | &lt;table value constructor&gt;          | &lt;explicit table&gt;     &lt;explicit table&gt; ::= TABLE &lt;table name&gt;     &lt;corresponding spec&gt; ::=          CORRESPONDING [ BY &lt;left paren&gt; &lt;corresponding column list&gt; &lt;right paren&gt; ]     &lt;corresponding column list&gt; ::= &lt;column name list&gt;     196  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                 7.10 &lt;query expression&gt;     Syntax Rules     1) Let T be the table specified by the &lt;query expression&gt;.     2) The &lt;explicit table&gt;          TABLE &lt;table name&gt;        is equivalent to the &lt;query expression&gt;          ( SELECT * FROM &lt;table name&gt; )     3) Let set operator be UNION [ALL], EXCEPT [ALL], or INTERSECT        [ALL].     4) T is an updatable table and the &lt;query expression&gt; is updatable        if and only if it simply contains a &lt;query expression&gt; QE or a        &lt;query specification&gt; QS and:        a) the &lt;query expression&gt; contains QE or QS without an inter-          vening &lt;non-join query expression&gt; that specified UNION or          EXCEPT;        b) the &lt;query expression&gt; contains QE or QS without an interven-          ing &lt;non-join query term&gt; that specifies INTERSECT; and        c) QE or QS is updatable.     5) Case:        a) If a &lt;simple table&gt; is a &lt;query specification&gt;, then the          column descriptor of the i-th column of the &lt;simple table&gt; is          the same as the column descriptor of the i-th column of the          &lt;query specification&gt;.        b) If a &lt;simple table&gt; is an &lt;explicit table&gt;, then the column          descriptor of the i-th column of the &lt;simple table&gt; is the          same as the column descriptor of the i-th column of the table          identified by the &lt;table name&gt; contained in the &lt;explicit          table&gt;.        c) Otherwise, the column descriptor of the i-th column of the          &lt;simple table&gt; is same as the column descriptor of the i-          th column of the &lt;table value constructor&gt;, except that the          &lt;column name&gt; is implementation-dependent and different from          the &lt;column name&gt; of any column, other than itself, of a          table referenced by any &lt;table reference&gt; contained in the          SQL-statement.     6) Case:        a) If a &lt;non-join query primary&gt; is a &lt;simple table&gt;, then the          column descriptor of the i-th column of the &lt;non-join query          primary&gt; is the same as the column descriptor of the i-th          column of the &lt;simple table&gt;.                                                 Query expressions   197</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.10 &lt;query expression&gt;        b) Otherwise, the column descriptor of the i-th column of the          &lt;non-join query primary&gt; is the same as the column descriptor          of the i-th column of the &lt;non-join query expression&gt;.     7) Case:        a) If a &lt;query primary&gt; is a &lt;non-join query primary&gt;, then the          column descriptor of the i-th column of the &lt;query primary&gt;          is the same as the column descriptor of the i-th column of          the &lt;non-join query primary&gt;.        b) Otherwise, the column descriptor of the i-th column of the          &lt;query primary&gt; is the same as the column descriptor of the          i-th column of the &lt;joined table&gt;.     8) If a set operator is specified in a &lt;non-join query term&gt; or a        &lt;non-join query expression&gt;, then let T1, T2, and TR be respec-        tively the first operand, the second operand, and the result of        the &lt;non-join query term&gt; or &lt;non-join query expression&gt;. Let        TN1 and TN2 be the effective names for T1 and T2, respectively.     9) If a set operator is specified in a &lt;non-join query term&gt; or a        &lt;non-join query expression&gt;, then let OP be the set operator.        Case:        a) If CORRESPONDING is specified, then:          i) Within the columns of T1, the same &lt;column name&gt; shall not             be specified more than once and within the columns of T2,             the same &lt;column name&gt; shall not be specified more than             once.         ii) At least one column of T1 shall have a &lt;column name&gt; that             is the &lt;column name&gt; of some column of T2.        iii) Case:             1) If &lt;corresponding column list&gt; is not specified, then               let SL be a &lt;select list&gt; of those &lt;column name&gt;s that               are &lt;column name&gt;s of both T1 and T2 in the order that               those &lt;column name&gt;s appear in T1.             2) If &lt;corresponding column list&gt; is specified, then let               SL be a &lt;select list&gt; of those &lt;column name&gt;s explic-               itly appearing in the &lt;corresponding column list&gt; in               the order that these &lt;column name&gt;s appear in the &lt;cor-               responding column list&gt;. Every &lt;column name&gt; in the               &lt;corresponding column list&gt; shall be a &lt;column name&gt; of               both T1 and T2.         iv) The &lt;non-join query term&gt; or &lt;non-join query expression&gt; is             equivalent to:               ( SELECT SL FROM TN1 ) OP ( SELECT SL FROM TN2 )     198  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                 7.10 &lt;query expression&gt;        b) If CORRESPONDING is not specified, then T1 and T2 shall be of          the same degree.     10)Case:        a) If the &lt;non-join query term&gt; is a &lt;non-join query primary&gt;,          then the column descriptor of the i-th column of the &lt;non-          join query term&gt; is same as the column descriptor of the i-th          column of the &lt;non-join query primary&gt;.        b) Otherwise,          i) Case:             1) Let C be the &lt;column name&gt; of the i-th column of T1. If               the &lt;column name&gt; of the i-th column of T2 is C, then               the &lt;column name&gt; of the i-th column of TR is C.             2) Otherwise, the &lt;column name&gt; of the i-th column of TR is               implementation-dependent and different from the &lt;column               name&gt; of any column, other than itself, of any table               referenced by any &lt;table reference&gt; contained in the               SQL-statement.         ii) The data type of the i-th column of TR is determined by             applying Subclause 9.3, &quot;Set operation result data types&quot;,             to the data types of the i-th column of T1 and the i-th             column of T2. If the i-th column of both T1 and T2 are             known not nullable, then the i-th column of TR is known             not nullable; otherwise, the i-th column of T is possibly             nullable.     11)Case:        a) If a &lt;query term&gt; is a &lt;non-join query term&gt;, then the column          descriptor of the i-th column of the &lt;query term&gt; is the same          as the column descriptor of the i-th column of the &lt;non-join          query term&gt;.        b) Otherwise, the column descriptor of the i-th column of the          &lt;query term&gt; is the same as the column descriptor of the i-th          column of the &lt;joined table&gt;.     12)Case:        a) If a &lt;non-join query expression&gt; is a &lt;non-join query term&gt;,          then the column descriptor of the i-th column of the &lt;non-          join query expression&gt; is the same as the column descriptor          of the i-th column of the &lt;non-join query term&gt;.                                                 Query expressions   199</code></pre><p></p><pre><code>      X3H2-92-154/DBL CBR-002     7.10 &lt;query expression&gt;        b) Otherwise,          i) Case:             1) Let C be the &lt;column name&gt; of the i-th column of T1. If               the &lt;column name&gt; of the i-th column of T2 is C, then               the &lt;column name&gt; of the i-th column of TR is C.             2) Otherwise, the &lt;column name&gt; of the i-th column of TR is               implementation-dependent and different from the &lt;column               name&gt; of any column, other than itself, of any table               referenced by any &lt;table reference&gt; contained in the               SQL-statement.         ii) The data type of the i-th column of TR is determined by             applying Subclause 9.3, &quot;Set operation result data types&quot;,             to the data types of the i-th column of T1 and the i-th             column of T2. If the i-th column of both T1 and T2 are             known not nullable, then the i-th column of TR is known             not nullable; otherwise, the i-th column of T is possibly             nullable.     13)Case:        a) If a &lt;query expression&gt; is a &lt;non-join query expression&gt;,          then the column descriptor of the i-th column of the &lt;query          expression&gt; is the same as the column descriptor of the i-th          column of the &lt;non-join query expression&gt;.        b) Otherwise, the column descriptor of the i-th column of the          &lt;query expression&gt; is the same as the column descriptor of          the i-th column of the &lt;joined table&gt;.     14)The simply underlying tables of a &lt;query expression&gt; are the        tables identified by those &lt;table name&gt;s, &lt;query expression&gt;s,        and &lt;derived table&gt;s contained in the &lt;query expression&gt; without        an intervening &lt;derived table&gt;, an intervening &lt;query specifica-        tion&gt;, or an intervening &lt;join condition&gt;.     15)A &lt;query expression&gt; is possibly non-deterministic if        a) it contains a set operator UNION and ALL is not specified, or          if it contains EXCEPT or INTERSECT; and        b) the first or second operand contains a column that has a data          type of character string.     16)The underlying columns of each column of QE and of QE itself are        defined as follows:        a) A column of a &lt;table value constructor&gt; has no underlying          columns.        b) The underlying columns of every i-th column of a &lt;simple          table&gt; ST are the underlying columns of the i-th column of          the table immediately contained in ST.     200  Database Language SQL</code></pre><p></p><pre><code>                                                X3H2-92-154/DBL CBR-002                                                 7.10 &lt;query expression&gt;        c) If no set operator is specified, then the underlying columns          of every i-th column of QE are the underlying columns of the          i-th column of the &lt;simple table&gt; simply contained in QE.        d) If a set operator is specified, then the underlying columns          of every i-th column of QE are the underlying columns of the          i-th column of T1 and those of the i-th column of T2.        e) Let C be some column. C is an underlying column of QE if and          only if C is an underlying column of some column of QE.     Access Rules        None.     General Rules     1) Case:        a) If no set operator is specified, then T is the result of the          specified &lt;simple table&gt; or &lt;joined table&gt;.        b) If a set operator is specified, then the result of applying          the set operator is a table containing the following rows:          i) Let R be a row that is a duplicate of some row in T1 or of             some row in T2 or both. Let m be the number of duplicates             of R in T1 and let n be the number of duplicates of R in             T2, where m </code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt</a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源地址：&lt;a href=&quot;http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt&quot;&gt;http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>exist和in的使用</title>
    <link href="http://yoursite.com/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/exist%E5%92%8Cin%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/wiki/中间件/MySQL/exist和in的使用/</id>
    <published>2021-04-11T03:53:35.000Z</published>
    <updated>2021-04-19T06:29:54.496Z</updated>
    
    <content type="html"><![CDATA[<p>如果查询的两个表大小相当，那么用in和exists差别不大。<br>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</p><p>例如：表A（小表），表B（大表）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以A表为主表</span></span><br><span class="line"><span class="comment">-- 效率低，用到了A表上cc列的索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> cc <span class="keyword">in</span> (<span class="keyword">select</span> cc <span class="keyword">from</span> B) </span><br><span class="line"><span class="comment">-- 效率高，用到了B表上cc列的索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> cc <span class="keyword">from</span> B <span class="keyword">where</span> cc<span class="operator">=</span>A.cc) </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以B表为主表</span></span><br><span class="line"><span class="comment">-- 效率高，用到了B表上cc列的索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> B <span class="keyword">where</span> cc <span class="keyword">in</span> (<span class="keyword">select</span> cc <span class="keyword">from</span> A) </span><br><span class="line"><span class="comment">-- 效率低，用到了A表上cc列的索引</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> B <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> cc <span class="keyword">from</span> A <span class="keyword">where</span> cc<span class="operator">=</span>B.cc)        </span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果查询的两个表大小相当，那么用in和exists差别不大。&lt;br&gt;如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。&lt;/p&gt;
&lt;p&gt;例如：表A（小表），表B（大表）&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>InnoDB存储引擎</title>
    <link href="http://yoursite.com/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>http://yoursite.com/wiki/中间件/MySQL/InnoDB存储引擎/</id>
    <published>2021-04-10T15:28:27.000Z</published>
    <updated>2021-04-19T06:29:54.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="14-1"><a href="#14-1" class="headerlink" title="14.1"></a>14.1</h2><h2 id="InnoDB-In-Memory-Structures"><a href="#InnoDB-In-Memory-Structures" class="headerlink" title="InnoDB In-Memory Structures"></a>InnoDB In-Memory Structures</h2><ul><li>Buffer Pool</li><li>Change Buffer</li><li>Adaptive Hash Index</li><li>Log Buffer</li></ul><h2 id="InnoDB-On-Disk-Structures"><a href="#InnoDB-On-Disk-Structures" class="headerlink" title="InnoDB On-Disk Structures"></a>InnoDB On-Disk Structures</h2><h3 id="Tablespace"><a href="#Tablespace" class="headerlink" title="Tablespace"></a>Tablespace</h3><p><a href="https://blog.csdn.net/qq_44961149/article/details/108420073">https://blog.csdn.net/qq_44961149/article/details/108420073</a></p><h3 id="Doublewrite-Buffer"><a href="#Doublewrite-Buffer" class="headerlink" title="Doublewrite Buffer"></a>Doublewrite Buffer</h3><p>Doublewrite Buffer是一个磁盘上的存储缓冲区，存储的是来自内存的Buffer Pool中的被修改过的Page。</p><p>一个被修改的数据Page到InnoDB data file流程：</p><ol><li>修改的数据页最初存在内存的Buffer Pool中</li><li>然后被flush到磁盘的Doublewrite Buffer中</li><li>最后从Doublewrite Buffer中把数据页写到数据文件的合适位置</li></ol><p>当在上面第3步时，mysqld进程exit，在crash recovery时，InnoDB能从Doublewrite Buffer中获取一个完整的被修改的数据页数据，进行故障恢复。</p><p>尽管数据被写了两次，但是不需要两倍的IO代价和IO操作，采用操作系统的fsync()将修改的数据页作为一个大的chunk写到Doublewrite Buffer中的。除了一种情况，数据页直接存放在操作系统的某个磁盘分区上，对应的innodb_flush_method被设置成O_DIRECT_NO_FSYNC。</p><p>默认是启用的，想禁用的话可以innodb_doublewrite = 0 </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;14-1&quot;&gt;&lt;a href=&quot;#14-1&quot; class=&quot;headerlink&quot; title=&quot;14.1&quot;&gt;&lt;/a&gt;14.1&lt;/h2&gt;&lt;h2 id=&quot;InnoDB-In-Memory-Structures&quot;&gt;&lt;a href=&quot;#InnoDB-In-Memory-S
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发-应用</title>
    <link href="http://yoursite.com/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/wiki/后端/Java/Java并发-应用/</id>
    <published>2021-04-04T04:12:48.000Z</published>
    <updated>2021-04-19T06:29:01.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发-模式</title>
    <link href="http://yoursite.com/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/wiki/后端/Java/Java并发-模式/</id>
    <published>2021-04-04T04:12:41.000Z</published>
    <updated>2021-04-19T06:29:00.959Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式之保护性暂停"><a href="#模式之保护性暂停" class="headerlink" title="模式之保护性暂停"></a>模式之保护性暂停</h2><h2 id="模式之生产者消费者"><a href="#模式之生产者消费者" class="headerlink" title="模式之生产者消费者"></a>模式之生产者消费者</h2><h2 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h2><h2 id="模式之两阶段终止"><a href="#模式之两阶段终止" class="headerlink" title="模式之两阶段终止"></a>模式之两阶段终止</h2><h2 id="模式之-Balking"><a href="#模式之-Balking" class="headerlink" title="模式之 Balking"></a>模式之 Balking</h2><h2 id="模式之享元"><a href="#模式之享元" class="headerlink" title="模式之享元"></a>模式之享元</h2><h2 id="模式之-Worker-Thread"><a href="#模式之-Worker-Thread" class="headerlink" title="模式之 Worker Thread"></a>模式之 Worker Thread</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模式之保护性暂停&quot;&gt;&lt;a href=&quot;#模式之保护性暂停&quot; class=&quot;headerlink&quot; title=&quot;模式之保护性暂停&quot;&gt;&lt;/a&gt;模式之保护性暂停&lt;/h2&gt;&lt;h2 id=&quot;模式之生产者消费者&quot;&gt;&lt;a href=&quot;#模式之生产者消费者&quot; class=&quot;he
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发-原理</title>
    <link href="http://yoursite.com/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/wiki/后端/Java/Java并发-原理/</id>
    <published>2021-04-04T04:12:27.000Z</published>
    <updated>2021-04-19T06:29:01.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="指令级并行原理"><a href="#指令级并行原理" class="headerlink" title="指令级并行原理"></a>指令级并行原理</h2><h2 id="CPU-缓存结构原理"><a href="#CPU-缓存结构原理" class="headerlink" title="CPU 缓存结构原理"></a>CPU 缓存结构原理</h2><h2 id="MESI缓存一致性协议"><a href="#MESI缓存一致性协议" class="headerlink" title="MESI缓存一致性协议"></a>MESI缓存一致性协议</h2><p>MESI指数据在缓存中四种状态，分别是M(Modify)修改、E(Exclusive)独占、S(Share)共享、I(Invild)无效</p><p>运行流程如下：</p><ol><li>读取数据：当一个CPU读数据到缓存行时，缓存初始状态为E，同时会通过总线嗅探机制监听总线，当有另一个CPU也读取了该数据时，数据在两个CPU缓存中的状态都变为S</li><li>修改数据：当其中一个CPU修改了数据后先写到缓存中并不是直接同步回主存中，同时状态改为M，并向总线发送修改了该数据的消息，其他CPU会嗅探到，然后将自己缓存中的数据状态改为I,即失效掉</li><li>同步数据：当有无效缓存数据的CPU要重新从主存读取数据时，先向总线发送读取消息，有修改状态的缓存数据的CPU会嗅探到，将修改数据同步到主存中，然后状态修改为E，当重新读数据的CPU读数据到缓存后，两个CPU的缓存数据再都改为S状态</li><li>修改裁决：当同时有两个CPU向总线发出了修改数据的消息时，会通过硬件进行一个总线裁决，成功的为M状态，其他的为I无效状态</li></ol><h2 id="原理之-volatile"><a href="#原理之-volatile" class="headerlink" title="原理之 volatile"></a>原理之 volatile</h2><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence），字节码上看不出来 volatile 指令的效果</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><ul><li>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</li><li>读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</li></ul><h3 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h3><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><h3 id="lock前缀指令"><a href="#lock前缀指令" class="headerlink" title="lock前缀指令"></a>lock前缀指令</h3><p>内存屏障对应到底层CPU指令是会加lock前缀的指令，volatile关键字是在Java语言层面的体现，字节码层面不能体现，即不存在对应字节码指令，lock前缀的作用如下：</p><ol><li>会将修改的数据立即同步回主存中，写回主存会导致其他CPU缓存中的数据立即失效，这个失效要配合MESI协议来实现，MESI协议要依赖总线嗅探机制实现</li><li>提供了内存屏障功能，使lock指令前后指令不能重排序，阻止优化CPU级别的流水线指令并行技术</li></ol><p>PS: 还是那句话，不能解决指令交错：写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去，而有序性的保证也只是保证了本线程内相关代码不被重排序</p><h2 id="原理之伪共享"><a href="#原理之伪共享" class="headerlink" title="原理之伪共享"></a>原理之伪共享</h2><p>LongAdder 源码</p><h2 id="原理之final"><a href="#原理之final" class="headerlink" title="原理之final"></a>原理之final</h2><h3 id="设置-final-变量的原理"><a href="#设置-final-变量的原理" class="headerlink" title="设置 final 变量的原理"></a>设置 final 变量的原理</h3><p>理解了 volatile 原理，再对比 final 的实现就比较简单了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">20</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: aload_0</span><br><span class="line">1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"><span class="number">4</span>: aload_0</span><br><span class="line"><span class="number">5</span>: bipush <span class="number">20</span></span><br><span class="line">7: putfield #2 // Field a:I</span><br><span class="line">    &lt;-- 写屏障</span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>发现 final 变量的赋值也会通过 putfield 指令来完成，这个操作数引用的是运行时常量池里的一个字段，同样在这条指令之后也会加入写屏障，保证在其它线程读到它的值时不会出现为 0 的情况</p><h3 id="获取-final-变量的原理"><a href="#获取-final-变量的原理" class="headerlink" title="获取 final 变量的原理"></a>获取 final 变量的原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestFinal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> B = Short.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> b = Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseFinal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(TestFinal.A); <span class="comment">// BIPUSH 10  直接常数赋值</span></span><br><span class="line">        System.out.println(TestFinal.B); <span class="comment">// LDC 32768  从常量池中获取</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> TestFinal().a); <span class="comment">// BIPUSH 20</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> TestFinal().b); <span class="comment">// LDC 2147483647</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理之-Monitor-锁"><a href="#原理之-Monitor-锁" class="headerlink" title="原理之 Monitor(锁)"></a>原理之 Monitor(锁)</h2><p>Monitor被翻译为监视器或管程。</p><p>每个Java对象都可以关联一个 Monitor 对象，如果使用 synchronized关键字给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针。Monitor 结构如下：</p><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/monitor.png"></p><ol><li>刚开始 Monitor 中 Owner 为 null</li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner</li><li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList BLOCKED</li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</li><li>图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析</li></ol><blockquote><p>synchronized 必须是进入同一个对象的 monitor 才有上述的效果，不加 synchronized 的对象不会关联监视器，不遵从以上规则</p></blockquote><h2 id="原理之-synchronized"><a href="#原理之-synchronized" class="headerlink" title="原理之 synchronized"></a>原理之 synchronized</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的字节码为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">        stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">            0: getstatic #2 // &lt;- lock引用 （synchronized开始）</span><br><span class="line">            <span class="number">3</span>: dup</span><br><span class="line">            <span class="number">4</span>: astore_1 <span class="comment">// lock引用 -&gt; slot 1</span></span><br><span class="line">            <span class="number">5</span>: monitorenter <span class="comment">// 将 lock对象 MarkWord 置为 Monitor 指针</span></span><br><span class="line">            6: getstatic #3 // &lt;- i</span><br><span class="line">            <span class="number">9</span>: iconst_1 <span class="comment">// 准备常数 1</span></span><br><span class="line">            <span class="number">10</span>: iadd <span class="comment">// +1</span></span><br><span class="line">            11: putstatic #3 // -&gt; i</span><br><span class="line">            <span class="number">14</span>: aload_1 <span class="comment">// &lt;- lock引用</span></span><br><span class="line">            <span class="number">15</span>: monitorexit <span class="comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList</span></span><br><span class="line">            <span class="number">16</span>: goto <span class="number">24</span></span><br><span class="line">            <span class="number">19</span>: astore_2 <span class="comment">// e -&gt; slot 2 </span></span><br><span class="line">            <span class="number">20</span>: aload_1 <span class="comment">// &lt;- lock引用</span></span><br><span class="line">            <span class="number">21</span>: monitorexit <span class="comment">// 将 lock对象 MarkWord 重置, 唤醒 EntryList（此处是发生异常时释放锁）</span></span><br><span class="line">            <span class="number">22</span>: aload_2 <span class="comment">// &lt;- slot 2 (e)</span></span><br><span class="line">            <span class="number">23</span>: athrow <span class="comment">// throw e</span></span><br><span class="line">            <span class="number">24</span>: <span class="keyword">return</span></span><br><span class="line">        Exception table:</span><br><span class="line">            from to target type</span><br><span class="line">            <span class="number">6</span> <span class="number">16</span> <span class="number">19</span> any</span><br><span class="line">            <span class="number">19</span> <span class="number">22</span> <span class="number">19</span> any</span><br><span class="line">        LineNumberTable:</span><br><span class="line">            line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">            line <span class="number">9</span>: <span class="number">6</span></span><br><span class="line">            line <span class="number">10</span>: <span class="number">14</span></span><br><span class="line">            line <span class="number">11</span>: <span class="number">24</span></span><br><span class="line">        LocalVariableTable:</span><br><span class="line">            Start Length Slot Name Signature</span><br><span class="line">            <span class="number">0</span> <span class="number">25</span> <span class="number">0</span> args [Ljava/lang/String;</span><br><span class="line">        StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">            frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">                offset_delta = <span class="number">19</span></span><br><span class="line">                locals = [ class &quot;[Ljava/lang/String;&quot;, class java/lang/Object ]</span><br><span class="line">                stack = [ class java/lang/Throwable ]</span><br><span class="line">            frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">                offset_delta = <span class="number">4</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>方法级别的 synchronized 不会在字节码指令中有所体现，而是通过一个标志位来体现</p></blockquote><h2 id="原理之-synchronized-进阶"><a href="#原理之-synchronized-进阶" class="headerlink" title="原理之 synchronized 进阶"></a>原理之 synchronized 进阶</h2><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。<br>轻量级锁对使用者是透明的，即语法仍然是 synchronized。假设有两个方法同步块，利用同一个对象加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">    <span class="comment">// 同步块 A</span></span><br><span class="line">    method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">    <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个线程的栈帧都会包含一个锁记录（Lock Record）的结构，内部可以存储锁对象的Mark Word。</p><p>加偏向锁时，让锁记录中 Object reference 指向锁对象，然后构造一个锁记录对象自己的地址+00标志位，并尝试用 cas 和锁对象的 Mark Word交换。<br><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/bais1.png"></p><p>如果 CAS 替换成功，锁对象的对象头中存储了锁记录地址和 00 状态位，线程的栈帧中的锁记录对象持有锁对象原来的Mark Word，表示由该线程给对象加轻量级锁成功，这时图示如下<br><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/bais2.png"></p><p>如果 cas 失败，有两种情况:</p><ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ul><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/bais3.png"></p><p>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时删除锁记录，表示重入计数减一<br>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头成功，则解锁成功；失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p><h3 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。流程如下：</p><p>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</p><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/m1.png"></p><p>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程，即为 锁Object 对象申请 Monitor 锁，让 锁Object的Mark Word 指向重量级锁地址，即将Monitor 锁地址+标志位10设置到锁Object的Mark Word，然后自己进入 Monitor 的 EntryList BLOCKED</p><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/m2.png"></p><p>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头时会失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED的线程</p><h3 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h3><p>轻量级锁膨胀为重量级锁的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><p>自旋重试成功的情况:</p><table><thead><tr><th>线程 1 （core 1 上）</th><th>对象 Mark</th><th>线程 2 （core 2 上）</th></tr></thead><tbody><tr><td>访问同步块，获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行完毕</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>成功（解锁）</td><td>01（无锁）</td><td>自旋重试</td></tr><tr><td></td><td>10（重量锁）重量锁指针</td><td>成功（加锁）</td></tr><tr><td></td><td>10（重量锁）重量锁指针</td><td>执行同步块</td></tr></tbody></table><p>自旋重试失败的情况:</p><table><thead><tr><th>线程 1（core 1 上）</th><th>对象 Mark</th><th>线程 2（core 2 上）</th></tr></thead><tbody><tr><td>访问同步块，获取 monitor</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>成功（加锁）</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>-</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>访问同步块，获取 monitor</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>自旋重试</td></tr><tr><td>执行同步块</td><td>10（重量锁）重量锁指针</td><td>阻塞</td></tr></tbody></table><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。</li><li>Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。</p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。<br>以后只要不发生竞争，这个锁对象就归该线程所持有，注意处于偏向锁的对象解锁后，线程 id 仍存储于对象头中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        m2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">        m3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/m3.png"></p><p>一个对象创建时：</p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的thread、epoch、age 都为 0</li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 -XX:BiasedLockingStartupDelay=0 来禁用延迟</li><li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值</li></ul><h3 id="偏向锁撤销"><a href="#偏向锁撤销" class="headerlink" title="偏向锁撤销"></a>偏向锁撤销</h3><p>偏向锁撤销的情况：</p><ol><li>锁对象处于偏向锁状态时，即Mark Word值是 线程id + 状态位101时，调用了对象的 hashCode方法时，会计算hashCode然后写到MarkWord中，覆盖掉线程id，会导致偏向锁被撤销。但是，轻量级锁会在锁记录中记录 hashCode，重量级锁会在 Monitor 中记录 hashCode。</li><li>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁，即对同一个锁对象，线程1先使用，此时锁对象偏向线程1，当其它线程要用时，会升级为轻量级锁。</li><li>调用 wait/notify，直接升级为重量级锁（Monitor锁），只有Monitor才能实现wait/notify功能，通过EntryList和WaitSet实现。</li></ol><h3 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h3><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID。当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程。</p><ul><li>在线程t1中，Dog类的30个实例对象作为锁对象时，默认先加偏向锁，都偏向线程t1</li><li>在线程t2中，再次对t1中的30个实例对象加锁时，前20次会撤销偏向，升级为轻量级锁，从21往后会重新启用偏向锁，偏向t2线程</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Vector&lt;Dog&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">                list.add(d);</span><br><span class="line">                <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                    log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                list.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (list) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    list.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">                Dog d = list.get(i);</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">                <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                    log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h3><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。</p><ul><li>在线程t1中，Dog类的39个实例对象作为锁对象时，默认先加偏向锁，都偏向线程t1</li><li>在线程t2中，再次对t1中的39个实例对象加锁时，前20次会撤销偏向，升级为轻量级锁，从21往后会重新启用偏向锁，偏向t2线程</li><li>在线程t3中，再次对t1中的39个实例对象加锁时，前20次会撤销偏向，升级为轻量级锁，从21往后会重新启用偏向锁，偏向t3线程</li><li>在主线程中，由于在线程t2和t3中，各自前20次都要先撤销偏向，升级为轻量级锁，总共撤销40次，超过阀值，所以导致整个Dog类的所有实例对象都会变为不可偏向的，新建的对象也是不可偏向的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread t1, t2, t3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Vector&lt;Dog&gt; list = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> loopNumber = <span class="number">39</span>;</span><br><span class="line">    t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">            list.add(d);</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.unpark(t2);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            Dog d = list.get(i);</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.unpark(t3);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LockSupport.park();</span><br><span class="line">        log.debug(<span class="string">&quot;===============&gt; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            Dog d = list.get(i);</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">                log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(i + <span class="string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t3&quot;</span>);</span><br><span class="line">    t3.start();</span><br><span class="line">    t3.join();</span><br><span class="line">    log.debug(ClassLayout.parseInstance(<span class="keyword">new</span> Dog()).toPrintableSimple(<span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>通过逃逸分析，对不会发生竞争的代码，但是加了锁的给去除掉</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度。</p><h2 id="原理之-wait-notify"><a href="#原理之-wait-notify" class="headerlink" title="原理之 wait notify"></a>原理之 wait notify</h2><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/wait-notify.png"></p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒，然后去抢锁</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争锁</li></ul><h2 id="原理之-join"><a href="#原理之-join" class="headerlink" title="原理之 join"></a>原理之 join</h2><p>join 体现的是【保护性暂停】模式，是调用者轮询检查线程 alive 状态，t1.join();等价于下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (t1) &#123;</span><br><span class="line">    <span class="comment">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束</span></span><br><span class="line">    <span class="keyword">while</span> (t1.isAlive()) &#123;</span><br><span class="line">        t1.wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原理之-park-amp-unpark"><a href="#原理之-park-amp-unpark" class="headerlink" title="原理之 park &amp; unpark"></a>原理之 park &amp; unpark</h2><p>每个线程都有自己的一个 Parker 对象，由三部分组成 _counter ， _cond 和 _mutex。打个比喻</p><ul><li>线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1 为充足）</li><li>调用 park 就是要看需不需要停下来歇息<ul><li>如果备用干粮耗尽，那么钻进帐篷歇息</li><li>如果备用干粮充足，那么不需停留，继续前进</li></ul></li><li>调用 unpark，就好比令干粮充足<ul><li>如果这时线程还在帐篷，就唤醒让他继续前进</li><li>如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进</li></ul></li><li>因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮</li></ul><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/unsafe-park.png"></p><ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量阻塞</li><li>设置 _counter = 0</li></ol><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/unsafe-unpark.png"></p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0</li><li>Thread_0 恢复运行</li><li>设置 _counter 为 0</li></ol><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/unsafe-unpark-park.png"></p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li><li>设置 _counter 为 0</li></ol><h2 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h2><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架，有如下特点：</p><ol><li>用 state 属性来表示资源的状态（分独占模式和共享模式），子类需要定义如何维护这个状态，控制如何获取锁和释放锁，可通过cas 机制设置 state 状态方法</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ol><p>子类主要实现这样一些方法（默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><p>起源: 早期程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。这显然不够优雅，于是在 JSR166（java 规范提案）中创建了 AQS，提供了这种通用的同步器机制。</p><p>AQS 要实现的功能目标：</p><ul><li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire</li><li>获取锁超时机制</li><li>通过打断取消机制</li><li>独占机制及共享机制</li><li>条件不满足时的等待机制</li></ul><p>要实现的性能目标：Instead, the primary performance goal here is scalability: to predictably maintain efficiency even, or especially, when synchronizers are contended.</p><p>设计：</p><ul><li>获取锁的逻辑<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(state 状态不允许获取) &#123;</span><br><span class="line">    <span class="keyword">if</span>(队列中还没有此线程) &#123;</span><br><span class="line">        入队并阻塞</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">当前线程出队</span><br></pre></td></tr></table></figure></li><li>释放锁的逻辑<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(state 状态允许了) &#123;</span><br><span class="line">    恢复阻塞的线程(s) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>要点: </li></ul><ol><li>原子维护 state 状态</li><li>阻塞及恢复线程</li><li>维护队列</li></ol><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/aqs-family.png"></p><p>PS: CyclicBarrier内部使用ReentrantLock和Condition组合实现，所以不在这个继承图上。</p><h2 id="ReentrantLock-原理"><a href="#ReentrantLock-原理" class="headerlink" title="ReentrantLock 原理"></a>ReentrantLock 原理</h2><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91-%E5%8E%9F%E7%90%86/reentrantlock.png"></p><h2 id="读写锁原理"><a href="#读写锁原理" class="headerlink" title="读写锁原理"></a>读写锁原理</h2><h2 id="Semaphore-原理"><a href="#Semaphore-原理" class="headerlink" title="Semaphore 原理"></a>Semaphore 原理</h2><h2 id="ConcurrentHashMap-原理"><a href="#ConcurrentHashMap-原理" class="headerlink" title="ConcurrentHashMap 原理"></a>ConcurrentHashMap 原理</h2><h2 id="LinkedBlockingQueue-原理"><a href="#LinkedBlockingQueue-原理" class="headerlink" title="LinkedBlockingQueue 原理"></a>LinkedBlockingQueue 原理</h2><h2 id="ConcurrentLinkedQueue-原理"><a href="#ConcurrentLinkedQueue-原理" class="headerlink" title="ConcurrentLinkedQueue 原理"></a>ConcurrentLinkedQueue 原理</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;指令级并行原理&quot;&gt;&lt;a href=&quot;#指令级并行原理&quot; class=&quot;headerlink&quot; title=&quot;指令级并行原理&quot;&gt;&lt;/a&gt;指令级并行原理&lt;/h2&gt;&lt;h2 id=&quot;CPU-缓存结构原理&quot;&gt;&lt;a href=&quot;#CPU-缓存结构原理&quot; class=&quot;head
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发</title>
    <link href="http://yoursite.com/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/wiki/后端/Java/Java并发/</id>
    <published>2021-03-31T06:22:40.000Z</published>
    <updated>2021-04-19T06:29:01.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul><li>一个进程之内可以分为一到多个线程。</li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</li><li>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</li></ul><h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul><li>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其内部的线程共享</li><li>进程间通信较为复杂：<ul><li>同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h3 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h3><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的，状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等，Context Switch 频繁发生会影响性能</p><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>单核 cpu 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是 同时运行的 。总结为一句话就是： 微观串行，宏观并行 ，</p><p>一般会将这种 线程轮流使用 CPU 的做法称为并发， concurrent</p><p>多核 cpu下，每个 核（core） 都可以调度运行线程，这时候线程可以是并行的。</p><p>引用 Go语言之父 Rob Pike 的一段描述：</p><ul><li>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</li><li>并行（parallel）是同一时间动手做（doing）多件事情的能力</li></ul><p>例子</p><ul><li>家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发</li><li>家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）</li><li>雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行</li></ul><h3 id="应用之异步调用（案例1）"><a href="#应用之异步调用（案例1）" class="headerlink" title="应用之异步调用（案例1）"></a>应用之异步调用（案例1）</h3><p>以调用方角度来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><p>设计：多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程</li><li>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><h3 id="应用之提高效率（案例1）"><a href="#应用之提高效率（案例1）" class="headerlink" title="应用之提高效率（案例1）"></a>应用之提高效率（案例1）</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算 1 花费 10 ms</span><br><span class="line">计算 2 花费 11 ms</span><br><span class="line">计算 3 花费 9 ms</span><br><span class="line">汇总需要 1 ms</span><br></pre></td></tr></table></figure><ul><li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms</li><li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms 最后加上汇总时间只会花费 12ms</li><li>注意: 需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</li></ul><p>结论: </p><ol><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任务都能拆分（参考后文的【阿姆达尔定律】），也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化</li></ol><h2 id="Java-线程"><a href="#Java-线程" class="headerlink" title="Java 线程"></a>Java 线程</h2><h3 id="创建和运行线程"><a href="#创建和运行线程" class="headerlink" title="创建和运行线程"></a>创建和运行线程</h3><ol><li>方法一，直接使用 Thread<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建线程对象</span><br><span class="line">Thread t &#x3D; new Thread() &#123;</span><br><span class="line"> public void run() &#123;</span><br><span class="line"> &#x2F;&#x2F; 要执行的任务</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 启动线程</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure></li><li>方法二，使用 Runnable 配合 Thread，把【线程】和【任务】（要执行的代码）分开Thread 代表线程，Runnable 可运行的任务（线程要执行的代码）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable &#x3D; new Runnable() &#123;</span><br><span class="line"> public void run()&#123;</span><br><span class="line"> &#x2F;&#x2F; 要执行的任务</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 创建线程对象</span><br><span class="line">Thread t &#x3D; new Thread( runnable );</span><br><span class="line">&#x2F;&#x2F; 启动线程</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><blockquote><p>原理之 Thread 与 Runnable 的关系</p></blockquote></li></ol><p>查看 Thread 的源码可知，Thread类中有一个Runnable类型的成员变量target，它的run方法中会判断target是否为null，不为null则调用run方法.<br>如上方法1是直接匿名类的方式重写了run方法.<br>如上方法2是实例化一个Runnable接口的实例，通过Thread构造方法传递给target.</p><p>使用Runnable有如下好处：</p><ul><li>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合</li><li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><ol start="3"><li>方法三，FutureTask 配合 Thread，FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> FutureTask&lt;&gt;(() -&gt; &#123;</span><br><span class="line"> log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="keyword">new</span> Thread(task3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"><span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line">Integer result = task3.get();</span><br><span class="line">log.debug(<span class="string">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure><h2 id="共享模型之管程"><a href="#共享模型之管程" class="headerlink" title="共享模型之管程"></a>共享模型之管程</h2><h3 id="临界区-Critical-Section"><a href="#临界区-Critical-Section" class="headerlink" title="临界区 Critical Section"></a>临界区 Critical Section</h3><p>一个程序运行多个线程本身是没有问题的，问题出在多个线程访问共享资源</p><ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区<br>例如，下面代码中的临界区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 临界区</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> counter++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 临界区</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> counter--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="竞态条件-Race-Condition"><a href="#竞态条件-Race-Condition" class="headerlink" title="竞态条件 Race Condition"></a>竞态条件 Race Condition</h3><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件</p><h3 id="synchronized-解决方案"><a href="#synchronized-解决方案" class="headerlink" title="synchronized 解决方案"></a>synchronized 解决方案</h3><blockquote><p>应用之互斥</p></blockquote><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>synchronized，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object room = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                counter--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以做这样的类比：synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人进行计算，线程 t1，t2 想象成两个人</p><ol><li>当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行count++ 代码</li><li>这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切换，阻塞住了</li><li>这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦），这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得CPU时间片时会再次开门进入</li><li>当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count– 代码</li></ol><p>思考：synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换或交错执行造成问题。</p><p>面向对象改进: 把需要保护的共享变量放入一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            value++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            value--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Room room = <span class="keyword">new</span> Room();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                room.increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">                room.decrement();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, room.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h3><p>成员变量和静态变量是否线程安全？</p><ul><li>如果它们没有共享，则线程安全</li><li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><p>局部变量是否线程安全？</p><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象则未必<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><p>如下类是线程安全的，因为：</p><ul><li>list 是局部变量，每个线程调用时会创建其不同实例，没有共享</li><li>method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象，method3 的参数分析与 method2 相同</li><li>method2 和 method3 访问修饰符是private，不能被其他类访问，所以不会造成list引用逃逸</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(<span class="keyword">int</span> loopNumber)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑method2、method3访问修饰符改为public时，是否带来安全问题</p><ul><li>有其它线程调用 method2 和 method3，会拿到list引用造成逃逸</li><li>在情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，也会得到list引用造成逃逸，即</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSubClass</span> <span class="keyword">extends</span> <span class="title">ThreadSafe</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个例子可以看出 private 或 final 提供【安全】的意义所在，请体会开闭原则中的【闭】</p><h3 id="常见线程安全类"><a href="#常见线程安全类" class="headerlink" title="常见线程安全类"></a>常见线程安全类</h3><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类</li></ul><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。<br>也可以理解为它们的每个方法是原子的，但注意它们多个方法的组合不是原子的，如下操作是安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> table.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line"> table.put(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>线程安全类方法的组合，下面代码不是线程安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Hashtable table = <span class="keyword">new</span> Hashtable();</span><br><span class="line"><span class="comment">// 线程1，线程2</span></span><br><span class="line"><span class="keyword">if</span>( table.get(<span class="string">&quot;key&quot;</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">    table.put(<span class="string">&quot;key&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可变类线程安全性：String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的<br>有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安全的呢？<br>类似如下，每次会构造一个新对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Immutable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Immutable</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Immutable <span class="title">add</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Immutable(<span class="keyword">this</span>.value + v);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>todo</p><h3 id="卖票、转账实例"><a href="#卖票、转账实例" class="headerlink" title="卖票、转账实例"></a>卖票、转账实例</h3><p>todo </p><h3 id="Monitor-概念"><a href="#Monitor-概念" class="headerlink" title="Monitor 概念"></a>Monitor 概念</h3><blockquote><p>原理之 Monitor(锁)<br>原理之 synchronized<br>原理之 synchronized 进阶</p></blockquote><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><blockquote><p>原理之 wait / notify</p></blockquote><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法: </p><ul><li>obj.wait() 会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止</li><li>obj.wait(long n) 有时限的等待, 到 n 毫秒后结束等待，或是被 notify</li><li>obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒</li><li>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒</li></ul><p>sleep(long n) 和 wait(long n) 的区别</p><ol><li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li><li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li><li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 </li><li>它们状态 TIMED_WAITING</li></ol><blockquote><p>模式之保护性暂停<br>模式之生产者消费者<br>原理之join</p></blockquote><h3 id="Park-Unpark"><a href="#Park-Unpark" class="headerlink" title="Park/Unpark"></a>Park/Unpark</h3><p>它们是 LockSupport 类中的方法</p><ul><li>LockSupport.park();  暂停当前线程，内部是调用Unsafe.park()</li><li>LockSupport.unpark(暂停线程对象); 恢复某个线程的运行，内部是调用UNSAFE.unpark(thread);</li></ul><p>基本使用1：先 park 再 unpark</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">18</span>:<span class="number">42</span>:<span class="number">52.585</span> c.TestParkUnpark [t1] - start... </span><br><span class="line"><span class="number">18</span>:<span class="number">42</span>:<span class="number">53.589</span> c.TestParkUnpark [t1] - park... </span><br><span class="line"><span class="number">18</span>:<span class="number">42</span>:<span class="number">54.583</span> c.TestParkUnpark [main] - unpark... </span><br><span class="line"><span class="number">18</span>:<span class="number">42</span>:<span class="number">54.583</span> c.TestParkUnpark [t1] - resume...</span><br></pre></td></tr></table></figure><p>基本使用2： 先 unpark 再 park</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.unpark(t1);</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">18</span>:<span class="number">43</span>:<span class="number">50.765</span> c.TestParkUnpark [t1] - start... </span><br><span class="line"><span class="number">18</span>:<span class="number">43</span>:<span class="number">51.764</span> c.TestParkUnpark [main] - unpark... </span><br><span class="line"><span class="number">18</span>:<span class="number">43</span>:<span class="number">52.769</span> c.TestParkUnpark [t1] - park... </span><br><span class="line"><span class="number">18</span>:<span class="number">43</span>:<span class="number">52.769</span> c.TestParkUnpark [t1] - resume...</span><br></pre></td></tr></table></figure><p>与 Object 的 wait &amp; notify 相比</p><ol><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li><li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li></ol><blockquote><p>原理之 park &amp; unpark</p></blockquote><h3 id="重新理解线程状态转换"><a href="#重新理解线程状态转换" class="headerlink" title="重新理解线程状态转换"></a>重新理解线程状态转换</h3><p>todo</p><h3 id="多把锁"><a href="#多把锁" class="headerlink" title="多把锁"></a>多把锁</h3><p>一间大屋子有两个功能：睡觉、学习，互不相干。<br>现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低<br>解决方法是准备多个房间（多个对象锁）</p><h3 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h3><ul><li>死锁<br>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁<br>t1 线程 获得 A对象 锁，接下来想获取 B对象 的锁，t2 线程 获得 B对象锁，接下来想获取 A对象 的锁，如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><blockquote><p>同步模式之顺序控制</p></blockquote><h2 id="共享模型之内存"><a href="#共享模型之内存" class="headerlink" title="共享模型之内存"></a>共享模型之内存</h2><p>上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性<br>这一章我们进一步深入学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题</p><h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。体现在以下几个方面</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span> run = <span class="keyword">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="keyword">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li><li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的高速缓存中，减少对主存中 run 的访问，提高效率</li><li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li></ol><p>解决方法: volatile（易变关键字），它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存</p><p>可见性 vs 原子性</p><ul><li>可见性保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可见，不能保证原子性，比较一下两个线程一个 i++ 一个 i– ，只能保证看到最新值，不能解决指令交错</li><li>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是synchronized 是属于重量级操作，性能相对更低</li></ul><p>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？<br>因为println中加了synchronized，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(<span class="keyword">boolean</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        print(x);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原理之 CPU 缓存结构<br>模式之两阶段终止<br>模式之 Balking</p></blockquote><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。<br>为什么要有重排指令这项优化呢？从 CPU执行指令的原理来理解一下吧</p><blockquote><p>原理之指令级并行</p></blockquote><h3 id="诡异的结果"><a href="#诡异的结果" class="headerlink" title="诡异的结果"></a>诡异的结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 线程1 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor1</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 线程2 执行此方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actor2</span><span class="params">(I_Result r)</span> </span>&#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p><p>有同学这么分析</p><ul><li>情况1：线程1 先执行，这时 ready = false，所以进入 else 分支结果为 1</li><li>情况2：线程2 先执行 num = 2，但没来得及执行 ready = true，线程1 执行，还是进入 else 分支，结果为1</li><li>情况3：线程2 执行到 ready = true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</li><li>但结果还有可能是 0，这种情况下是：线程2 执行 ready = true，切换到线程1，进入 if 分支，相加为 0，再切回线程2 执行 num = 2</li></ul><p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化，这个现象需要通过大量测试才能复现：<br>借助 java 并发压测工具 jcstress <a href="https://wiki.openjdk.java.net/display/CodeTools/jcstress">https://wiki.openjdk.java.net/display/CodeTools/jcstress</a><br>我们能发现不同情况出现的次数，出现结果为 0 的情况很少，但是出现了</p><p>解决方法：volatile 修饰ready变量，可以禁用指令重排，volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence） </p><ul><li>对 volatile 变量的写指令后会加入写屏障，写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>对 volatile 变量的读指令前会加入读屏障，读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul><blockquote><p>原理之 volatile</p></blockquote><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ol><li>程序次序规则：在一个线程内一段代码的执行结果是有序的。就是还会指令重排，但是随便它怎么排，结果是按照我们代码的顺序生成的不会变。</li><li>管程锁定规则：对于使用synchronized时的同一个锁对象m，线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li><li>volatile变量规则：线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</li><li>线程启动规则：线程 start 前对变量的写，该线程 start 后对该变量的读可见</li><li>线程结束规则：线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li><li>线程中断规则：线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</li><li>传递性规则：具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排，有下面的例子</li><li>对象终结规则：一个对象的初始化的完成，也就是构造函数执行的结束一定 先发生于它的finalize()方法。</li></ol><blockquote><p>同步模式之 Balking<br>模式之线程安全的单例</p></blockquote><h2 id="共享模型之无锁"><a href="#共享模型之无锁" class="headerlink" title="共享模型之无锁"></a>共享模型之无锁</h2><ul><li>CAS 与 volatile</li><li>原子整数</li><li>原子引用</li><li>原子累加器</li><li>Unsafe</li></ul><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>有如下需求，保证 account.withdraw 取款方法的线程安全</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    <span class="function">Integer <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                account.withdraw(<span class="number">10</span>);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        System.out.println(account.getBalance()</span><br><span class="line">                + <span class="string">&quot; cost: &quot;</span> + (end - start) / <span class="number">1000_000</span> + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原有实现并不是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountUnsafe</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountUnsafe</span><span class="params">(Integer balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        balance -= amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么不安全? withdraw 方法字节码指令如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ALOAD <span class="number">0</span>                                                         <span class="comment">// &lt;- this</span></span><br><span class="line">ALOAD <span class="number">0</span></span><br><span class="line">GETFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer;  <span class="comment">// &lt;- this.balance</span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue ()I                    <span class="comment">// 拆箱</span></span><br><span class="line">ALOAD <span class="number">1</span>                                                         <span class="comment">// &lt;- amount</span></span><br><span class="line">INVOKEVIRTUAL java/lang/Integer.intValue ()I                    <span class="comment">// 拆箱</span></span><br><span class="line">ISUB                                                            <span class="comment">// 减法</span></span><br><span class="line">INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;   <span class="comment">// 结果装箱</span></span><br><span class="line">PUTFIELD cn/itcast/AccountUnsafe.balance : Ljava/lang/Integer;  <span class="comment">// -&gt; this.balance</span></span><br></pre></td></tr></table></figure><p>多线程执行时，指令交错导致</p><h3 id="解决思路1-锁"><a href="#解决思路1-锁" class="headerlink" title="解决思路1-锁"></a>解决思路1-锁</h3><p>给withdraw方法加synchronized</p><h3 id="解决思路2-无锁"><a href="#解决思路2-无锁" class="headerlink" title="解决思路2-无锁"></a>解决思路2-无锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountSafe</span> <span class="keyword">implements</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountSafe</span><span class="params">(Integer balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = <span class="keyword">new</span> AtomicInteger(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> prev = balance.get();</span><br><span class="line">            <span class="keyword">int</span> next = prev - amount;</span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以简化为下面的方法</span></span><br><span class="line">        <span class="comment">// balance.addAndGet(-1 * amount);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CAS-与-volatile"><a href="#CAS-与-volatile" class="headerlink" title="CAS 与 volatile"></a>CAS 与 volatile</h3><p>前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？</p><ul><li>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</li><li>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</li><li>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li></ul><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</p><ul><li>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</li><li>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取</li><li>它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</li><li>volatile 仅仅保证了共享变量的可见性，让其它线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</li></ul><p>为什么无锁效率高</p><ul><li>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，稍后可以再次重试，而 synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。打个比喻线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大</li><li>但无锁情况下，线程仍然要服从CPU时间片使用的调度，即CPU时间片用完还是会发生上下文切换的。</li></ul><p>CAS 的特点：</p><ul><li>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</li><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思<ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h3 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h3><p>J.U.C 并发包提供了：AtomicBoolean、AtomicInteger、AtomicLong</p><p>以 AtomicInteger 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">System.out.println(i.getAndIncrement());</span><br><span class="line"><span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">System.out.println(i.incrementAndGet());</span><br><span class="line"><span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">System.out.println(i.decrementAndGet());</span><br><span class="line"><span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">System.out.println(i.getAndDecrement());</span><br><span class="line"><span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line"><span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line"><span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line"><span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br></pre></td></tr></table></figure><h3 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h3><p>为什么需要原子引用类型？</p><ul><li>AtomicReference</li><li>AtomicMarkableReference</li><li>AtomicStampedReference</li></ul><p>下面通过实例说明AtomicReference用法，之前Account的余额是整数，现改为BigDecimal</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DecimalAccount</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取余额</span></span><br><span class="line">    <span class="function">BigDecimal <span class="title">getBalance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取款</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(BigDecimal amount)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span></span><br><span class="line"><span class="comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">(DecimalAccount account)</span> </span>&#123;</span><br><span class="line">        List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                account.withdraw(BigDecimal.TEN);</span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        ts.forEach(Thread::start);</span><br><span class="line">        ts.forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(account.getBalance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决思路1-锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecimalAccountSafeLock</span> <span class="keyword">implements</span> <span class="title">DecimalAccount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    BigDecimal balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecimalAccountSafeLock</span><span class="params">(BigDecimal balance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(BigDecimal amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            BigDecimal balance = <span class="keyword">this</span>.getBalance();</span><br><span class="line">            <span class="keyword">this</span>.balance = balance.subtract(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决思路2-使用 CAS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecimalAccountSafeCas</span> <span class="keyword">implements</span> <span class="title">DecimalAccount</span> </span>&#123;</span><br><span class="line">    AtomicReference&lt;BigDecimal&gt; ref;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecimalAccountSafeCas</span><span class="params">(BigDecimal balance)</span> </span>&#123;</span><br><span class="line">        ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ref.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(BigDecimal amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            BigDecimal prev = ref.get();</span><br><span class="line">            BigDecimal next = prev.subtract(amount);</span><br><span class="line">            <span class="keyword">if</span> (ref.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ABA-问题及解决"><a href="#ABA-问题及解决" class="headerlink" title="ABA 问题及解决"></a>ABA 问题及解决</h3><p>ABA 问题: 如下代码主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取值 A</span></span><br><span class="line">    <span class="comment">// 这个共享变量被它线程修改过？</span></span><br><span class="line">    String prev = ref.get();</span><br><span class="line">    other();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试改为 C</span></span><br><span class="line">    log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;B&quot;</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.get(), <span class="string">&quot;A&quot;</span>));</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果主线程希望：只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号<br>可通过AtomicStampedReference来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="string">&quot;A&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;main start...&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取值 A</span></span><br><span class="line">    String prev = ref.getReference();</span><br><span class="line">    <span class="comment">// 获取版本号</span></span><br><span class="line">    <span class="keyword">int</span> stamp = ref.getStamp();</span><br><span class="line">    log.debug(<span class="string">&quot;版本 &#123;&#125;&quot;</span>, stamp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span></span><br><span class="line">    other();</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 尝试改为 C</span></span><br><span class="line">    log.debug(<span class="string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="string">&quot;C&quot;</span>, stamp, stamp + <span class="number">1</span>));  <span class="comment">// change A-&gt;C false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">other</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;B&quot;</span>,</span><br><span class="line">                ref.getStamp(), ref.getStamp() + <span class="number">1</span>));</span><br><span class="line">        log.debug(<span class="string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="string">&quot;A&quot;</span>,</span><br><span class="line">                ref.getStamp(), ref.getStamp() + <span class="number">1</span>));</span><br><span class="line">        log.debug(<span class="string">&quot;更新版本为 &#123;&#125;&quot;</span>, ref.getStamp());</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。<br>但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了AtomicMarkableReference，用一个布尔值来表示是否被修改过。</p><h3 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h3><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><p>todo</p><h3 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h3><ul><li>AtomicReferenceFieldUpdater // 域 字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> field;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicIntegerFieldUpdater fieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Test5.class, <span class="string">&quot;field&quot;</span>);</span><br><span class="line">        Test5 test5 = <span class="keyword">new</span> Test5();</span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 修改成功 field = 10</span></span><br><span class="line">        System.out.println(test5.field);</span><br><span class="line">        <span class="comment">// 修改成功 field = 20</span></span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        System.out.println(test5.field);</span><br><span class="line">        <span class="comment">// 修改失败 field = 20</span></span><br><span class="line">        fieldUpdater.compareAndSet(test5, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(test5.field);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h3><p>累加器性能比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        demo(() -&gt; <span class="keyword">new</span> LongAdder(), adder -&gt; adder.increment());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        demo(() -&gt; <span class="keyword">new</span> AtomicLong(), adder -&gt; adder.getAndIncrement());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action)</span> </span>&#123;</span><br><span class="line">    T adder = adderSupplier.get();</span><br><span class="line">    <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">    List&lt;Thread&gt; ts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 4 个线程，每人累加 50 万</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        ts.add(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">500000</span>; j++) &#123;</span><br><span class="line">                action.accept(adder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    ts.forEach(t -&gt; t.start());</span><br><span class="line">    ts.forEach(t -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">    System.out.println(adder + <span class="string">&quot; cost:&quot;</span> + (end - start) / <span class="number">1000_000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">20000000</span> cost:<span class="number">462</span></span><br><span class="line"><span class="number">20000000</span> cost:<span class="number">56</span></span><br><span class="line"><span class="number">20000000</span> cost:<span class="number">51</span></span><br><span class="line"><span class="number">20000000</span> cost:<span class="number">49</span></span><br><span class="line"><span class="number">20000000</span> cost:<span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="number">20000000</span> cost:<span class="number">627</span></span><br><span class="line"><span class="number">20000000</span> cost:<span class="number">615</span></span><br><span class="line"><span class="number">20000000</span> cost:<span class="number">635</span></span><br><span class="line"><span class="number">20000000</span> cost:<span class="number">592</span></span><br><span class="line"><span class="number">20000000</span> cost:<span class="number">479</span></span><br></pre></td></tr></table></figure><p>性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加Cell[1]… 最后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性能。<br>LongAdder 是并发大师 @author Doug Lea （大哥李）的作品，设计的非常精巧。</p><blockquote><p>原理之伪共享<br>LongAdder 源码</p></blockquote><h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAccessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field theUnsafe = Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Unsafe CAS 操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Unsafe unsafe = UnsafeAccessor.getUnsafe();</span><br><span class="line">Field id = Student.class.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">Field name = Student.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得成员变量的偏移量</span></span><br><span class="line"><span class="keyword">long</span> idOffset = UnsafeAccessor.unsafe.objectFieldOffset(id);</span><br><span class="line"><span class="keyword">long</span> nameOffset = UnsafeAccessor.unsafe.objectFieldOffset(name);</span><br><span class="line">Student student = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 cas 方法替换成员变量的值</span></span><br><span class="line">UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, <span class="number">0</span>, <span class="number">20</span>); <span class="comment">// 返回 true</span></span><br><span class="line">UnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, <span class="keyword">null</span>, <span class="string">&quot;张三&quot;</span>); <span class="comment">// 返回 true</span></span><br><span class="line">System.out.println(student);</span><br><span class="line"></span><br><span class="line">输出：Student(id=<span class="number">20</span>, name=张三)</span><br><span class="line">```        </span><br><span class="line"></span><br><span class="line">使用自定义的 AtomicData 实现之前线程安全的原子整数 Account 实现</span><br><span class="line">```java</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> data;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DATA_OFFSET;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        unsafe = UnsafeAccessor.getUnsafe();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// data 属性在 DataContainer 对象中的偏移量，用于 Unsafe 直接访问该属性</span></span><br><span class="line">            DATA_OFFSET = unsafe.objectFieldOffset(AtomicData.class.getDeclaredField(<span class="string">&quot;data&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicData</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrease</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldValue;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取共享变量旧值，可以在这一行加入断点，修改 data 调试来加深理解</span></span><br><span class="line">            oldValue = data;</span><br><span class="line">            <span class="comment">// cas 尝试修改 data 为 旧值 + amount，如果期间旧值被别的线程改了，返回 false</span></span><br><span class="line">            <span class="keyword">if</span> (unsafe.compareAndSwapInt(<span class="keyword">this</span>, DATA_OFFSET, oldValue, oldValue - amount)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Account.demo(<span class="keyword">new</span> Account() &#123;</span><br><span class="line">    AtomicData atomicData = <span class="keyword">new</span> AtomicData(<span class="number">10000</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> atomicData.getData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withdraw</span><span class="params">(Integer amount)</span> </span>&#123;</span><br><span class="line">        atomicData.decrease(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="共享模型之不可变"><a href="#共享模型之不可变" class="headerlink" title="共享模型之不可变"></a>共享模型之不可变</h2><ul><li>不可变类的使用</li><li>不可变类设计</li><li>无状态类设计</li></ul><h3 id="日期转换的问题"><a href="#日期转换的问题" class="headerlink" title="日期转换的问题"></a>日期转换的问题</h3><p>下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>思路 - 同步锁: 这样虽能解决问题，但带来的是性能上的损失，并不算很好</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sdf) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>思路 - 不可变: 如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        LocalDate date = dtf.parse(<span class="string">&quot;2018-10-01&quot;</span>, LocalDate::from);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, date);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看 DateTimeFormatter 的文档：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@implSpec</span></span><br><span class="line">This <span class="class"><span class="keyword">class</span> <span class="title">is</span> <span class="title">immutable</span> <span class="title">and</span> <span class="title">thread</span>-<span class="title">safe</span>.</span></span><br></pre></td></tr></table></figure><p>不可变对象，实际是另一种避免竞争的方式。</p><h3 id="不可变设计"><a href="#不可变设计" class="headerlink" title="不可变设计"></a>不可变设计</h3><p>另一个大家更为熟悉的 String 类也是不可变的，以它为例，说明一下不可变设计的要素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="final-的使用"><a href="#final-的使用" class="headerlink" title="final 的使用"></a>final 的使用</h4><p>发现String该类、类中所有属性都是 final 的</p><ul><li>属性用 final 修饰保证了该属性是只读的，不能修改</li><li>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li></ul><h4 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h4><p>但有同学会说，使用字符串时，也有一些跟修改相关的方法啊，比如 substring 等，那么下面就看一看这些方法是如何实现的，就以 substring 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现其内部是调用 String 的构造方法创建了一个新字符串，再进入这个构造看看，是否对 final char[] value 做出了修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果发现也没有，构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】</p><blockquote><p>模式之享元<br>原理之final</p></blockquote><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】<br>在 web 阶段学习时，设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这种没有任何成员变量的类是线程安全的</p><h2 id="共享模型之工具"><a href="#共享模型之工具" class="headerlink" title="共享模型之工具"></a>共享模型之工具</h2><h3 id="线程池-ThreadPoolExecutor"><a href="#线程池-ThreadPoolExecutor" class="headerlink" title="线程池 ThreadPoolExecutor"></a>线程池 ThreadPoolExecutor</h3><p>线程池状态：ThreadPoolExecutor 中用一个AtomicInteger类型的私有final成员变量ctl的高 3 位来表示线程池状态，低 29 位表示线程数量</p><ul><li>RUNNING：高3位111，接受新任务，处理阻塞队列中的任务</li><li>SHUTDOWN：高3位000，不接受新任务，但会处理阻塞队列任务</li><li>STOP：高3位001，中断正在执行的任务，并抛弃阻塞队列任务</li><li>TIDYING: 高3位010，任务执行完毕，活动线程为0即将进入终结</li><li>TERMINATED：高3位011，终结状态</li></ul><p>将线程池状态与线程个数合二为一的目的就是可以用一次 cas 原子操作进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, // 核心线程数目, 最多保留的线程数</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize, // 最大线程数目</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime, // 生存时间 - 针对救急线程</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit, // 时间单位 - 针对救急线程</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory, // 线程工厂 - 可以为线程创建时起个好名字</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span>  <span class="comment">// 拒绝策略 </span></span></span><br></pre></td></tr></table></figure><p>工作方式：</p><ol><li>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</li><li>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。</li><li>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</li><li>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，其它著名框架也提供了实现<ul><li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li><li>CallerRunsPolicy 让调用者运行任务</li><li>DiscardPolicy 放弃本次任务</li><li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li><li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题</li><li>Netty 的实现，是创建一个新线程来执行任务</li><li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略</li><li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略                </li></ul></li><li>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制。</li></ol><p>根据这个构造方法，JDK Executors 类中提供了众多工厂方法来创建各种用途的线程池</p><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>阻塞队列是无界的，可以放任意数量的任务</li></ul><p>评价：适用于任务量已知，相对耗时的任务</p><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                    <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着全部都是救急线程（60s 后可以回收）且救急线程可以无限创建</li><li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li></ul><p>评价：整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线程。 适合任务数比较密集，但每个任务执行时间较短的情况</p><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一个线程，保证池的正常工作<br>使用场景：希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程也不会被释放。</p><ul><li>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改，其中 FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用 ThreadPoolExecutor 中特有的方法</li><li>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</li></ul><h4 id="提交任务方式"><a href="#提交任务方式" class="headerlink" title="提交任务方式"></a>提交任务方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure><h4 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h4><ul><li>shutdown()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 但已提交任务会执行完</span></span><br><span class="line"><span class="comment">- 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess(); </span><br><span class="line">        advanceRunState(SHUTDOWN); <span class="comment">// 修改线程池状态SHUTDOWN</span></span><br><span class="line">        interruptIdleWorkers(); <span class="comment">// 仅会打断空闲线程</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate(); <span class="comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>shutdownNow()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 STOP</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 会将队列中的任务返回</span></span><br><span class="line"><span class="comment">- 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        advanceRunState(STOP); <span class="comment">// 修改线程池状态STOP</span></span><br><span class="line">        interruptWorkers(); <span class="comment">// 打断所有线程</span></span><br><span class="line">        tasks = drainQueue(); <span class="comment">// 获取队列中剩余任务,最后返回</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其他方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><blockquote><p> 模式之 Worker Thread</p></blockquote><h4 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h4><p>在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">    TimerTask task1 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    TimerTask task2 = <span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">    <span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span></span><br><span class="line">    timer.schedule(task1, <span class="number">1000</span>); <span class="comment">// 1s后开始执行</span></span><br><span class="line">    timer.schedule(task2, <span class="number">1000</span>); <span class="comment">// 3s后开始执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 ScheduledExecutorService 改写后，1s后两个任务同时开始执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1，执行时间：&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2，执行时间：&quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS); </span><br></pre></td></tr></table></figure><p>scheduleAtFixedRate 例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line"></span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS); <span class="comment">// 第1个1是首次延迟时间，第2个1是周期执行时间</span></span><br></pre></td></tr></table></figure><p>scheduleAtFixedRate 例子（任务执行时间超过了间隔时间）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line"></span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">输出分析：一开始，延时 1s，接下来，由于任务执行时间 &gt; 间隔时间，间隔被『撑』到了 2s</span><br></pre></td></tr></table></figure><p>scheduleWithFixedDelay 例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line"></span><br><span class="line">pool.scheduleWithFixedDelay(()-&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">输出分析：一开始，延时 1s，scheduleWithFixedDelay 的间隔是 上一个任务结束后开始计时延时时间，然后下一个任务开始，所以间隔都是 3s</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">            <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>评价: 整个线程池表现为：线程数固定，任务数多于线程数时，会放入无界队列排队。任务执行完毕，这些线程也不会被释放。用来执行延迟或反复执行的任务</p><h4 id="正确处理执行任务异常"><a href="#正确处理执行任务异常" class="headerlink" title="正确处理执行任务异常"></a>正确处理执行任务异常</h4><p>方法1：主动捉异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;error:&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>方法2：使用 Future</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">&quot;result:&#123;&#125;&quot;</span>, f.get());</span><br></pre></td></tr></table></figure><blockquote><p>应用之定时任务</p></blockquote><h3 id="Tomcat-线程池"><a href="#Tomcat-线程池" class="headerlink" title="Tomcat 线程池"></a>Tomcat 线程池</h3><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/tomcat-threadpool.png"><br>todo</p><h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h3><p>Fork/Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算<br>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计算，如归并排序、斐波那契数列、都可以用分治思想进行求解<br>Fork/Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率<br>Fork/Join 默认会创建与 cpu 核心数大小相同的线程池</p><p>使用: 提交给 Fork/Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下面定义了一个对 1~n 之间的整数求和的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTask1</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddTask1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + n + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 n 已经为 1，可以求得结果了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, n);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务进行拆分(fork)</span></span><br><span class="line">        AddTask1 t1 = <span class="keyword">new</span> AddTask1(n - <span class="number">1</span>);</span><br><span class="line">        t1.fork();</span><br><span class="line">        log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并(join)结果</span></span><br><span class="line">        <span class="keyword">int</span> result = n + t1.join();</span><br><span class="line">        log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交给 ForkJoinPool 来执行，计算1-5个数的和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</span><br><span class="line">    System.out.println(pool.invoke(<span class="keyword">new</span> AddTask1(<span class="number">5</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用图表示如下：<br><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/fork-join1.png"></p><p>改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTask3</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddTask3</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + begin + <span class="string">&quot;,&quot;</span> + end + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 5, 5</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, begin);</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4, 5</span></span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, begin, end, end + begin);</span><br><span class="line">            <span class="keyword">return</span> end + begin;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 5</span></span><br><span class="line">        <span class="keyword">int</span> mid = (end + begin) / <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line">        AddTask3 t1 = <span class="keyword">new</span> AddTask3(begin, mid); <span class="comment">// 1,3</span></span><br><span class="line">        t1.fork();</span><br><span class="line">        AddTask3 t2 = <span class="keyword">new</span> AddTask3(mid + <span class="number">1</span>, end); <span class="comment">// 4,5</span></span><br><span class="line">        t2.fork();</span><br><span class="line">        log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125; = ?&quot;</span>, t1, t2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = t1.join() + t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, t1, t2, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交给 ForkJoinPool 来执行，计算1-10个数的和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</span><br><span class="line">    System.out.println(pool.invoke(<span class="keyword">new</span> AddTask3(<span class="number">1</span>, <span class="number">10</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用图表示如下：<br><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/fork-join2.png"></p><h3 id="J-U-C"><a href="#J-U-C" class="headerlink" title="J.U.C"></a>J.U.C</h3><blockquote><p>AQS 原理<br>ReentrantLock 原理</p></blockquote><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><blockquote><p>应用之缓存<br>读写锁原理</p></blockquote><h4 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h4><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><blockquote><p>Semaphore 应用<br>Semaphore 原理</p></blockquote><h4 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h4><blockquote><p>应用之同步等待多线程准备完毕<br>应用之同步等待多个远程调用结束</p></blockquote><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>CyclicBarrier内部使用ReentrantLock和Condition组合实现。</p><h4 id="线程安全集合类概述"><a href="#线程安全集合类概述" class="headerlink" title="线程安全集合类概述"></a>线程安全集合类概述</h4><p><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/thread-safe-collection.png"></p><p>线程安全集合类可以分为三大类：</p><ul><li>遗留的线程安全集合如 Hashtable ， Vector，方法都用synchronize修饰</li><li>使用 Collections 装饰的线程安全集合，通过this加synchronize锁，方法还是调用被装饰集合的相应方法<ul><li>Collections.synchronizedCollection</li><li>Collections.synchronizedList</li><li>Collections.synchronizedMap</li><li>Collections.synchronizedSet</li><li>Collections.synchronizedNavigableMap</li><li>Collections.synchronizedNavigableSet </li><li>Collections.synchronizedSortedMap</li><li>Collections.synchronizedSortedSet</li></ul></li><li>java.util.concurrent.*</li></ul><p>重点介绍 java.util.concurrent.* 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：locking、CopyOnWrite、Concurrent</p><ul><li>Blocking 大部分实现基于锁，并提供用来阻塞的方法</li><li>CopyOnWrite 之类容器修改开销相对较重</li><li>Concurrent 类型的容器<ul><li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</li><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li><li>求大小弱一致性，size 操作未必是 100% 准确</li></ul></li></ul><p>PS: 对于非安全容器来讲，遍历时如果发生了修改，使用 fail-fast 机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是</p><ul><li>两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行</li><li>dummy 节点的引入让两把【锁】将来锁住的是不同对象，避免竞争，只是这【锁】使用了 cas 来实现</li></ul><p>事实上，ConcurrentLinkedQueue 应用还是非常广泛的，例如之前讲的 Tomcat 的 Connector 结构时，Acceptor 作为生产者向 Poller 消费者传递事件信息时，正是采用了ConcurrentLinkedQueue 将 SocketChannel 给 Poller 使用</p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>CopyOnWriteArraySet 是它的马甲<br>底层实现采用了 写入时拷贝 的思想，增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，这时不影响其它线程的并发读，读写分离，适合『读多写少』的应用场景。 </p><p>新增实现如下，这里的源码版本是 Java 8，使用的是可重入锁，在 Java 11 中使用的是 synchronized</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray(); <span class="comment">// 获取旧的数组</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>); <span class="comment">// 拷贝新的数组（这里是比较耗时的操作，但不影响其它读线程）</span></span><br><span class="line">        newElements[len] = e;  <span class="comment">// 添加新元素</span></span><br><span class="line">        setArray(newElements);  <span class="comment">// 替换旧的数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它读操作并未加锁，例如foreach：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Object[] elements = getArray();</span><br><span class="line">    <span class="keyword">int</span> len = elements.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> E e = (E) elements[i];</span><br><span class="line">        action.accept(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的读取是弱一致性的，如下以get为例说明：<br><img src="/wiki/%E5%90%8E%E7%AB%AF/Java/Java%E5%B9%B6%E5%8F%91/copy-on-write-get.png"></p><p>上图两个线程分别执行get(0)和remove(0)，执行流程如下时，就会出现读取弱一致性问题</p><ol><li>线程0获取旧数组的地址</li><li>线程1获取旧数组，并copy一份新的</li><li>线程1移除0下标处元素，更新容器中的数组引用为新数组地址</li><li>线程0此时还是持有旧地址，所以还能获取到1，造成不一致</li></ol><p>迭代器弱一致性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">Iterator&lt;Integer&gt; iter = list.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    list.remove(<span class="number">0</span>); <span class="comment">// 此处会拷贝新数组</span></span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    System.out.println(iter.next()); <span class="comment">// 此处遍历的旧数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要觉得弱一致性就不好</p><ul><li>数据库的 MVCC 都是弱一致性的表现</li><li>并发高和一致性是矛盾的，需要权衡</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h2&gt;&lt;h3 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP三次握手四次挥手</title>
    <link href="http://yoursite.com/wiki/%E6%9D%82%E8%B0%88/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/wiki/杂谈/TCP三次握手四次挥手/</id>
    <published>2021-03-30T01:13:33.000Z</published>
    <updated>2021-04-16T02:04:47.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="time-wait"><a href="#time-wait" class="headerlink" title="time_wait"></a>time_wait</h2><p>指的是在四次挥手的最后一步中，主动关闭的一方，回复完ack后，所处于的状态，它有两个作用：</p><ol><li>等待重传ack，因为可能会存在丢包</li><li>避免链接中还有在途中的数据包，当另一个新链接重用这个端口建立后，接受到之前的数据包，污染数据</li></ol><p>这个状态会持续，两个msl，一个msl是2分钟，msl指的是最大段生存周期，即当新链接收到之前链接的数据包时，因为超过它的生存时间，也会丢弃。</p><h2 id="绕过三次握手"><a href="#绕过三次握手" class="headerlink" title="绕过三次握手"></a>绕过三次握手</h2><p>在 Linux 3.7 内核版本之后，提供了 TCP Fast Open 功能，这个功能可以减少 TCP 连接建立的时延。</p><p>三次握手建立连接造成的后果就是，HTTP 请求必须在一个 RTT（从客户端到服务器一个往返的时间）后才能发送。</p><p>通过cookie实现，默认情况下是，当半连接队列满时，为了能继续建立连接，会采用cookie方式，分首次建立链接和非首次</p><ul><li><p>首次链接时：</p><ul><li>客户端发送syn + 请求cookie</li><li>服务端收到后生成cookie， 响应ack + cookie</li><li>客户端存储cookie， 传输数据</li></ul></li><li><p>非首次：</p><ul><li>客户端发送syn + cookie值 + 请求方法</li><li>服务端校验cookie, 响应ack + sync, 再响应数据</li><li>客户端接收数据，再回复ack</li></ul></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;time-wait&quot;&gt;&lt;a href=&quot;#time-wait&quot; class=&quot;headerlink&quot; title=&quot;time_wait&quot;&gt;&lt;/a&gt;time_wait&lt;/h2&gt;&lt;p&gt;指的是在四次挥手的最后一步中，主动关闭的一方，回复完ack后，所处于的状态，它有两个
      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>一致性Hash算法</title>
    <link href="http://yoursite.com/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/wiki/中间件/MySQL/一致性Hash算法/</id>
    <published>2021-03-29T06:05:07.000Z</published>
    <updated>2021-04-19T06:29:54.388Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_40551994/article/details/100991581">https://blog.csdn.net/qq_40551994/article/details/100991581</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_40551994/article/details/100991581&quot;&gt;https://blog.csdn.net/qq_40551994/article/details/100991581&lt;/a&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>磁盘基础知识</title>
    <link href="http://yoursite.com/wiki/%E6%9D%82%E8%B0%88/%E7%A3%81%E7%9B%98%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/wiki/杂谈/磁盘基础知识/</id>
    <published>2021-03-26T07:44:32.000Z</published>
    <updated>2021-04-16T02:04:48.503Z</updated>
    
    <content type="html"><![CDATA[<p>字符设备：按照字符流的方式被有序访问，如串口和键盘<br>块设备：能够随机，不用按顺序访问的，每次访问固定大小的数据片chunks的设备，如磁盘，扇区是它的最小存储单元，即chunks, 一般为512byte，现在有的新硬盘的扇区4K</p><p>操作系统的文件系统不是一个扇区一个扇区的来读数据，太慢了，所以有了block（块）的概念，一个block有多个扇区组成，一般一个block是4K, 即由连续的8个扇区组成。<br>操作系统读写文件时，是一个块一个块的读写的，block才是文件读取和写入的最小单位，同时物理内存也是按block进行划分的。</p><p>程序逻辑地址：默认从0开始编址。</p><p>程序代码未运行时是存储在磁盘上，在启动后代码被装载进内存运行，这个可运行的整体称为进程，它对用代码的组织形式有如下几种：</p><ol><li>分页存储管理：</li></ol><ul><li>用户程序的逻辑地址空间被分为若干个固定大小的页，每个页有一个页号，每页内的每行代码指令有对应的偏移量，即页内地址，实现上是逻辑地址的若干高位做为页号，低位对应页内地址，一般是先确定了页面大小，就能确定页内地址占程序逻辑地址低位个数，剩余高位做页号。页的大小由系统决定，一般为4K，占12位，等于block大小，也有页大小为1k的。</li><li>操作系统给进程分配的内存是以block为单位分配的，每个blcok也中有块号的，将进程中的页分别装入到多个可以不相邻的物理block中，由于最后一页经常不满，所以也不能完全装满block，从而会形成碎片，称为页内碎片。</li><li>因为页可以装入到不连续的block中，所以操作系统会给每个进程建立一个页表来记录每个页号对应的block号。在程序执行时也要通过页表对逻辑地址到物理地址转换，页内地址无需转换，只用通过页表算出每个页对应的block的物理起始地址，加上页内地址，即相对本页起始地址的偏移量，就是每条指令的物理地址。</li></ul><ol start="2"><li>分段存储管理：分页是直接按页大小对程序代码进行划分，段则以程序的逻辑代码片段，如主程序段、子程序段、数据段、栈段等。每个段有一个段号，都从0开始编址，并采用一段连续的地址空间，段的长度由相应的逻辑代码片段长度决定。</li><li>段页式结合：用户程序按代码逻辑分段，每个段再分多个页，每个页装载进可以不相邻的物理block中，此时地址结构为：段号+段内页号+页内地址。</li></ol><p>WAL: Write Ahead Log， 日志文件要早于数据写入磁盘</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;字符设备：按照字符流的方式被有序访问，如串口和键盘&lt;br&gt;块设备：能够随机，不用按顺序访问的，每次访问固定大小的数据片chunks的设备，如磁盘，扇区是它的最小存储单元，即chunks, 一般为512byte，现在有的新硬盘的扇区4K&lt;/p&gt;
&lt;p&gt;操作系统的文件系统不是一
      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Redo日志</title>
    <link href="http://yoursite.com/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/Redo%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/wiki/中间件/MySQL/Redo日志/</id>
    <published>2021-03-26T06:03:11.000Z</published>
    <updated>2021-04-19T06:29:54.778Z</updated>
    
    <content type="html"><![CDATA[<p>表空间：<br>数据页：以页的大小，记录表的数据，属于一个表空间，通过SpaceId 和 PageNum, 即表空间id和页号能确定一个数据页</p><p>undo log 用来事务回滚及MVCC的功能<br>redo log 用来保证事务的持久性，一个redo log记录某个数据页中某偏移量处的数据要修改成什么数据</p><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>当数据库对数据做修改的时候，需要把数据页从磁盘读到buffer pool中，然后在buffer pool中进行修改，那么这个时候buffer pool中的数据页就与磁盘上的数据页内容不一致，称buffer pool的数据页为dirty page 脏数据，如果这个时候发生非正常的DB服务重启，那么这些数据还在内存，并没有同步到磁盘文件中，也就是会发生数据丢失，如果这个时候，能够在有一个文件，当buffer pool 中的data page变更结束后，把相应修改记录记录到这个文件，那么当DB服务发生crash的情况，恢复DB的时候，也可以根据这个文件的记录内容，重新将修改的数据更新到磁盘数据页文件，保证数据的完整性。</p><p>这个文件就是redo log ，用于记录 数据修改后的记录，顺序记录。它可以带来这些好处：</p><ul><li>当buffer pool中的dirty page 还没有刷新到磁盘的时候，发生crash，启动服务后，可通过redo log 找到需要重新刷新到磁盘文件的记录</li><li>如果将buffer pool中的数据直接flush到disk file，是一个随机IO，效率较差，而把buffer pool中的数据记录到redo log，是一个顺序IO，可以提高事务提交的速度</li></ul><h3 id="redo参数"><a href="#redo参数" class="headerlink" title="redo参数"></a>redo参数</h3><ul><li>innodb_log_files_in_group：redo log 文件的个数，命名方式如：ib_logfile0，iblogfile1… iblogfilen。默认2个，最大100个。</li><li>innodb_log_file_size：文件设置大小，默认值为 48M，最大值为512G，注意最大值指的是整个 redo log系列文件之和，即（innodb_log_files_in_group变量值 * innodb_log_file_size ）不能大于最大值512G。</li><li>innodb_log_group_home_dir：文件存放路径</li><li>innodb_log_buffer_size：Redo Log 缓存区，默认8M，可设置1-8M。延迟事务日志写入磁盘，把redo log 放到该缓冲区，然后根据innodb_flush_log_at_trx_commit参数的设置，再把日志从buffer中flush到磁盘中。</li><li>innodb_flush_log_at_trx_commit<ul><li>innodb_flush_log_at_trx_commit=1，每次commit都会把redo log从redo log buffer写入到system，并通过fsync强制刷新到磁盘文件中。</li><li>innodb_flush_log_at_trx_commit=2，每次事务提交时MySQL会把日志从redo log buffer写入到system，但只写入到file system buffer，由系统内部来fsync到磁盘文件。如果数据库实例crash，不会丢失redo log，但是如果服务器crash，由于file system buffer还来不及fsync到磁盘文件，所以会丢失这一部分的数据。</li><li>innodb_flush_log_at_trx_commit=0，事务发生过程，日志一直记录在redo log buffer中，跟其他设置一样，但是在事务提交时，不产生redo 写操作，而是MySQL内部每秒操作一次，从redo log buffer，把数据写入到系统中去。如果发生crash，即丢失1s内的事务修改操作。由于进程调度策略问题,这个“每秒执行一次 flush(刷到磁盘)操作”并不是保证100%的“每秒”。</li></ul></li></ul><h3 id="redo-buffer"><a href="#redo-buffer" class="headerlink" title="redo buffer"></a>redo buffer</h3><p>Redo log文件以ib_logfile_x_命名，Redo log 以顺序的方式写入文件文件，写满时则回溯到第一个文件，进行覆盖写。（但在做redo checkpoint时，也会更新第一个日志文件的头部checkpoint标记，所以严格来讲也不算顺序写）。</p><p>实际上redo log有两部分组成：redo log buffer跟redo log file。buffer pool中把数据修改情况记录到redo log buffer，出现以下情况，再把redo log buffer刷下到redo log file：</p><ol><li>Redo log buffer空间不足</li><li>事务提交（依赖innodb_flush_log_at_trx_commit参数设置）</li><li>后台线程</li><li>做checkpoint</li><li>实例shutdown</li><li>binlog切换</li></ol><h3 id="一条redo-log记录了什么"><a href="#一条redo-log记录了什么" class="headerlink" title="一条redo log记录了什么"></a>一条redo log记录了什么</h3><p>重做日志格式: 不同的数据库操作会有对应的重做日志格式。此外，由于InnoDB存储引擎的存储管理是基于页的，故其重做日志格式也是基于页的。虽然有着不同的重做日志格式，但他们有着通用的头部格式，通用的头部格式由一下3部分组成</p><ul><li>redo_log_type 重做日志类型</li><li>space: 表空间ID</li><li>page_no 页的偏移量</li><li>redo log body: 根据重做日志类型的不对，会有不同的存储内容</li></ul><p>为了应对InnoDB各种各样不同的需求，到MySQL 8.0为止，已经有多达65种的REDO记录。用来记录这不同的信息，恢复时需要判断不同的REDO类型，来做对应的解析。根据REDO记录不同的作用对象，可以将这65中REDO划分为三个大类：作用于Page，作用于Space以及提供额外信息的Logic类型。</p><ol><li>作用于Page的REDO: 这类REDO占所有REDO类型的绝大多数，根据作用的Page的不同类型又可以细分为，Index Page REDO，Undo Page REDO，Rtree Page REDO等。比如MLOG_REC_INSERT，MLOG_REC_UPDATE_IN_PLACE，MLOG_REC_DELETE三种类型分别对应于Page中记录的插入，修改以及删除。这里还是以MLOG_REC_UPDATE_IN_PLACE为例来看看其中具体的内容：其中，Type就是MLOG_REC_UPDATE_IN_PLACE类型，Space ID 和 Page Number唯一标识一个Page页，这三项是所有REDO记录都需要有的头信息，后面的是MLOG_REC_UPDATE_IN_PLACE类型独有的，其中Record Offset用给出要修改的记录在Page中的位置偏移，Update Field Count说明记录里有几个Field要修改，紧接着对每个Field给出了Field编号(Field Number)，数据长度（Field Data Length）以及数据（Filed Data）。</li><li>作用于Space的REDO：这类REDO针对一个Space文件的修改，如MLOG_FILE_CREATE，MLOG_FILE_DELETE，MLOG_FILE_RENAME分别对应对一个Space的创建，删除以及重命名。由于文件操作的REDO是在文件操作结束后才记录的，因此在恢复的过程中看到这类日志时，说明文件操作已经成功，因此在恢复过程中大多只是做对文件状态的检查，以MLOG_FILE_CREATE来看看其中记录的内容：同样的前三个字段还是Type，Space ID和Page Number，由于是针对Space的操作，这里的Page Number永远是0。在此之后记录了创建的文件flag以及文件名，用作重启恢复时的检查。</li><li>提供额外信息的Logic REDO: 除了上述类型外，还有少数的几个REDO类型不涉及具体的数据修改，只是为了记录一些需要的信息，比如最常见的MLOG_MULTI_REC_END就是为了标识一个REDO组，也就是一个完整的原子操作的结束。</li></ol><h3 id="log-block"><a href="#log-block" class="headerlink" title="log block"></a>log block</h3><p>前面说明了在InnoDB存储引擎中一条redo log记录了什么，现在说一下它是如何进行物理存储的管理。</p><p>首先一条redo log内容大小是不确定的，但是在写入磁盘时是按固定大小512byte的log block写入的，如果redo log较大会占用多个log block, 较小时一个log block会存有多个redo log。另外redo log buffer、redo log file都是以log block的方式进行保存的。</p><p>一个log block块除了存日志本身之外，还由日志块头(log block header)及日志块尾(log block tailer)两部分组成。重做日志头一共占用12字节，重做日志尾占用8字节。故每个重做日志块实际可以存储的大小为492字节(512-12-8)，如图显示重做日志块缓存的结构：</p><p><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/Redo%E6%97%A5%E5%BF%97/log-block.jpg"></p><p>如图显示了重做日志缓存的结果，可以发现，重做日志缓存由每个为512字节大小的日志块所组成，日志块由三部分组成，依次为日志块头(log block header)、日志内容(log body)、日志块尾(log block tailer)。log block header由4部分组成，分别占4、2、2、4字节，共12字节。</p><ul><li>LOG_BLOCK_HDR_NO：log buffer 是由log block组成，在内部log buffer就好似一个数组，因此LOG_BLOCK_HDR_NO用来标记这个数组中的位置，尤其是递增并且循环使用的。占用4个字节。但是由于第一位用来判断是否是flush bit，所以最大值为2G（2的31次方）</li><li>LOG_BLOCK_HDR_DATA_LEN：占用2个字节，表示log block所占用的大小，当log block被写满时，该值为0x200,表示使用全部的log block空间，即占用512字节</li><li>LOG_BLOCK_FIRST_REC_GROUP：占用2个字节，表示log block中第一个日志所在的偏移量，因为存在该log block开头保存有上一个日志剩余数据的情况。如果该值的大小和LOG_BLOCK_HDR_DATA_LEN相同，则表示当前log block不包含新的日志，只保存了之前日志剩余数据的情况。如事务T1的重做日志1占用762字节，事务T2的重做日志占用100字节。由于每个log block实际只能保存492字节，因此其在log buffer的情况应该如图所示：</li></ul><p><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/Redo%E6%97%A5%E5%BF%97/log-block-header.jpg"></p><p>从图可以观察到，由于事务T1的重做日志占用792字节，因此需要占用两个log block。左侧的log block中 LOG_BLOCK_FIRST_REC_GROUP 为 12，即前12个字节是log block header, 然后第一个存储日志的开始位置，在第二个log block中，由于包含了之前事务T1的重做日志，事务T2的日志才是log block中第一日志，因此该log block的LOG_BLOCK_FIRST_REC_GROUP为（270+12）</p><ul><li>LOG_BLOCK_CHECKPOINT_NO占用4字节，表示该log block最后被写入时的检查点，写Block时的next_checkpoint_number，用来发现文件的循环使用</li><li>log block tailer 只由1个部分组成，且值和LOG_BLOCK_HDR_NO相同，并在函数log_block_init中被初始化 LOG_BLOCK_TRL_NO 大小为4字节</li></ul><h3 id="log-group"><a href="#log-group" class="headerlink" title="log group"></a>log group</h3><p>log group 重做日志组，是一个逻辑的概念，并没有一个实际的物理文件来表示log group信息，log group 由多个重做日志文件组成。每个log group中的日志文件是相同的。</p><p>InnoDB存储引擎默认只能有一个log group。</p><h3 id="redo-log-file"><a href="#redo-log-file" class="headerlink" title="redo log file"></a>redo log file</h3><p>重做日志文件中存储就是之前log buffer中保存的log block。因此其也是根据块的方式进行物理存储的管理，每个块的大小与log block一样，同样为512字节，在InnoDB存储引擎运行过程中，log buffer根据一定的规则将内存中的log block刷新到磁盘。这个规则具体是</p><ul><li>事务提交时</li><li>当log buffer中有一半的内存空间已经被使用时</li><li>log checkpoint时</li></ul><p>对于log block的写入追加在redo log file最后部分，当一个redo log file写满时，会接着写下一个redo log file，其使用的方式为round-robin。</p><p>虽然log block总是在redo log file的最后部分进行写入，有的读者可能以为对redo log file的写入时顺序的，其实不是，因为redo log file除了保存log buffer刷新到磁盘的log block，还保存了一些其他的信息，这些信息一共占用2KB大小，即每个redo log file的前2KB的部分不保存log block信息，对于log group中的第一个redo log file,其前2KB的部分保存4个512字节大小的块，其中存放的内容为</p><p><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/Redo%E6%97%A5%E5%BF%97/redo-log-file-header.jpg"></p><p>需要特别注意，上述信息仅在每个log group的第一个redo log file中进行存储，log group中的其余redo log file仅保留这些空间，但不保存上述信息。正因为保存了这些信息，就意味着对redo log file 的写入并不是完全顺序的。因为其除了log block的写入操作，还需要更新前2KB部分的信息，这些信息对于InnoDB存储引擎的恢复操作来说非常关键和重要，故log group与redo log file 之间的关系如下</p><p><img src="/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/Redo%E6%97%A5%E5%BF%97/log-group.jpg"></p><p>在log filer header 后面的部分为InnoDB存储引擎保存的checkpoint(检查点)值，其设计是交替写入。这样的设计避免了因介质失败而导致无法找到可用的checkpoint的情况</p><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>在innodb存储引擎中数据是按照表空间来组织存储的，即表空间是表空间文件，是实际存在的物理文件。</p><p>sys表空间：默认情况下，MySQL会初始化一个大小为12MB，名为ibdata1文件，并且随着数据的增多，它会自动扩容。这个ibdata1文件是系统表空间，也是默认的表空间，也是默认的表空间物理文件，也是传说中的共享表空间。</p><p>file per table 表空间：如果你想让每一个数据库表都有一个单独的表空间文件的话，可以通过参数innodb_file_per_table设置。这个参数只有在MySQL5.6或者是更高的版本中才可以使用。独立的表空间文件命名规则：表名.ibd。注意：独立表空间文件中仅存放该表对应数据、索引、insert buffer bitmap。其余的诸如：undo信息、insert buffer 索引页、double write buffer 等信息依然放在默认表空间，也就是共享表空间中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># my.cnf   </span><br><span class="line">#配置sys表空间</span><br><span class="line">innodb_data_file_path&#x3D;&#x2F;dir1&#x2F;ibdata1:2000M;&#x2F;dir2&#x2F;ibdata2:2000M:autoextend</span><br><span class="line"></span><br><span class="line"># file per table 表空间</span><br><span class="line">innodb_file_per_table&#x3D;ON</span><br></pre></td></tr></table></figure><p>最后再简述一下这种file per table的优缺点：</p><p>优点：</p><ul><li>提升容错率，表A的表空间损坏后，其他表空间不会收到影响。s</li><li>使用MySQL Enterprise Backup快速备份或还原在每表文件表空间中创建的表，不会中断其他InnoDB 表的使用</li></ul><p>缺点：对fsync系统调用来说不友好，如果使用一个表空间文件的话单次系统调用可以完成数据的落盘，但是如果你将表空间文件拆分成多个。原来的一次fsync可能会就变成针对涉及到的所有表空间文件分别执行一次fsync，增加fsync的次数。</p><p>临时表空间：临时表空间用于存放用户创建的临时表和磁盘内部临时表。参数innodb_temp_data_file_path定义了临时表空间的一些名称、大小、规格属性<br>独享表空间：独享表空间存储方式使用“.ibd”文件来存放数据，且每个表一个“.ibd”文件，文件存放在和MyISAM数据相同的位置。<br>共享表空间：如果选用共享存储表空间来存放数据，则会使用 ibdata 文件来存放，所有表共同使用一个（或者多个，可自行配置）ibdata文件。<br>undo表空间：相信你肯定听过说undolog，常见的当你的程序想要将事物rollback时，底层MySQL其实就是通过这些undo信息帮你回滚的。在MySQL的设定中，有一个表空间可以专门用来存放undolog的日志文件。然而，默认配置是会将undolog放置到系统表空间中。如果你的MySQL是新安装的，那你可以通过查看变量：innodb_undo_tablespaces，看看你的MySQL undo表空间的使用情况。</p><p>那undo log到底是该使用默认的配置放在系统表空间呢？还是该放在undo表空间呢？<br>这其实取决服务器使用的存储卷的类型。<br>如果是SSD存储，那推荐将undo info存放在 undo表空间中。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="http://mysql.taobao.org/monthly/2020/02/01/">http://mysql.taobao.org/monthly/2020/02/01/</a></li><li><a href="https://blog.csdn.net/linuxheik/article/details/62043450">https://blog.csdn.net/linuxheik/article/details/62043450</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;表空间：&lt;br&gt;数据页：以页的大小，记录表的数据，属于一个表空间，通过SpaceId 和 PageNum, 即表空间id和页号能确定一个数据页&lt;/p&gt;
&lt;p&gt;undo log 用来事务回滚及MVCC的功能&lt;br&gt;redo log 用来保证事务的持久性，一个redo log记
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>B+Tree原理</title>
    <link href="http://yoursite.com/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/B-Tree%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/wiki/中间件/MySQL/B-Tree原理/</id>
    <published>2021-03-26T05:56:58.000Z</published>
    <updated>2021-04-19T06:29:54.447Z</updated>
    
    <content type="html"><![CDATA[<p>局部性原理: 当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。<br>磁盘预读：一般操作系统将内存和磁盘空间分为大小相等的块，称为页，一般大小为4k。<br>内存和磁盘以页为大小进行数据交换，程序运行时要读取的数据不在内存中时，会发生缺页中断，磁盘会从缺失页连续读取多页进内存，然后程序继续运行。</p><p>B+Tree节点： 节点大小一般设计等于一个页的大小，实现一个节点一次IO就能读进内存，由于根节点常驻内存，所以一次索引最多用h-1次IO，每个节点的出度d很大，通常超100，因此h很小，通常不超过3层，对这种3层每个节点100的情况下，3次IO至少可检索100万的数据。</p><p>从上面分析可知，每个节点的出度d越大，则可支持检索的数据量越大，由于B+Tree相对于B-Tree，非叶子节点不存data，因此可容纳更多key。</p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;局部性原理: 当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。&lt;br&gt;磁盘预读：一般操作系统将内存和磁盘空间分为大小相等的块，称为页，一般大小为4k。&lt;br&gt;内存和磁盘以页为大小进行数据交换，程序运行时要读取的数据不在内存中时，会发
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>事务隔离与MVCC</title>
    <link href="http://yoursite.com/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E4%B8%8EMVCC/"/>
    <id>http://yoursite.com/wiki/中间件/MySQL/事务隔离与MVCC/</id>
    <published>2021-03-26T01:51:14.000Z</published>
    <updated>2021-04-19T06:29:54.165Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/weixin_30342639/article/details/107552255">https://blog.csdn.net/weixin_30342639/article/details/107552255</a></p><p><a href="https://blog.csdn.net/qq_44961149/article/details/108420073">https://blog.csdn.net/qq_44961149/article/details/108420073</a></p><p>卡内基梅隆大学sql92标准txt地址: <a href="http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt">http://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt</a></p><h2 id="事务的特点（ACID）"><a href="#事务的特点（ACID）" class="headerlink" title="事务的特点（ACID）"></a>事务的特点（ACID）</h2><ul><li>原子性：对数据库的一系列的操作，要么都是成功，要么都是失败，不可能出现部分成功或者部分失败的情况；原子性，在 InnoDB 里面是通过 undo log 来实现的，它记录了数据修改之前的值（逻辑日志），一旦发生异常，就可以用 undo log 来实现回滚操作。</li><li>隔离性：在数据库里面会有很多的 事务同时去操作我们的同一张表或者同一行数据，必然会产生一些并发或者干扰的操作， 那么我们对隔离性的定义，就是这些很多个的事务，对表或者行的并发操作，应该是透明的，互相不干扰的。通过这种方式，我们最终也是保证业务数据的一致性。</li><li>持久性：我们对数据库的任意的操作，增删改，只要事务提交成功，那么结果就是永久性的，不可能因为我们系统宕机或者重启了数据库的服务器，它又恢复到原来的状态了；持久性是通过 redo log 和 double write 双写缓冲来实现的。</li><li>一致性：是数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。上面三个特性保证了一致性。</li></ul><p>事务的实现原理：</p><ul><li>事务的原子性是通过 undo log 来实现的</li><li>事务的持久性是通过 redo log 来实现的</li><li>事务的隔离性是通过（读写锁+MVCC）来实现的</li><li>事务的一致性是通过原子性、持久性、隔离性来实现的</li></ul><p>隔离性产生的问题，sql92标准中搜索【4.28 SQL-transactions】</p><ul><li>P1 (“Dirty read”): SQL-transaction T1 modifies a row. SQL-transaction T2 then reads that row before T1 performs a COMMIT. If T1 then performs a ROLLBACK, T2 will have read a row that was never committed and that may thus be considered to have never existed.</li><li>P2 (“Non-repeatable read”): SQL-transaction T1 reads a row. SQL-transaction T2 then modifies or deletes that row and performs a COMMIT. If T1 then attempts to reread the row, it may receive the modified value or discover that the row has been deleted.</li><li>P3 (“Phantom”): SQL-transaction T1 reads the set of rows N that satisfy some <search condition="">. SQL-transaction T2 then executes SQL-statements that generate one or more rows that satisfy the <search condition=""> used by SQL-transaction T1. If SQL-transaction T1 then repeats the initial read with the same <search condition="">, it obtains a different collection of rows.</search></search></search></li><li>幻读译：事务T1通过where条件读了N行的集合，事务T2的sql语句生成了一行或多行数据满足事务T1的where条件，事务T1通过原来的where条件再次读取，会读到不同的数据集，像出现幻觉一样。</li></ul><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul><li>读未提交（Read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。<ul><li>RU 隔离级别：不加锁</li></ul></li><li>读提交（Read committed）：一个事务提交之后，它做的变更才会被其他事务看到。<ul><li>RC 隔离级别下，普通的 select 都是快照读，使用 MVCC 实现，解决了脏读问题。</li><li>加锁的 select 都使用记录锁，因为没有 Gap Lock</li><li>除了两种特殊情况——外键约束检查(foreign-key constraint checking)以及重复键检查(duplicate-key checking)时会使用间隙锁封锁区间；所以 RC 会出现幻读的问题。</li></ul></li><li>可重复读（Repeatable read）:一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。<ul><li>RR 隔离级别下，普通的 select 使用快照读(snapshot read)，底层使用 MVCC 来实现</li><li>加锁的 select(select … in share mode / select … for update)以及更新操作update, delete 等语句使用当前读（current read）（当前读inndb可能会导致幻读问题），底层使用记录锁、或者间隙锁、临键锁。</li></ul></li><li>串行化（Serializable ）:顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。所有的 select 语句都会被隐式的转化为 select … in share mode，会和update、delete 互斥</li></ul><h2 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h2><p>官网八锁文档地址：<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html</a></p><ul><li>Shared and Exclusive Locks：共享锁-排他锁</li><li>Intention Locks：意向锁，可细分为意向共享锁和意向排他锁</li><li>Record Locks：记录锁</li><li>Gap Locks：间隙锁</li><li>Next-Key Locks：临键锁</li><li>Insert Intention Locks：插入意向锁</li><li>AUTO-INC Locks：自增锁</li><li>Predicate Locks for Spatial Indexes：空间索引预测锁</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://blog.csdn.net/qq_44961149/article/details/108420073">https://blog.csdn.net/qq_44961149/article/details/108420073</a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_30342639/article/details/107552255&quot;&gt;https://blog.csdn.net/weixin_30342639/article/details/107552255
      
    
    </summary>
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring的类加载机制</title>
    <link href="http://yoursite.com/wiki/%E5%90%8E%E7%AB%AF/Spring/Spring%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/wiki/后端/Spring/Spring的类加载机制/</id>
    <published>2021-03-25T01:51:37.000Z</published>
    <updated>2021-04-16T02:04:47.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OverridingClassLoader"><a href="#OverridingClassLoader" class="headerlink" title="OverridingClassLoader"></a>OverridingClassLoader</h2><p>OverridingClassLoader 是 Spring 自定义的类加载器，构造方法中要指定自己的父类加载器，默认会先自己加载(excludedPackages 或 excludedClasses 例外)，只有加载不到才会委托给双亲加载，这就破坏了 JDK 的双亲委派模式。</p><p>它的继承链很简单：OverridingClassLoader -&gt; DecoratingClassLoader -&gt; java的ClassLoader</p><p>证明OverridingClassLoader的加载是先自己加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.OverridingClassLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpring</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOverridingClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassLoader appClassLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加到 excludedPackages 或 excludedClasses 的类就不会被代理的 ClassLoader 加载</span></span><br><span class="line">        <span class="comment">// 而会使用 JDK 默认的双亲委派机制</span></span><br><span class="line">        <span class="comment">// 因此 TestBean 不会被 OverridingClassLoader 重新加载，而 ITestBean 会重新加载</span></span><br><span class="line">        OverridingClassLoader overridingClassLoader = <span class="keyword">new</span> OverridingClassLoader(appClassLoader);</span><br><span class="line">        overridingClassLoader.excludeClass(TestBean.class.getName());</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; excludedClazz1 = appClassLoader.loadClass(TestBean.class.getName());</span><br><span class="line">        Class&lt;?&gt; excludedClazz2 = overridingClassLoader.loadClass(TestBean.class.getName());</span><br><span class="line">        Assert.assertTrue(<span class="string">&quot;TestBean will exclude from OverridingClassLoader, so no reload&quot;</span>,</span><br><span class="line">                excludedClazz1 == excludedClazz2);</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; nonExcludedClazz1 = appClassLoader.loadClass(ITestBean.class.getName());</span><br><span class="line">        Class&lt;?&gt; nonExcludedClazz2 = overridingClassLoader.loadClass(ITestBean.class.getName());</span><br><span class="line">        Assert.assertFalse(<span class="string">&quot;ITestBean will not exclude, so reload again&quot;</span>,</span><br><span class="line">                nonExcludedClazz1 == nonExcludedClazz2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ITestBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，ITestBean 被 OverridingClassLoader 重新加载了一次，而 TestBean 添加到了 excludedClasses 中还是使用 JDK 的默认加载器，因此不会被重新加载。</p><h2 id="DecoratingClassLoader"><a href="#DecoratingClassLoader" class="headerlink" title="DecoratingClassLoader"></a>DecoratingClassLoader</h2><p>DecoratingClassLoader 很简单，内部维护了两个集合，即excludedPackages和excludedClasses，如果你不想你的类被自定义的类加载器管理，可以把它添加到这两个集合中，这样仍使用 JDK 的默认类加载机制。上面代码中就是excludeClass排除了TestBean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; excludedPackages = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">8</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; excludedClasses = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// isExcluded 返回 true 时仍使用 JDK 的默认类加载机制，返回 false 时自定义的类加载器生效</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExcluded</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.excludedClasses.contains(className)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String packageName : <span class="keyword">this</span>.excludedPackages) &#123;</span><br><span class="line">        <span class="keyword">if</span> (className.startsWith(packageName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;OverridingClassLoader&quot;&gt;&lt;a href=&quot;#OverridingClassLoader&quot; class=&quot;headerlink&quot; title=&quot;OverridingClassLoader&quot;&gt;&lt;/a&gt;OverridingClassLoader&lt;/
      
    
    </summary>
    
      <category term="后端" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Spring" scheme="http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/Spring/"/>
    
    
  </entry>
  
</feed>
